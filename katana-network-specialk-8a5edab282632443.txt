Directory structure:
â””â”€â”€ katana-network-specialk/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ build.js
    â”œâ”€â”€ package.json
    â”œâ”€â”€ test.ts
    â”œâ”€â”€ TODO.md
    â”œâ”€â”€ tsconfig.json
    â”œâ”€â”€ txtx.yml
    â”œâ”€â”€ WARP.md
    â”œâ”€â”€ .env.example
    â”œâ”€â”€ contracts/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ IAgoraFaucet.sol
    â”‚   â”œâ”€â”€ IBatchDistributor.sol
    â”‚   â”œâ”€â”€ IBundler3.sol
    â”‚   â”œâ”€â”€ ICreate2Deployer.sol
    â”‚   â”œâ”€â”€ ICreateX.sol
    â”‚   â”œâ”€â”€ IDeterministicDeploymentProxy.sol
    â”‚   â”œâ”€â”€ IERC20.sol
    â”‚   â”œâ”€â”€ IERC4337.sol
    â”‚   â”œâ”€â”€ IERC4626.sol
    â”‚   â”œâ”€â”€ IGnosisSafe.sol
    â”‚   â”œâ”€â”€ IGnosisSafeL2.sol
    â”‚   â”œâ”€â”€ ILxLyBridge.sol
    â”‚   â”œâ”€â”€ IMulticall3.sol
    â”‚   â”œâ”€â”€ IMultiSend.sol
    â”‚   â”œâ”€â”€ IMultiSendCallOnly.sol
    â”‚   â”œâ”€â”€ IPermit2.sol
    â”‚   â”œâ”€â”€ IRIP7212.sol
    â”‚   â”œâ”€â”€ ISafeExecutor.sol
    â”‚   â”œâ”€â”€ ISushiRouter.sol
    â”‚   â”œâ”€â”€ MultiCall1.sol
    â”‚   â”œâ”€â”€ MultiCall2.sol
    â”‚   â”œâ”€â”€ AAv0.6.0/
    â”‚   â”‚   â”œâ”€â”€ IEntryPoint.sol
    â”‚   â”‚   â”œâ”€â”€ IERC4337Account.sol
    â”‚   â”‚   â””â”€â”€ ISenderCreator.sol
    â”‚   â”œâ”€â”€ AAv0.7.0/
    â”‚   â”‚   â”œâ”€â”€ IEntryPoint.sol
    â”‚   â”‚   â”œâ”€â”€ IEntryPointSimulations.sol
    â”‚   â”‚   â”œâ”€â”€ IERC4337Account.sol
    â”‚   â”‚   â””â”€â”€ ISenderCreator.sol
    â”‚   â”œâ”€â”€ agglayer/
    â”‚   â”‚   â”œâ”€â”€ IBridgeExtension.sol
    â”‚   â”‚   â”œâ”€â”€ IBridgeL2SovereignChain.sol
    â”‚   â”‚   â”œâ”€â”€ IGlobalExitRootManagerL2SovereignChain.sol
    â”‚   â”‚   â”œâ”€â”€ IPolygonZkEVMDeployer.sol
    â”‚   â”‚   â”œâ”€â”€ IPolygonZkEVMTimelock.sol
    â”‚   â”‚   â””â”€â”€ IProxyAdmin.sol
    â”‚   â”œâ”€â”€ morpho/
    â”‚   â”‚   â”œâ”€â”€ IMetaMorpho.sol
    â”‚   â”‚   â”œâ”€â”€ IMetaMorphoFactory.sol
    â”‚   â”‚   â”œâ”€â”€ IMorphoAdaptiveIRM.sol
    â”‚   â”‚   â”œâ”€â”€ IMorphoBlue.sol
    â”‚   â”‚   â”œâ”€â”€ IMorphoCallbacks.sol
    â”‚   â”‚   â”œâ”€â”€ IMorphoChainlinkOracleV2.sol
    â”‚   â”‚   â”œâ”€â”€ IMorphoChainlinkOracleV2Factory.sol
    â”‚   â”‚   â”œâ”€â”€ IMorphoOracle.sol
    â”‚   â”‚   â”œâ”€â”€ IPreLiquidation.sol
    â”‚   â”‚   â”œâ”€â”€ IPreLiquidationCallback.sol
    â”‚   â”‚   â”œâ”€â”€ IPreLiquidationFactory.sol
    â”‚   â”‚   â””â”€â”€ IPublicAllocator.sol
    â”‚   â”œâ”€â”€ nft/
    â”‚   â”‚   â”œâ”€â”€ IBulkWriter.sol
    â”‚   â”‚   â”œâ”€â”€ ICatalogFactory.sol
    â”‚   â”‚   â”œâ”€â”€ ICatalogUtils.sol
    â”‚   â”‚   â”œâ”€â”€ IRenderUtils.sol
    â”‚   â”‚   â””â”€â”€ ITokenAttributesRepository.sol
    â”‚   â”œâ”€â”€ opensea/
    â”‚   â”‚   â”œâ”€â”€ IConduit.sol
    â”‚   â”‚   â”œâ”€â”€ IConduitController.sol
    â”‚   â”‚   â””â”€â”€ ISeaport.sol
    â”‚   â”œâ”€â”€ oracles/
    â”‚   â”‚   â”œâ”€â”€ chainlink/
    â”‚   â”‚   â”‚   â”œâ”€â”€ IAggregatorV3Interface.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ IAUSDUSDOracle.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ IBTCUSDOracle.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ IEACAggregatorProxy.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ IETHUSDOracle.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ IJitoSOLSOLOracle.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ IJitoSOLUSDOracle.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ ILBTCBTCOracle.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ ILBTCUSDOracle.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ ILINKUSDOracle.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ IMORPHOUSDOracle.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ IPOLUSDOracle.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ ISOLUSDOracle.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ ISUSHIUSDOracle.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ IUSDCUSDOracle.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ IUSDSUSDOracle.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ IUSDTUSDOracle.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ IWBTCBTCOracle.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ IWBTCUSDOracle.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ IweETHETHOracle.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ IwstETHETHOracle.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ IYFIUSDOracle.sol
    â”‚   â”‚   â”‚   â””â”€â”€ IyUSDUSDOracle.sol
    â”‚   â”‚   â””â”€â”€ redstone/
    â”‚   â”‚       â”œâ”€â”€ IADAUSDOracle.sol
    â”‚   â”‚       â”œâ”€â”€ IAUSDUSDOracle.sol
    â”‚   â”‚       â”œâ”€â”€ IBTCUSDOracle.sol
    â”‚   â”‚       â”œâ”€â”€ IETHUSDOracle.sol
    â”‚   â”‚       â”œâ”€â”€ ILBTCBTCOracle.sol
    â”‚   â”‚       â”œâ”€â”€ IRedstoneAggregator.sol
    â”‚   â”‚       â”œâ”€â”€ ISUIUSDOracle.sol
    â”‚   â”‚       â”œâ”€â”€ IWBTCUSDOracle.sol
    â”‚   â”‚       â”œâ”€â”€ IweETHETHOracle.sol
    â”‚   â”‚       â”œâ”€â”€ IweETHUSDOracle.sol
    â”‚   â”‚       â”œâ”€â”€ IwstETHstETHOracle.sol
    â”‚   â”‚       â”œâ”€â”€ IwstETHUSDOracle.sol
    â”‚   â”‚       â””â”€â”€ IXRPUSDOracle.sol
    â”‚   â”œâ”€â”€ sushi/
    â”‚   â”‚   â”œâ”€â”€ IBladePoolRegister.sol
    â”‚   â”‚   â”œâ”€â”€ IRedSnwapper.sol
    â”‚   â”‚   â”œâ”€â”€ IRouteProcessor8.sol
    â”‚   â”‚   â”œâ”€â”€ ISushiTickLens.sol
    â”‚   â”‚   â”œâ”€â”€ ISushiV2Factory.sol
    â”‚   â”‚   â”œâ”€â”€ ISushiV3Factory.sol
    â”‚   â”‚   â”œâ”€â”€ ISushiV3PositionManager.sol
    â”‚   â”‚   â””â”€â”€ IUniswapV2Router02.sol
    â”‚   â”œâ”€â”€ tokens/
    â”‚   â”‚   â”œâ”€â”€ IAUSD.sol
    â”‚   â”‚   â”œâ”€â”€ IBTCK.sol
    â”‚   â”‚   â”œâ”€â”€ IbvUSD.sol
    â”‚   â”‚   â”œâ”€â”€ IJitoSOL.sol
    â”‚   â”‚   â”œâ”€â”€ IKAT.sol
    â”‚   â”‚   â”œâ”€â”€ ILBTC.sol
    â”‚   â”‚   â”œâ”€â”€ IMORPHO.sol
    â”‚   â”‚   â”œâ”€â”€ IPOL.sol
    â”‚   â”‚   â”œâ”€â”€ IPROVE.sol
    â”‚   â”‚   â”œâ”€â”€ ISUSHI.sol
    â”‚   â”‚   â”œâ”€â”€ IuBTC.sol
    â”‚   â”‚   â”œâ”€â”€ IuSOL.sol
    â”‚   â”‚   â”œâ”€â”€ IuSUI.sol
    â”‚   â”‚   â”œâ”€â”€ IuXRP.sol
    â”‚   â”‚   â”œâ”€â”€ IweETH.sol
    â”‚   â”‚   â”œâ”€â”€ IwstETH.sol
    â”‚   â”‚   â””â”€â”€ IYFI.sol
    â”‚   â”œâ”€â”€ utils/
    â”‚   â”‚   â”œâ”€â”€ BokutoAddresses.sol
    â”‚   â”‚   â”œâ”€â”€ BokutoOriginAddresses.sol
    â”‚   â”‚   â”œâ”€â”€ KatanaAddresses.sol
    â”‚   â”‚   â”œâ”€â”€ KatanaOriginAddresses.sol
    â”‚   â”‚   â”œâ”€â”€ TataraAddresses.sol
    â”‚   â”‚   â””â”€â”€ TataraOriginAddresses.sol
    â”‚   â”œâ”€â”€ vb/
    â”‚   â”‚   â”œâ”€â”€ IBridgedVaultBridgeEth.sol
    â”‚   â”‚   â”œâ”€â”€ IGenericCustomToken.sol
    â”‚   â”‚   â”œâ”€â”€ IMigrationManager.sol
    â”‚   â”‚   â”œâ”€â”€ INativeConverter.sol
    â”‚   â”‚   â”œâ”€â”€ IVaultBridgeToken.sol
    â”‚   â”‚   â”œâ”€â”€ converters/
    â”‚   â”‚   â”‚   â”œâ”€â”€ IUSDCNativeConverter.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ IUSDSNativeConverter.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ IUSDTNativeConverter.sol
    â”‚   â”‚   â”‚   â”œâ”€â”€ IWBTCNativeConverter.sol
    â”‚   â”‚   â”‚   â””â”€â”€ IWETHNativeConverter.sol
    â”‚   â”‚   â””â”€â”€ tokens/
    â”‚   â”‚       â”œâ”€â”€ IbvbEth.sol
    â”‚   â”‚       â”œâ”€â”€ IbvbUSDC.sol
    â”‚   â”‚       â”œâ”€â”€ IbvbUSDS.sol
    â”‚   â”‚       â”œâ”€â”€ IbvbUSDT.sol
    â”‚   â”‚       â”œâ”€â”€ IbvbWBTC.sol
    â”‚   â”‚       â”œâ”€â”€ IvbETH.sol
    â”‚   â”‚       â”œâ”€â”€ IvbUSDC.sol
    â”‚   â”‚       â”œâ”€â”€ IvbUSDS.sol
    â”‚   â”‚       â”œâ”€â”€ IvbUSDT.sol
    â”‚   â”‚       â””â”€â”€ IvbWBTC.sol
    â”‚   â””â”€â”€ yearn/
    â”‚       â”œâ”€â”€ IYearnVault.sol
    â”‚       â”œâ”€â”€ IYvAUSD.sol
    â”‚       â””â”€â”€ IYvWETH.sol
    â”œâ”€â”€ dist-mcp/
    â”‚   â””â”€â”€ README.md
    â”œâ”€â”€ examples/
    â”‚   â”œâ”€â”€ ausd-yearnvault/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â”œâ”€â”€ public/
    â”‚   â”‚   â”‚   â””â”€â”€ index.html
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â”œâ”€â”€ App.css
    â”‚   â”‚       â”œâ”€â”€ App.tsx
    â”‚   â”‚       â”œâ”€â”€ contracts.ts
    â”‚   â”‚       â”œâ”€â”€ index.css
    â”‚   â”‚       â”œâ”€â”€ index.tsx
    â”‚   â”‚       â”œâ”€â”€ Web3Provider.tsx
    â”‚   â”‚       â””â”€â”€ components/
    â”‚   â”‚           â”œâ”€â”€ Navbar.tsx
    â”‚   â”‚           â””â”€â”€ VaultInterface.tsx
    â”‚   â””â”€â”€ wrapping/
    â”‚       â”œâ”€â”€ index.html
    â”‚       â”œâ”€â”€ main.ts
    â”‚       â””â”€â”€ style.css
    â”œâ”€â”€ forge/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ foundry.toml
    â”‚   â”œâ”€â”€ remappings.txt
    â”‚   â”œâ”€â”€ script/
    â”‚   â”‚   â”œâ”€â”€ AgoraFaucet.s.sol
    â”‚   â”‚   â””â”€â”€ Counter.s.sol
    â”‚   â”œâ”€â”€ src/
    â”‚   â”‚   â”œâ”€â”€ Coinflip.sol
    â”‚   â”‚   â”œâ”€â”€ Counter.sol
    â”‚   â”‚   â””â”€â”€ Lock.sol
    â”‚   â””â”€â”€ test/
    â”‚       â”œâ”€â”€ Coinflip.t.sol
    â”‚       â”œâ”€â”€ Counter.t.sol
    â”‚       â””â”€â”€ Lock.t.sol
    â”œâ”€â”€ runbooks/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â””â”€â”€ deployments/
    â”‚       â””â”€â”€ deployer.tx
    â”œâ”€â”€ scripts/
    â”‚   â”œâ”€â”€ build_abi.js
    â”‚   â”œâ”€â”€ build_address_utils.js
    â”‚   â”œâ”€â”€ forge-deploy.sh
    â”‚   â”œâ”€â”€ fork_example.js
    â”‚   â”œâ”€â”€ generate_contract_dir.js
    â”‚   â”œâ”€â”€ generate_mintlify_context.js
    â”‚   â”œâ”€â”€ start_anvil.sh
    â”‚   â””â”€â”€ verify_anvil.js
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ index.html
    â”‚   â”œâ”€â”€ main.ts
    â”‚   â””â”€â”€ style.css
    â”œâ”€â”€ utils/
    â”‚   â”œâ”€â”€ address-example.js
    â”‚   â”œâ”€â”€ phonehome.ts
    â”‚   â”œâ”€â”€ phonehome_flush.ts
    â”‚   â””â”€â”€ addresses/
    â”‚       â””â”€â”€ index.ts
    â””â”€â”€ .github/
        â”œâ”€â”€ actions/
        â”‚   â””â”€â”€ install/
        â”‚       â””â”€â”€ action.yml
        â””â”€â”€ workflows/
            â”œâ”€â”€ build.yml
            â”œâ”€â”€ deploy-arns.yml
            â”œâ”€â”€ deploy.yml
            â””â”€â”€ install.yml

================================================
FILE: README.md
================================================
# Katana Development Starter Kit

![Box of legos](leo.jpg)

## ğŸš€ Introduction

Welcome to the **Katana Development Starter Kit**! This repository serves as
your launchpad for building on **Katana** and its testnet **Bokuto**.

This kit provides:

- **Bun-based development environment** ğŸ§…
- **Anvil + Foundry integration** for reliable local chain forks
- **Pre-configured build system** using Esbuild & TypeScript
- **[UI-kit CSS](https://getuikit.com/)**, optional to use
- **[viem](https://viem.sh/)** for blockchain interactions
- **Example contracts** to help you integrate with **Katana's money legos** and
  interfaces for all deployed contracts on Katana and testnets
- **Foundry setup** for smart contract development and testing
- **Static File Handling** (HTML, CSS, and assets copied to `dist/`, easy to
  host on IPFS or any static file hosting service)
- **Contract address mapping generator** for easy access to deployed contract
  addresses in JavaScript, including origin chain addresses for cross-chain operations
- **Foundry MCP Server** for AI-assisted smart contract development
- Script to generate a single file contract directory with all the ABIs,
  contract names, paths, descriptions, addresses, and context they belong to,
  for directory browsers like the [contract dir](https://contracts.katana.tools)

Whether you're building yield strategies, cross-chain intent-based execution,
or novel DeFi protocols**, this starter kit helps you bootstrap your project
**fast**.

- [Documentation](https://docs.katana.network/)
- [More about contract interfaces](/interfaces/README.md)
- [More about running Katana locally for development](/scripts/README.md)

## Chain information

### Katana

| Property                        | Value                                         |
|----------------------------------|-----------------------------------------------|
| **Chain Name**                   | Katana                                        |
| **Chain ID**                     | `747474`                                      |
| **Public RPC URL**               | [https://rpc.katana.network/](https://rpc.katana.network/) |
| **Gas Token**                    | ETH                                           |
| **Block Explorer**               | [https://katanascan.com/](https://katanascan.com/) |
| **Block Time**                   | 1 second                                      |
| **Block Gas Limit**              | 60M units                                     |
| **Block Gas Target**             | 30M units                                     |
| **Gas Pricing**                  | EIP1559                                       |
| **EIP-1559 Elasticity Multiplier** | 60                                          |
| **EIP-1559 Denominator**         | 250                                           |
| **Data Availability**            | EIP4844                                       |
| **Account Abstraction**          | EIP7702                                       |

---

### Bokuto

| Property         | Value                                              |
|------------------|----------------------------------------------------|
| **Chain Name**   | Bokuto                                             |
| **Chain ID**     | `737373`                                           |
| **RPC URL**      | [https://rpc-bokuto.katanarpc.com](https://rpc-bokuto.katanarpc.com) |
| **Block Explorer**      | [https://explorer-bokuto.katanarpc.com/](https://explorer-bokuto.katanarpc.com/) |
| **Gas Token**           | ETH                                                                   |
| **Block Time**          | 1 second                                                              |
| **Gas Block Limit**     | 60M units                                                             |
| **Gas Pricing**         | EIP1559                                                               |
| **Data Availability**   | EIP4844                                                               |

---

## ğŸ›  Setup & Installation

### 1ï¸âƒ£ **Install Dependencies**

Copy `.env.example` into `.env` and add in your RPC endpoints if you want to
change them (recommended: to prevent rate limiting).

Ensure you have the required tools installed:

- [Bun](https://bun.sh/) - Follow the installation instructions at <https://bun.sh/>
- [Foundry](https://book.getfoundry.sh/) for contract development and local
  chain forks
- [Git](https://git-scm.com/)

After installing Bun, run:

```sh
# Install project dependencies
bun install
```

### 2ï¸âƒ£ **Run the Build System**

This project uses **Bun** as its runtime and **Esbuild** for bundling. To build
your project, run:

```sh
bun run build:all
```

This will:

- Compile and minify the example TypeScript code
- Copy HTML & static assets to `./dist`
- Prepare the environment for deployment
- Compile helper utilities like an address-to-contract mapping in
  `utils/addresses` and interface ABIs in the `/abis` folder as well as address
  lookup Solidity contracts in `contracts/utils`. This includes both regular
  destination chain addresses and origin chain addresses for cross-chain operations.
- Build the Foundry MCP server for AI-assisted development

ğŸš¨ Note: Going forward, you can just rebuild the web app using `bun run build`.

### 3ï¸âƒ£ **Local Chain Forking**

#### Environment Setup

Create a `.env` file by copying `.env.example`. If you want non-rate-limited
access, replace the RPC endpoints there with your own, otherwise, use the
defaults.

```bash
# Copy and customize based on your available RPC endpoints
KATANA_RPC_URL=https://rpc.katana.network/
BOKUTO_RPC_URL=https://rpc-bokuto.katanarpc.com
```

#### Terminal 1: Start Anvil Fork

```sh
# Or fork Bokuto testnet
bun run start:anvil bokuto

# Or fork Katana mainnet
bun run start:anvil katana
```

#### Terminal 2: Verify the Fork

To check if all is well, you can run the following command in another terminal.

```sh
bun run verify:anvil
```

This will automatically detect which chain you're forking and verify that
contracts are accessible. It will test key contracts (like AUSD, WETH,
MorphoBlue) if available on the forked chain and show connection details for
your wallet.

See [scripts/README.md](scripts/README.md) for more details.

### 4ï¸âƒ£ **Example dApp**

The starter kit includes a simple example dApp that automatically detects and
connects to any of the supported local chain forks (Katana or Bokuto)
and displays information about key contracts available on that chain.

To run the example:

1. Start your local chain fork (in its own terminal):

   ```sh
   # Fork any supported chain
   bun run start:anvil bokuto   # or katana
   ```

2. In a new terminal, build the dApp:

   ```sh
   bun run build
   ```

3. Start **frontend app**
   `bun run dev`

   This starts the frontend dapp here `http://localhost:8080`

The example dApp automatically:

- **Detects the running chain** by reading the chain ID from your local fork
- **Loads the appropriate contracts** using the dynamic address system
  (including origin chain addresses)
- **Shows available contract information** (AUSD, WETH, MorphoBlue) if deployed
  on that chain
- **Displays helpful messages** if contracts aren't available on the selected chain

The app gracefully handles different chains and will show which contracts are
available on each network. You can use this as a starting point for your own
multi-chain dApp development.

### 5ï¸âƒ£ **Using the Foundry MCP Server**

The kit includes a Foundry MCP (Model Context Protocol) server that enables
AI-assisted smart contract and app development when used with compatible AI
tools like Cursor.

To use the MCP server:

1. Configure e.g. Cursor to use the MCP server by adding the following to your Cursor
   config in `.cursor/mcp.json`:

   ```json
   "mcpServers": {
     "foundry": {
       "command": "bun run",
       "args": [
         "/absolute_path_to_starter_kit/dist-mcp/index.js"
       ],
       "env": {
         "PRIVATE_KEY": "0xYourPrivateKeyHere",
         "RPC_URL": "http://localhost:8545"
       }
     }
   }
   ```

   Replace `/absolute_path_to_starter_kit/` with absolute path to your clone of
   the starter kit.

2. Launch the local chain with `bun run start:anvil bokuto` (or `katana`).

3. The `PRIVATE_KEY` and `RPC_URL` environment variables are optional. If not
   provided, the RPC URL will default to `http://localhost:8545`.

4. After configuring, you can use the AI in Cursor to interact with Foundry
   tools, including:
   - Calling contract functions
   - Checking balances
   - Starting/stopping Anvil instances
   - Creating and deploying smart contracts
   - Working with Katana-specific contracts

The MCP server provides a seamless interface between AI tools and Foundry's
blockchain development toolkit, making it easier to build and interact with
contracts on Katana.

### 6ï¸âƒ£ **Foundry commands (run from repo root)**

The following convenience commands are available via Bun scripts in
`package.json` and run from the repository root:

- **forge:deps**: Set up Foundry dependencies (clones `forge-std` if missing)

  ```sh
  bun run forge:deps
  ```

  You don't need to generally run this ever - it's automatic during `build:all`.

- **forge:build**: Build the contracts in the `forge/` workspace

  ```sh
  bun run forge:build
  ```

  Compiles your contracts, creating deployable artifacts.

- **forge:test**: Run the Foundry test suite in the `forge/` workspace

  ```sh
  bun run forge:test
  ```

- **forge:deploy**: Deploy a Foundry script target using a wrapper around
  `forge script`

  Defaults if not provided:

- **RPC URL**: `http://localhost:8545`
- **Private key**:
  `0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80` (unlocked
  Anvil demo account)

  Chain-aware usage (the `@script/` prefix is optional):

  ```sh
  # Local anvil (uses defaults shown above)
  bun run forge:deploy -- @script/DaikatanaPayments.s.sol:DaikatanaPaymentsScript --chain local

  # Katana mainnet (reads KATANA_RPC_URL and KATANA_DEPLOYER_KEY from .env)
  bun run forge:deploy -- @script/DaikatanaPayments.s.sol:DaikatanaPaymentsScript --chain katana

  # Bokuto testnet
  bun run forge:deploy -- @script/Counter.s.sol:CounterScript --chain bokuto

  # Override only the private key while keeping chain RPC from .env
  bun run forge:deploy -- @script/DaikatanaPayments.s.sol:DaikatanaPaymentsScript \
    --chain katana \
    --private-key 0xYOUR_PRIVATE_KEY

  # Override both explicitly (bypasses .env values for the chain)
  bun run forge:deploy -- @script/Counter.s.sol:CounterScript \
    --rpc-url https://your.rpc/ \
    --private-key 0xYOUR_PRIVATE_KEY
  ```

  Notes:

- The wrapper auto-adds `--broadcast` unless you already provided it.
- Extra flags are forwarded to `forge script` as-is.
- Script path is normalized to `forge/script/...` under the `forge/` workspace.
- When using `--sig`, put it after a literal `--` and quote the signature to
  avoid shell parsing:

    ```sh
    bun run forge:deploy -- @script/DaikatanaPayments.s.sol:DaikatanaPaymentsScript \
      --chain local \
      --sig 'run(uint256,uint256,bool)' 5000000000000000 100 true
    ```

#### Verifying contracts programmatically

To verify a Katana-deployed contract via the unified Etherscan API key, install
nightly
[per their guide](https://docs.etherscan.io/etherscan-v2/contract-verification/verify-with-foundry).

Then:

```bash
cd forge
forge verify-contract --watch --root . --chain katana \
  {ADDRESS} \
  src/{CONTRACTFILE.sol}:{CONTRACTNAME} \
  --verifier etherscan \
  --etherscan-api-key {APIKEY} \
  --optimizer-runs 200
```

Obtain the etherscan key [in the API dash](https://etherscan.io/apidashboard).

### 7ï¸âƒ£ **Contract Address Mapping**

The kit includes a utility to generate a JavaScript mapping of all contract
addresses for Katana mainnet and Bokuto testnet. This
makes it easy to access contract addresses in your frontend code without
hardcoding them. The system also handles **origin chain addresses** for
cross-chain operations like Vault Bridge.

To generate the address mapping:

```sh
bun run build:addressutils
```

This will create files in `utils/addresses/` and `contracts/utils/`:

**TypeScript Files:**

- `mapping.ts` - Auto-generated mapping of contract addresses (do not edit)
- `index.ts` - User-friendly API wrapper with chain context management

**Solidity Files:**

- `[Chain]Addresses.sol` - Contract address libraries for each chain
- `[Chain]OriginAddresses.sol` - Origin chain address libraries for cross-chain operations

### Usage

The improved API provides a cleaner interface with automatic "I" prefix handling:

```javascript
import { addresses, CHAINS } from '../utils/addresses';

// Set the chain context (by name or ID)
addresses.setChain('bokuto');
// or
addresses.setChain(CHAINS.bokuto);

// Get contract addresses - automatically handles I prefix
const wethAddress = addresses.getAddress('WETH');      // Finds IWETH
const morphoAddress = addresses.getAddress('MorphoBlue'); // Finds IMorphoBlue
const ausdAddress = addresses.getAddress('AUSD');      // Finds IAUSD

// Check if a contract exists
if (addresses.hasContract('Permit2')) {
  const permit2 = addresses.getAddress('Permit2');
}

// Get all available contracts on current chain
const allContracts = addresses.getAllContracts();

// Get address for a specific chain without changing context
const wethOnKatana = addresses.getAddressForChain('WETH', 'katana');
```

### Origin Chain Addresses

For cross-chain operations (like Vault Bridge), you often need addresses from
the **origin chain** (Ethereum/Sepolia) while operating in a **destination
chain** context (Katana/Bokuto). The address system handles this
automatically:

```javascript
import { addresses } from '../utils/addresses';

// Set context to Katana (destination chain)
addresses.setChain('katana');

// Get destination chain contracts (deployed on Katana)
const bridgedUSDC = addresses.getAddress('bvbUSDC');
// Returns: 0x203A662b0BD271A6ed5a60EdFbd04bFce608FD36

// Get origin chain contracts (deployed on Ethereum, accessed from Katana context)
const vaultUSDC = addresses.getOriginAddress('vbUSDC');
// Returns: 0x53E82ABbb12638F09d9e624578ccB666217a765e

const migrationManager = addresses.getOriginAddress('MigrationManager');
// Returns: 0x417d01B64Ea30C4E163873f3a1f77b727c689e02

// Check what origin contracts are available
const originContracts = addresses.getAllOriginContracts();
// Returns: ["IMigrationManager", "IvbETH", "IvbUSDC", "IvbUSDS", "IvbUSDT", "IvbWBTC"]
```

**Chain Context Mapping:**

- **Katana context** â†’ Origin addresses from **Ethereum**
- **Bokuto context** â†’ Origin addresses from **Sepolia**

### Features

- **Automatic I-prefix handling**: Try `WETH` and it will find `IWETH`
- **Chain context management**: Set once, use everywhere
- **Origin chain support**: Access origin chain addresses for cross-chain operations
- **Context-aware addressing**: Katana context â†’ Ethereum origins, Bokuto
  â†’ Sepolia origins
- **Better error messages**: Shows available contracts when not found
- **Type-safe**: Full TypeScript support with address types
- **Dual address types**: Regular (destination) and origin addresses in one API

The address mapping is generated from the `@custom:katana` and
`@custom:bokuto` doccomments in the contract files.

---

### 8ï¸âƒ£ **Forkable Examples**

You can replace the default demo app in `src/` with any example from `examples/`.

Commands:

```bash
# List available examples
bun run fork --list

# Fork an example and build the app
bun run fork wrapping --yes

# Skip the build step (you can run `bun run build` later)
bun run fork ausd-yearnvault --yes --no-build
```

Behavior:

- Backs up your current `src/` to `.fork-backups/src-<timestamp>`
- Clears `src/` and copies `examples/<name>` into `src/`
- Runs `bun run build` unless `--no-build` is provided

Telemetry (centralized and optional):

If you want telemetry to include which example was forked, set `PHONEHOME_META`
when running the command. This augments the `prefork` pre-script event with
metadata.

```bash
# Preferred JSON format
PHONEHOME_META='{"example":"wrapping"}' bun run fork wrapping --yes

# Or simple key=value list (comma-separated allowed)
PHONEHOME_META='example=wrapping' bun run fork wrapping --yes
```

Notes:

- Telemetry is still governed by the same consent and env flags described below
- The fork script itself contains no telemetry logic; all analytics go through `utils/phonehome.ts`

## Anonymous telemetry (opt-in)

On first run of any `bun run` script, the starter kit may ask:

> "Help improve Katana Starter Kit by sending anonymous usage (event name,
> version, OS)? [y/N]"

- If you opt in, a local `.phonehome/config.json` is created with:
  - `consent`: `yes` or `no`
  - `repoId`: random ID for this clone
  - `deviceId`: random ID for this device
- The `deviceId` is generated once per machine and cached, so multiple clones on
  the same device share the same ID. No personal data is collected.
- Telemetry is non-blocking and offline-safe: events are queued in
  `.phonehome/queue` and occasionally flushed in the background with strict
  timeouts.

Control via environment variables:

- `KATANA_PHONEHOME=0` disables telemetry
- `KATANA_PHONEHOME=1` enables telemetry
- Telemetry is automatically disabled in CI and when `DO_NOT_TRACK=1`.

You can change your choice anytime by editing `.phonehome/config.json`.

---

## ğŸ”— Smart Contract Development

See [interfaces](interfaces).

## ğŸ›  Contributing

We welcome contributions! If you'd like to improve the Katana Starter Kit, fork
the repo and submit a PR.

---

3ï¸âƒ£ Deploy and interact with Katana's **DeFi money legos**

ğŸš€ **Happy Building!**



================================================
FILE: build.js
================================================
import { build } from 'esbuild';
import fs from 'node:fs';
import path from 'node:path';
import { execSync } from 'node:child_process';

async function buildProject() {
  console.log('ğŸ—ï¸ Building project...');

  // Ensure dist directory exists
  if (fs.existsSync('./dist')) {
    console.log('Cleaning dist directory...');
    fs.rmSync('./dist', { recursive: true, force: true });
  }
  fs.mkdirSync('./dist', { recursive: true });

  try {
    // Build TypeScript
    await build({
      entryPoints: ['./src/main.ts'],
      outfile: './dist/main.js',
      bundle: true,
      minify: true,
      format: 'esm',
      platform: 'browser',
      loader: {
        '.ts': 'ts',
      },
      define: {
        'process.env.NODE_ENV': '"production"',
      }
    });

    console.log('âœ… TypeScript compiled successfully.');

    // Copy HTML file
    fs.copyFileSync('./src/index.html', './dist/index.html');
    console.log('âœ… HTML files copied.');

    // Copy CSS file
    fs.copyFileSync('./src/style.css', './dist/style.css');
    console.log('âœ… CSS files copied.');

    // Copy any other static assets if they exist
    const imagesDir = './src/images';
    if (fs.existsSync(imagesDir)) {
      const targetDir = './dist/images';
      if (!fs.existsSync(targetDir)) {
        fs.mkdirSync(targetDir, { recursive: true });
      }
      
      fs.readdirSync(imagesDir).forEach(file => {
        fs.copyFileSync(path.join(imagesDir, file), path.join(targetDir, file));
      });
      console.log('âœ… Images copied.');
    }

    console.log('ğŸ‰ Build complete! Files written to ./dist');
  } catch (error) {
    console.error('âŒ Build failed:', error);
    process.exit(1);
  }
}

async function buildMcpServer() {
  console.log('ğŸ—ï¸ Building MCP server...');

  // Ensure dist-mcp directory exists
  if (fs.existsSync('./dist-mcp')) {
    console.log('Cleaning dist-mcp directory...');
    fs.rmSync('./dist-mcp', { recursive: true, force: true });
  }
  fs.mkdirSync('./dist-mcp', { recursive: true });

  try {
    // Build MCP server
    await build({
      entryPoints: ['./utils/mcp-server/index.ts'],
      outfile: './dist-mcp/index.js',
      bundle: true,
      minify: false, // For easier debugging
      format: 'esm',
      platform: 'node',
      loader: {
        '.ts': 'ts',
      },
      external: ['child_process', 'fs', 'path', 'os', 'util'],
      define: {
        'process.env.NODE_ENV': '"production"',
      }
    });

    console.log('âœ… MCP server compiled successfully.');

    // Create README for MCP server
    const mcpReadme = `# Katana Foundry MCP Server

This is a Model Context Protocol (MCP) server for Foundry that provides tools
for interacting with Katana blockchain via the command line.

## Usage

To use this MCP server with Cursor, add the following to your Cursor config:

\`\`\`json
"mcpServers": {
  "foundry": {
    "command": "bun",
    "args": [
      "${path.resolve('./dist-mcp/index.js')}"
    ],
    "env": {
      "PRIVATE_KEY": "0xYourPrivateKeyHere",
      "RPC_URL": "http://localhost:8545"
    }
  }
}
\`\`\`

The \`PRIVATE_KEY\` and \`RPC_URL\` environment variables are optional. If not provided,
the RPC URL will default to http://localhost:8545.
`;

    fs.writeFileSync('./dist-mcp/README.md', mcpReadme);
    console.log('âœ… MCP server README created.');

  } catch (error) {
    console.error('âŒ MCP server build failed:', error);
    process.exit(1);
  }
}

async function buildExamples() {
  console.log('ğŸ—ï¸ Building examples...');

  // Ensure dist-examples directory exists
  if (fs.existsSync('./dist-examples')) {
    console.log('Cleaning dist-examples directory...');
    fs.rmSync('./dist-examples', { recursive: true, force: true });
  }
  fs.mkdirSync('./dist-examples', { recursive: true });

  const examplesDir = './examples';
  
  if (!fs.existsSync(examplesDir)) {
    console.log('âŒ Examples directory not found');
    return;
  }

  const examples = fs.readdirSync(examplesDir, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);

  if (examples.length === 0) {
    console.log('âŒ No example directories found');
    return;
  }

  console.log(`ğŸ“ Found ${examples.length} examples: ${examples.join(', ')}`);

  for (const example of examples) {
    const examplePath = path.join(examplesDir, example);
    const outputPath = path.join('./dist-examples', example);
    
    console.log(`ğŸ”¨ Building example: ${example}`);
    
    // Create output directory for this example
    fs.mkdirSync(outputPath, { recursive: true });
    
    try {
      // Detect example type
      const mainTsPath = path.join(examplePath, 'main.ts');
      const reactIndexPath = path.join(examplePath, 'src', 'index.tsx');

      const isTsSingleFile = fs.existsSync(mainTsPath);
      const isReactTsx = fs.existsSync(reactIndexPath);

      if (!isTsSingleFile && !isReactTsx) {
        console.log(`âš ï¸  Skipping ${example}: no entry found (expected main.ts or src/index.tsx)`);
        continue;
      }

      // If the example is a React app with its own package.json, ensure deps are installed
      const examplePkgPath = path.join(examplePath, 'package.json');
      const hasPackageJson = fs.existsSync(examplePkgPath);
      const nodeModulesPath = path.join(examplePath, 'node_modules');
      if (isReactTsx && hasPackageJson && !fs.existsSync(nodeModulesPath)) {
        try {
          console.log(`ğŸ“¦ Installing dependencies for ${example} (bun install)...`);
          execSync('bun install --no-progress', { cwd: examplePath, stdio: 'inherit' });
          console.log(`âœ… Dependencies installed for ${example}`);
        } catch (installErr) {
          console.warn(`âš ï¸  Failed to install dependencies for ${example}. Continuing with build...`);
        }
      }

      // Common esbuild options
      const esbuildCommon = {
        outfile: path.resolve(outputPath, 'main.js'),
        bundle: true,
        minify: true,
        format: 'esm',
        platform: 'browser',
        absWorkingDir: path.resolve(examplePath),
        loader: {
          '.ts': 'ts',
          '.tsx': 'tsx',
          '.css': 'css',
        },
        jsx: 'automatic',
        jsxImportSource: 'react',
        define: {
          'process.env.NODE_ENV': '"production"',
          'process.env.REACT_APP_WALLETCONNECT_PROJECT_ID': JSON.stringify(process.env.REACT_APP_WALLETCONNECT_PROJECT_ID || ''),
        },
      };

      if (isTsSingleFile) {
        await build({
          entryPoints: ['main.ts'],
          ...esbuildCommon,
        });
        console.log(`âœ… TypeScript compiled for ${example}`);

        // Copy HTML file if it exists
        const htmlPath = path.join(examplePath, 'index.html');
        if (fs.existsSync(htmlPath)) {
          fs.copyFileSync(htmlPath, path.join(outputPath, 'index.html'));
          console.log(`âœ… HTML copied for ${example}`);
        }

        // Copy CSS file if it exists
        const cssPath = path.join(examplePath, 'style.css');
        if (fs.existsSync(cssPath)) {
          fs.copyFileSync(cssPath, path.join(outputPath, 'style.css'));
          console.log(`âœ… CSS copied for ${example}`);
        }

        // Copy any images directory if it exists
        const imagesDir = path.join(examplePath, 'images');
        if (fs.existsSync(imagesDir)) {
          const targetImagesDir = path.join(outputPath, 'images');
          fs.mkdirSync(targetImagesDir, { recursive: true });
          fs.readdirSync(imagesDir).forEach(file => {
            fs.copyFileSync(path.join(imagesDir, file), path.join(targetImagesDir, file));
          });
          console.log(`âœ… Images copied for ${example}`);
        }
      } else if (isReactTsx) {
        // Build React example from src/index.tsx
        const tsconfigPath = path.resolve(examplePath, 'tsconfig.json');
        await build({
          entryPoints: ['src/index.tsx'],
          tsconfig: fs.existsSync(tsconfigPath) ? tsconfigPath : undefined,
          ...esbuildCommon,
        });
        console.log(`âœ… React example compiled for ${example}`);

        // Copy public assets
        const publicDir = path.join(examplePath, 'public');
        if (fs.existsSync(publicDir)) {
          // Copy everything except index.html (we'll transform it below)
          fs.readdirSync(publicDir).forEach(file => {
            const srcPath = path.join(publicDir, file);
            const destPath = path.join(outputPath, file);
            if (file.toLowerCase() === 'index.html') return;
            const stat = fs.statSync(srcPath);
            if (stat.isDirectory()) {
              fs.cpSync(srcPath, destPath, { recursive: true });
            } else {
              fs.copyFileSync(srcPath, destPath);
            }
          });
          console.log(`âœ… Public assets copied for ${example}`);
        }

        // Copy all .css files from src/ to output directory (for React examples)
        const srcDir = path.join(examplePath, 'src');
        if (fs.existsSync(srcDir)) {
          const cssFiles = fs.readdirSync(srcDir).filter(f => f.endsWith('.css'));
          for (const cssFile of cssFiles) {
            fs.copyFileSync(path.join(srcDir, cssFile), path.join(outputPath, cssFile));
            console.log(`âœ… src/${cssFile} copied for ${example}`);
          }
        }

        // Transform and write index.html
        const publicIndexHtml = path.join(publicDir, 'index.html');
        const cssFiles = fs.existsSync(srcDir) ? fs.readdirSync(srcDir).filter(f => f.endsWith('.css')) : [];
        if (fs.existsSync(publicIndexHtml)) {
          let html = fs.readFileSync(publicIndexHtml, 'utf8');
          // Replace CRA placeholders and inject script tag
          html = html.replace(/%PUBLIC_URL%/g, '.');
          // Inject CSS links if not present
          for (const cssFile of cssFiles) {
            if (!html.includes(cssFile)) {
              html = html.replace('</head>', `  <link rel="stylesheet" href="./${cssFile}">\n  </head>`);
            }
          }
          if (!/main\.js/.test(html)) {
            html = html.replace('</body>', '  <script type="module" src="./main.js"></script>\n  </body>');
          }
          fs.writeFileSync(path.join(outputPath, 'index.html'), html);
          console.log(`âœ… HTML generated for ${example}`);
        } else {
          // Fallback basic HTML
          let cssLinks = cssFiles.map(cssFile => `    <link rel="stylesheet" href="./${cssFile}">`).join('\n');
          const basicHtml = `<!doctype html>\n<html>\n  <head>\n    <meta charset="utf-8"/>\n    <meta name="viewport" content="width=device-width, initial-scale=1"/>\n    <title>${example}</title>\n${cssLinks}\n  </head>\n  <body>\n    <div id="root"></div>\n    <script type="module" src="./main.js"></script>\n  </body>\n</html>`;
          fs.writeFileSync(path.join(outputPath, 'index.html'), basicHtml);
          console.log(`âœ… HTML created for ${example}`);
        }
      }

      // Create a README for this example
      const exampleReadme = `# ${example.charAt(0).toUpperCase() + example.slice(1)} Example

This is a demo application showing how to use Katana blockchain features.

## Running the Demo

To run this demo:

1. Start a local HTTP server in this directory:
   \`\`\`bash
   npx http-server
   \`\`\`

2. Open your browser to http://localhost:PORT (port will vary based on other apps running)
`;

      fs.writeFileSync(path.join(outputPath, 'README.md'), exampleReadme);
      console.log(`âœ… README created for ${example}`);

    } catch (error) {
      console.error(`âŒ Failed to build example ${example}:`, error);
      // Continue with other examples instead of failing entirely
    }
  }

  console.log('ğŸ‰ Examples build complete! Files written to ./dist-examples');
  console.log('ğŸ’¡ To run an example: cd dist-examples/<example-name> && npx http-server');
}

// Run if this file is executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  if (process.argv.includes('--mcp-only')) {
    buildMcpServer();
  } else if (process.argv.includes('--examples-only')) {
    buildExamples();
  } else {
    buildProject();
  }
}

export { buildProject, buildMcpServer, buildExamples };


================================================
FILE: package.json
================================================
{
  "name": "katana-development-starter-kit",
  "version": "0.1.0",
  "description": "Development starter kit for Katana and Bokuto",
  "scripts": {
    "prebuild": "bun utils/phonehome.ts --event build",
    "build": "bun build.js",
    "predev": "bun utils/phonehome.ts --event dev",
    "dev": "npx http-server dist",
    "prestart:anvil": "bun utils/phonehome.ts --event start:anvil",
    "start:anvil": "chmod +x scripts/start_anvil.sh && scripts/start_anvil.sh",
    "preverify:anvil": "bun utils/phonehome.ts --event verify:anvil",
    "verify:anvil": "bun scripts/verify_anvil.js",
    "build:abi": "bun scripts/build_abi.js",
    "build:contractdir": "bun scripts/generate_contract_dir.js",
    "build:addressutils": "bun scripts/build_address_utils.js",
    "prebuild:mcpserver": "bun utils/phonehome.ts --event build:mcpserver",
    "build:mcpserver": "bun build.js --mcp-only",
    "prebuild:examples": "bun utils/phonehome.ts --event build:examples",
    "build:examples": "bun build.js --examples-only",
    "generate_mintlify_context": "bun scripts/generate_mintlify_context.js",
    "prebuild:all": "bun utils/phonehome.ts --event build:all",
    "forge:deps": "mkdir -p forge/lib && [ -d forge/lib/forge-std/.git ] || git clone --depth 1 https://github.com/foundry-rs/forge-std forge/lib/forge-std && chmod +x scripts/forge-deploy.sh",
    "preforge:build": "bun utils/phonehome.ts --event forge:build",
    "forge:build": "cd forge && forge build && cd ..",
    "preforge:test": "bun utils/phonehome.ts --event forge:test",
    "forge:test": "cd forge && forge test && cd ..",
    "preforge:deploy": "bun utils/phonehome.ts --event forge:deploy",
    "forge:deploy": "bash scripts/forge-deploy.sh",
    "build:all": "bun run forge:deps && bun run build:addressutils && bun run build:abi && bun run build:contractdir && bun run build && bun run build:mcpserver",
    "predeploy:arns": "bun utils/phonehome.ts --event deploy:arns",
    "deploy:arns": "bun run build:all && permaweb-deploy --arns-name $ARNS_NAME --sig-type ethereum",
    "prestart:mcp": "bun utils/phonehome.ts --event start:mcp",
    "start:mcp": "bun dist-mcp/index.js",
    "prefork": "bun utils/phonehome.ts --event fork",
    "fork": "bun scripts/fork_example.js"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.10.2",
    "solc": "^0.8.30",
    "viem": "^2.23.13",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/node": "^20.11.25",
    "esbuild": "^0.24.0",
    "permaweb-deploy": "^2.5.1",
    "typescript": "^5.4.2",
    "bun-types": "latest"
  },
  "type": "module"
}



================================================
FILE: test.ts
================================================
console.log("test")



================================================
FILE: TODO.md
================================================
# TODO

## Add all the context to mintlify

Add the interfaces somehow to Mintlify.


================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "lib": ["dom", "dom.iterable", "esnext"],
    "types": ["node"],
    "outDir": "./dist",
    "rootDir": "./",
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["src/**/*.ts", "src/**/*.tsx", "utils/**/*.ts", "utils/**/*.js"],
  "exclude": ["node_modules"]
}



================================================
FILE: txtx.yml
================================================
---
name: specialk
id: specialk
runbooks:
  - name: deployer
    description: 
    location: runbooks/deployments/deployer.tx
environments:




================================================
FILE: WARP.md
================================================
# WARP.md

This file provides guidance to WARP (warp.dev) when working with code in this repository.

## Project Overview

This is the **Katana Development Starter Kit**, a comprehensive development environment for building on Katana blockchain and its testnet Bokuto. The kit provides a complete stack for DeFi protocol development including smart contracts, frontend applications, and blockchain interaction utilities.

### Key Networks
- **Katana Mainnet**: Chain ID 747474, RPC: https://rpc.katana.network/
- **Bokuto Testnet**: Chain ID 737373, RPC: https://rpc-bokuto.katanarpc.com

## Essential Commands

### Initial Setup
```bash
# Install dependencies
bun install

# Copy environment file and configure RPC endpoints
cp .env.example .env

# Build everything (run once after cloning)
bun run build:all
```

### Development Workflow
```bash
# Start local chain fork (choose one)
bun run start:anvil katana    # Fork Katana mainnet  
bun run start:anvil bokuto    # Fork Bokuto testnet

# Verify fork is working (in another terminal)
bun run verify:anvil

# Build frontend application
bun run build

# Start development server
bun run dev    # Serves at http://localhost:8080
```

### Foundry Smart Contract Development
```bash
# Build contracts
bun run forge:build

# Run tests
bun run forge:test

# Deploy contracts (supports chain-aware deployment)
bun run forge:deploy -- @script/Counter.s.sol:CounterScript --chain local
bun run forge:deploy -- @script/Counter.s.sol:CounterScript --chain katana

# Set up Foundry dependencies (automatic during build:all)
bun run forge:deps
```

### Address and ABI Management
```bash
# Generate contract address mappings from doccomments
bun run build:addressutils

# Generate ABI files from contract interfaces
bun run build:abi

# Generate contract directory for tooling/documentation
bun run build:contractdir
```

### Forkable Examples
```bash
# List available examples
bun run fork --list

# Fork an example into src/ and build
bun run fork wrapping --yes

# Skip build (build later with bun run build)
bun run fork ausd-yearnvault --yes --no-build
```

Behavior:
- Backs up current `src/` to `.fork-backups/src-<timestamp>`
- Replaces `src/` with `examples/<name>`
- Runs `bun run build` unless `--no-build` is provided

Telemetry (centralized):
- To attribute which example was forked, pass metadata via env:
```bash
PHONEHOME_META='{"example":"wrapping"}' bun run fork wrapping --yes
# or
PHONEHOME_META='example=wrapping' bun run fork wrapping --yes
```
- No custom telemetry in the script; `prefork` runs `utils/phonehome.ts`

### MCP Server for AI Development
```bash
# Build MCP server for AI-assisted development
bun run build:mcpserver

# Start MCP server (for use with Cursor/other AI tools)
bun run start:mcp
```

## Architecture Overview

### Multi-Chain Address System
The project features a sophisticated address management system that handles both destination chain contracts and origin chain addresses for cross-chain operations:

- **Destination Addresses**: Contracts deployed on Katana/Bokuto
- **Origin Addresses**: Contracts on Ethereum/Sepolia used for Vault Bridge operations
- **Dynamic Resolution**: Automatically handles 'I' prefix for interfaces (e.g., `WETH` â†’ `IWETH`)

Key files:
- `utils/addresses/index.ts` - Main address management API
- `utils/addresses/mapping.ts` - Auto-generated address mappings
- `contracts/utils/` - Solidity address libraries for each chain

### Contract Interface System
All contract interfaces are stored in the `contracts/` directory with doccomments specifying deployment addresses:

```solidity
/**
 * @custom:katana 0x2345678901234567890123456789012345678901
 * @custom:bokuto sepolia:0x3456789012345678901234567890123456789012
 */
interface IAUSD {
    // Interface definition
}
```

### Foundry Integration
- Workspace: `forge/` directory
- Scripts: `forge/script/` for deployment scripts
- Tests: `forge/test/` for contract tests
- Source: `forge/src/` for contract implementations
- Chain-aware deployment wrapper: `scripts/forge-deploy.sh`

### Frontend Application
- Built with TypeScript, Viem, and UIKit CSS
- Automatically detects running chain fork
- Displays contract information for available networks
- Demonstrates multi-chain address resolution

### MCP Server
Provides AI-assisted development through Foundry MCP server at `utils/mcp-server/index.ts`:
- Cast operations (call, send, balance, logs, etc.)
- Anvil management (start, stop, status)
- Contract interaction by name instead of address
- Automatic address lookup and function signature resolution

## Development Patterns

### Working with Addresses
```typescript
import { addresses, CHAINS } from '../utils/addresses';

// Set chain context
addresses.setChain('bokuto');

// Get contract addresses (automatic I-prefix handling)
const wethAddress = addresses.getAddress('WETH');      // Finds IWETH
const ausdAddress = addresses.getAddress('AUSD');      // Finds IAUSD

// Origin chain addresses (for Vault Bridge)
const originUSDC = addresses.getOriginAddress('vbUSDC'); // Ethereum address from Katana context
```

### Chain Fork Development
1. Always start with a local fork: `bun run start:anvil <network>`
2. Verify connection: `bun run verify:anvil`
3. The fork runs on `http://localhost:8545` with 12-second block time
4. Example dApp automatically detects the running fork

### Contract Deployment
Use the chain-aware deployment wrapper:
```bash
# Local deployment (uses default anvil account)
bun run forge:deploy -- @script/MyScript.s.sol:MyScript --chain local

# Testnet deployment (reads from .env)
bun run forge:deploy -- @script/MyScript.s.sol:MyScript --chain bokuto
```

### Adding New Contracts
1. Add interface to `contracts/` with `@custom:network address` doccomments
2. Run `bun run build:addressutils` to update address mappings
3. Run `bun run build:abi` to generate ABI files
4. The address system will automatically pick up new contracts

## Environment Configuration

### Required Environment Variables (.env)
```bash
# RPC endpoints (customize to avoid rate limiting)
KATANA_RPC_URL=https://rpc.katana.network/
BOKUTO_RPC_URL=https://rpc-bokuto.katanarpc.com

# Deployment keys (set for live deployments)
KATANA_DEPLOYER_KEY=0x...
BOKUTO_DEPLOYER_KEY=0x...
LOCAL_DEPLOYER_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
```

### MCP Server Configuration
For AI-assisted development with Cursor, add to `.cursor/mcp.json`:
```json
{
  "mcpServers": {
    "foundry": {
      "command": "bun",
      "args": ["/absolute/path/to/specialk/dist-mcp/index.js"],
      "env": {
        "PRIVATE_KEY": "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
        "RPC_URL": "http://localhost:8545"
      }
    }
  }
}
```

## Important Notes

- **Always use chain forks for development**: Start anvil fork before running the dApp
- **Address system is dynamic**: No need to hardcode addresses, use the address management system
- **Origin vs Destination**: Understand the difference between origin chain addresses (Ethereum/Sepolia) and destination chain addresses (Katana/Bokuto)
- **Build order matters**: Run `build:addressutils` before other build steps when adding new contracts
- **MCP server requires absolute paths**: Use full paths in MCP configuration files

## Anonymous Telemetry (Opt-in)

On the first interactive run of any `bun run` script, the kit may prompt:

> "Help improve Katana Starter Kit by sending anonymous usage (event name,
> version, OS)? [y/N]"

- Consent is stored in `.phonehome/config.json` along with:
  - `repoId`: random UUID for this clone
  - `deviceId`: random UUID, generated once per device (stored under
    `~/.katana-phonehome/device-id`)
- Non-blocking and offline-safe: events are written to `.phonehome/queue/` and
  occasionally flushed in the background with an ~800ms network timeout.
- Disabled automatically in CI (`CI`, `GITHUB_ACTIONS`) and with
  `DO_NOT_TRACK=1`.

Environment overrides:

```bash
# Force disable telemetry
KATANA_PHONEHOME=0 bun run build

# Force enable telemetry
KATANA_PHONEHOME=1 bun run build
```

### Implementation details

- Event collector: `utils/phonehome.ts`
- Background flusher: `utils/phonehome_flush.ts`
- Config and queue: `.phonehome/config.json`, `.phonehome/queue/`
- Endpoint override: `PHONEHOME_ENDPOINT` (default
  `https://telemetry.katana.tools/v1/events`)

### Wiring via pre-scripts

Telemetry hooks are attached using npm-style pre-scripts which Bun supports. For
each script `name`, adding `pre{name}` will auto-run before `bun run {name}`.

Examples already wired:

```json
{
  "scripts": {
    "prebuild": "bun utils/phonehome.ts --event build",
    "build": "bun build.js",

    "predev": "bun utils/phonehome.ts --event dev",
    "dev": "cd dist && npx http-server",

    "prestart:anvil": "bun utils/phonehome.ts --event start:anvil",
    "start:anvil": "chmod +x scripts/start_anvil.sh && scripts/start_anvil.sh"
  }
}
```

The pre-script exits immediately if consent is off. When enabled, it only writes
to a local queue and spawns a detached flusher; the main command never waits on
network.

### Tip for LLMs and contributors

- When adding a new script to `package.json`, also add the matching `pre...`
  hook to keep telemetry coverage in sync. Example:

```json
{
  "scripts": {
    "premy:new:cmd": "bun utils/phonehome.ts --event my:new:cmd",
    "my:new:cmd": "bun scripts/my_cmd.js"
  }
}
```

This ensures telemetry evolves with the project without altering developer
workflows.

## Txtx Integration

The project includes txtx runbooks in `runbooks/` for infrastructure-as-code blockchain operations. Use `txtx ls` to see available runbooks and `txtx run <runbook-id>` to execute them.



================================================
FILE: .env.example
================================================
KATANA_RPC_URL=https://rpc.katana.network/
BOKUTO_RPC_URL=https://rpc-bokuto.katanarpc.com

KATANA_DEPLOYER_KEY=0x00000000
BOKUTO_DEPLOYER_KEY=0x00000000
LOCAL_DEPLOYER_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80


================================================
FILE: contracts/README.md
================================================
# Katana Contract Interfaces

This folder contains Solidity interfaces for all core contracts deployed on
**Katana** and **Bokuto** (testnet). These interfaces
provide a unified way to interact with the diverse ecosystem of DeFi protocols,
bridges, oracles, and utilities available across the Katana network.

## ğŸ“‹ Address Management System

The starter kit provides both **Solidity** and **JavaScript/TypeScript**
utilities for managing contract addresses across networks.

### Solidity Address Libraries

Network-specific address libraries are auto-generated and provide type-safe
access to contract addresses:

```solidity
import "./utils/KatanaAddresses.sol";
import "./utils/BokutoAddresses.sol";

contract MyDapp {
    function usebvbEth() external {
        // Automatically gets the correct address for the current network
        address wethAddress = KatanaAddresses.getbvbEthAddress();
        IbvbEth weth = IbvbEth(wethAddress);
        weth.deposit{value: 1 ether}();
    }
}
```

### JavaScript/TypeScript Address API

For frontend applications, use the comprehensive address management system:

```javascript
import { addresses, CHAINS } from '../utils/addresses';

// Set the chain context (by name or ID)
addresses.setChain('katana');
// or addresses.setChain(CHAINS.katana);

// Get contract addresses with automatic "I" prefix handling
const wethAddress = addresses.getAddress('bvbEth');      // Finds IbvbEth automatically
const morphoAddress = addresses.getAddress('MorphoBlue'); // Direct match
const ausdAddress = addresses.getAddress('AUSD');      // Finds IAUSD

// Check contract availability
if (addresses.hasContract('Permit2')) {
  const permit2 = addresses.getAddress('Permit2');
}

// Get all available contracts on current chain
const allContracts = addresses.getAllContracts();

// Cross-chain origin addresses (for Vault Bridge)
addresses.setChain('katana');
const bridgedUSDC = addresses.getAddress('bvbUSDC');      // Katana address
const originUSDC = addresses.getOriginAddress('vbUSDC');  // Ethereum address
```

### Generating Address Utilities

To update the address utilities after adding new contracts:

```bash
bun run build:addressutils
```

This generates:

- **Solidity libraries**: `contracts/utils/[Network]Addresses.sol`
- **Origin chain libraries**: `contracts/utils/[Network]OriginAddresses.sol`
- **TypeScript mapping**: `utils/addresses/mapping.ts` (data only)
- **TypeScript API**: `utils/addresses/index.ts` (user-friendly wrapper)

## ğŸ—ï¸ Contract Categories

### ğŸª™ **Core Tokens**

**Use these when:** You need to interact with primary tokens in the Katana ecosystem

- **[IAUSD](./tokens/IAUSD.sol)** - Agora USD stablecoin, the primary stable
  asset on Katana. Use for stable value transfers, yield farming base asset, and
  as loan/collateral in DeFi protocols.

- **[IbvUSD](./tokens/IbvUSD.sol)** - Bitvault USD - BTC collateralized stablecoin.

- **[IBTCK](./tokens/IBTCK.sol)** - Bitcoin Katana, wrapped Bitcoin on Katana.
  Use for Bitcoin exposure in DeFi applications.

- **[ILBTC](./tokens/ILBTC.sol)** - Lombard Bitcoin, liquid Bitcoin staking
  token. Use when you want Bitcoin exposure with staking rewards.

- **[IKAT](./tokens/IKAT.sol)** - Katana network token. Use for governance,
  staking, and protocol incentives. Currently non-transferable until ~EOY.
  [More info](https://katana.network/blog/the-network-is-katana-the-token-is-kat).

- **[IPOL](./tokens/IPOL.sol)** - Polygon token on Katana. Use for cross-chain
  Polygon ecosystem interactions.

- **[ISUSHI](./tokens/ISUSHI.sol)** - SushiSwap token on Katana. Use for DEX
  interactions and SushiSwap protocol participation.

- **[IMORPHO](./tokens/IMORPHO.sol)** - Morpho protocol token. Use for Morpho
  governance and protocol incentives.

- **[IYFI](./tokens/IYFI.sol)** - Yearn Finance token. Use for Yearn protocol
  interactions and governance.

- **[IweETH](./tokens/IweETH.sol)** - Wrapped liquid staked Ethereum. Use for
  ETH staking exposure with DeFi composability.

- **[IwstETH](./tokens/IwstETH.sol)** - Wrapped staked ETH from Lido. Use for
  ETH staking rewards while maintaining liquidity.

- **[IJitoSOL](./tokens/IJitoSOL.sol)** - Jito liquid staked Solana. Use for
  Solana staking exposure on Katana.

- **[IuBTC](./tokens/IuBTC.sol)** - Universal Bitcoin token. Use for Bitcoin
  yield strategies.

- **[IuSOL](./tokens/IuSOL.sol)** - Universal Solana token. Use for Solana
  yield strategies.

- **[IuSUI](./tokens/IuSUI.sol)** - Universal Sui token. Use for Sui ecosystem
  exposure.

- **[IuXRP](./tokens/IuXRP.sol)** - Universal XRP token. Use for XRP ecosystem
  interactions.

### ğŸŒ‰ **Vault Bridge Ecosystem**

**Use these when:** You're building cross-chain applications or working with
bridged assets

#### Bridged Vault Tokens (Destination Chain)

- **[IbvbEth](./vb/tokens/IbvbEth.sol)** - Bridged vault-bridge ETH on
  destination chains. Use when receiving ETH from Ethereum/Sepolia. Also known
  as WETH (same interface).

- **[IbvbUSDC](./vb/tokens/IbvbUSDC.sol)** - Bridged vault-bridge USDC. Use for
  USDC bridged from origin chains to Katana/testnets.

- **[IbvbUSDS](./vb/tokens/IbvbUSDS.sol)** - Bridged vault-bridge USDS. Use for
  USDS cross-chain transfers.

- **[IbvbUSDT](./vb/tokens/IbvbUSDT.sol)** - Bridged vault-bridge USDT. Use for
  Tether transfers between chains.

- **[IbvbWBTC](./vb/tokens/IbvbWBTC.sol)** - Bridged vault-bridge wrapped
  Bitcoin. Use for Bitcoin cross-chain transfers.

#### Base Interfaces

- **[IVaultBridgeToken](./vb/IVaultBridgeToken.sol)** - Base interface for Vault
  Bridge Token contracts. Use as the foundation for all vault bridge token
  implementations.

- **[IBridgedVaultBridgeEth](./vb/IBridgedVaultBridgeEth.sol)** - Interface for
  Bridged Vault Bridge ETH token. Use for bridged ETH functionality on
  destination chains.

- **[IGenericCustomToken](./vb/IGenericCustomToken.sol)** - Base interface for
  generic custom tokens in the vault bridge ecosystem. Use for custom token
  implementations.

- **[INativeConverter](./vb/INativeConverter.sol)** - Base interface for native
  converter contracts. Use as foundation for all converter implementations.

- **[IMigrationManager](./vb/IMigrationManager.sol)** - Migration manager
  interface for handling cross-chain asset migrations. Use for complex migration
  operations.

#### Native Converters

- **[IUSDCNativeConverter](./vb/converters/IUSDCNativeConverter.sol)** -
  Converts between USDC and yield-bearing versions. Use for USDC yield
  optimization strategies.

- **[IUSDSNativeConverter](./vb/converters/IUSDSNativeConverter.sol)** -
  Converts USDS to yield-bearing format. Use for USDS yield generation.

- **[IUSDTNativeConverter](./vb/converters/IUSDTNativeConverter.sol)** -
  Converts USDT for yield strategies. Use for Tether yield optimization.

- **[IWBTCNativeConverter](./vb/converters/IWBTCNativeConverter.sol)** -
  Converts WBTC for yield strategies. Use for Bitcoin yield generation.

- **[IWETHNativeConverter](./vb/converters/IWETHNativeConverter.sol)** -
  Seamless ETH/WETH(bvbEth) conversion. Use for ETH wrapping/unwrapping in
  applications.

### ğŸ¦ **DeFi Lending & Borrowing**

**Use these when:** Building lending protocols, yield strategies, or leveraged positions

#### Morpho Protocol

- **[IMorphoBlue](./morpho/IMorphoBlue.sol)** - Core Morpho lending protocol.
  Use for creating isolated lending markets, supplying assets, borrowing against
  collateral, and liquidations.

- **[IMorphoAdaptiveIRM](./morpho/IMorphoAdaptiveIRM.sol)** - Adaptive interest
  rate model. Use when creating markets that need dynamic rate optimization.

- **[IMetaMorphoFactory](./morpho/IMetaMorphoFactory.sol)** - Factory for
  MetaMorpho vaults. Use to deploy new yield aggregation vaults.

- **[IMetaMorpho](./morpho/IMetaMorpho.sol)** - ERC-4626 yield aggregator
  vaults. Use for automated yield optimization across multiple Morpho markets.

- **[IPublicAllocator](./morpho/IPublicAllocator.sol)** - Permissionless vault
  rebalancing. Use to optimize MetaMorpho vault allocations for fees.

-
  **[IMorphoChainlinkOracleV2Factory](./morpho/IMorphoChainlinkOracleV2Factory.sol)**
  - Oracle factory for Morpho markets. Use to create price oracles for new
  markets.

- **[IMorphoChainlinkOracleV2](./morpho/IMorphoChainlinkOracleV2.sol)** -
  Chainlink-based price oracles. Use for accurate price feeds in lending
  markets.

- **[IPreLiquidationFactory](./morpho/IPreLiquidationFactory.sol)** - Factory
  for pre-liquidation contracts. Use to create early intervention liquidation
  mechanisms.

- **[IPreLiquidation](./morpho/IPreLiquidation.sol)** - Early liquidation
  system. Use to prevent bad debt by liquidating risky positions before they
  become underwater.

#### Yearn Protocol

- **[IYvAUSD](./yearn/IYvAUSD.sol)** - Yearn AUSD vault for automated yield
  generation. Use to earn yield on AUSD deposits.

- **[IYvWETH](./yearn/IYvWETH.sol)** - Yearn WETH vault for ETH yield
  strategies. Use to earn yield on ETH holdings.

### ğŸ”„ **DEX & Trading**

**Use these when:** Building trading interfaces, implementing swaps, or managing
liquidity

- **[ISushiRouter](./ISushiRouter.sol)** - SushiSwap router for token swaps. Use
  for efficient token exchanges with minimal slippage.

- **[ISushiV3Factory](./ISushiV3Factory.sol)** - SushiSwap V3 factory contract.
  Use to create new trading pairs and manage pool deployments.

- **[ISushiV3PositionManager](./ISushiV3PositionManager.sol)** - Manages
  SushiSwap V3 liquidity positions. Use for sophisticated liquidity provision
  strategies.

### ğŸ–¼ï¸ **NFTs & Marketplaces**

**Use these when:** Building NFT applications, marketplaces, or trading platforms

- **[ISeaport](./opensea/ISeaport.sol)** - OpenSea's advanced marketplace
  protocol. Use for comprehensive NFT trading with complex order types, bulk
  operations, and criteria-based orders.

- **[IConduitController](./opensea/IConduitController.sol)** - Manages Seaport
  conduits for secure transfers. Use to create secure transfer pathways for
  marketplaces.

- **[IConduit](./opensea/IConduit.sol)** - Efficient token transfer system. Use
  for gas-optimized batch transfers in NFT marketplaces.

- **[ICatalogFactory](./nft/ICatalogFactory.sol)** - Factory for NFT catalog
  contracts. Use to deploy new ERC6220 NFT collections with standardized
  features.

- **[ICatalogUtils](./nft/ICatalogUtils.sol)** - Utilities for NFT ERC6220
  catalog management. Use for metadata and collection management tools.

- **[IRenderUtils](./nft/IRenderUtils.sol)** - NFT rendering utilities. Use for
  dynamic NFT metadata and image generation.

- **[ITokenAttributesRepository](./nft/ITokenAttributesRepository.sol)** -
  Repository for NFT attributes. Use for modular NFT trait systems.

- **[IBulkWriter](./nft/IBulkWriter.sol)** - Bulk operations for NFT attributes.
  Use for efficient batch updates of NFT metadata.

### ğŸ” **Security & Multisig**

**Use these when:** Implementing secure transaction patterns or multisig functionality

- **[IGnosisSafe](./IGnosisSafe.sol)** - Industry-standard multisig wallet. Use
  for secure multi-party asset management and governance.

- **[IGnosisSafeL2](./IGnosisSafeL2.sol)** - L2-optimized Gnosis Safe with
  enhanced event logging. Use for gas-efficient multisig operations.

- **[IMultiSend](./IMultiSend.sol)** - Batch transaction execution with call and
  delegatecall support. Use for complex multi-step operations.

- **[IMultiSendCallOnly](./IMultiSendCallOnly.sol)** - Safer batch execution
  (call only). Use when you need transaction batching without delegatecall
  risks.

- **[ISafeExecutor](./ISafeExecutor.sol)** - Safe execution patterns. Use for
  secure contract interactions with built-in safety checks.

### ğŸš€ **Contract Deployment**

**Use these when:** Deploying contracts, especially with deterministic addresses

- **[ICreateX](./ICreateX.sol)** - Comprehensive deployment factory supporting
  CREATE, CREATE2, and CREATE3. Use for advanced deployment patterns,
  cross-chain address consistency, and proxy deployments.

- **[ICreate2Deployer](./ICreate2Deployer.sol)** - CREATE2 deployer with safety
  features. Use for deterministic deployments with additional security.

- **[IDeterministicDeploymentProxy](./IDeterministicDeploymentProxy.sol)** -
  Arachnid's standard proxy for same-address deployments across chains. Use for
  basic cross-chain contract deployment.

### ğŸŒ **Cross-chain Infrastructure**

**Use these when:** Building cross-chain applications or bridges

- **[IBridgeL2SovereignChain](./agglayer/IBridgeL2SovereignChain.sol)** - Bridge
  for cross-chain asset and message transfers. Use for secure inter-chain
  communication.

-
  **[IGlobalExitRootManagerL2SovereignChain](./agglayer/IGlobalExitRootManagerL2SovereignChain.sol)**
  - Manages exit roots for secure withdrawals. Use for cross-chain withdrawal
  verification.

- **[IPolygonZkEVMDeployer](./agglayer/IPolygonZkEVMDeployer.sol)** - Interface
  for the PolygonZkEVMDeployer contract which manages deployments of rollup
  components.

- **[IPolygonZkEVMTimelock](./agglayer/IPolygonZkEVMTimelock.sol)** - Governance
  timelock for administrative actions. Use for secure governance operations.

- **[IProxyAdmin](./agglayer/IProxyAdmin.sol)** - Manages transparent proxy
  upgrades. Use for controlled infrastructure upgrades.

- **[IBridgeExtension](./agglayer/IBridgeExtension.sol)** - Extended bridge
  functionality. Use for advanced cross-chain operations with Agglayer / LXLY
  bridging.

- **[ILxLyBridge](./ILxLyBridge.sol)** - Layer X to Layer Y bridge interface.
  Use for cross-chain asset transfers between different layers.

### ğŸ§® **Utilities & Helpers**

**Use these when:** You need common utility functions or gas optimizations

- **[IMulticall3](./IMulticall3.sol)** - Batch multiple read-only calls in a
  single transaction. Use to reduce RPC calls and improve dApp performance.

- **[IBundler3](./IBundler3.sol)** - Advanced multicall with reentrant callback
  support. Use for complex multi-contract interactions.

- **[IBatchDistributor](./IBatchDistributor.sol)** - Efficient bulk token
  distribution. Use for airdrops, payroll, and reward distribution.

- **[IPermit2](./IPermit2.sol)** - Advanced token approval system with
  signatures and batch operations. Use for better UX in token transfers.

- **[IRIP7212](./IRIP7212.sol)** - secp256r1 signature verification precompile.
  Use for biometric authentication and secure enclave integration.

- **[IAgoraFaucet](./IAgoraFaucet.sol)** - Testnet faucet for obtaining AUSD
  test tokens. Use for testnet development and testing.

### ğŸ“Š **Price Oracles**

**Use these when:** You need reliable price data for DeFi applications

#### Chainlink Oracles

- **[IAggregatorV3Interface](./oracles/chainlink/IAggregatorV3Interface.sol)** -
  Base Chainlink aggregator interface
- **[IEACAggregatorProxy](./oracles/chainlink/IEACAggregatorProxy.sol)** -
  Chainlink aggregator proxy interface
- **[IAUSDUSDOracle](./oracles/chainlink/IAUSDUSDOracle.sol)** - AUSD/USD price
  feed
- **[IBTCUSDOracle](./oracles/chainlink/IBTCUSDOracle.sol)** - Bitcoin/USD price
  feed
- **[IETHUSDOracle](./oracles/chainlink/IETHUSDOracle.sol)** - Ethereum/USD
  price feed
- **[IJitoSOLSOLOracle](./oracles/chainlink/IJitoSOLSOLOracle.sol)** -
  JitoSOL/SOL price feed
- **[IJitoSOLUSDOracle](./oracles/chainlink/IJitoSOLUSDOracle.sol)** -
  JitoSOL/USD price feed
- **[ILBTCBTCOracle](./oracles/chainlink/ILBTCBTCOracle.sol)** - Lombard BTC/BTC
  price feed
- **[ILBTCUSDOracle](./oracles/chainlink/ILBTCUSDOracle.sol)** - Lombard BTC/USD
  price feed
- **[ILINKUSDOracle](./oracles/chainlink/ILINKUSDOracle.sol)** - LINK/USD price
  feed
- **[IMORPHOUSDOracle](./oracles/chainlink/IMORPHOUSDOracle.sol)** - MORPHO/USD
  price feed
- **[IPOLUSDOracle](./oracles/chainlink/IPOLUSDOracle.sol)** - POL/USD price
  feed
- **[ISOLUSDOracle](./oracles/chainlink/ISOLUSDOracle.sol)** - SOL/USD price
  feed
- **[ISUSHIUSDOracle](./oracles/chainlink/ISUSHIUSDOracle.sol)** - SUSHI/USD
  price feed
- **[IUSDCUSDOracle](./oracles/chainlink/IUSDCUSDOracle.sol)** - USDC/USD price
  feed
- **[IUSDSUSDOracle](./oracles/chainlink/IUSDSUSDOracle.sol)** - USDS/USD price
  feed
- **[IUSDTUSDOracle](./oracles/chainlink/IUSDTUSDOracle.sol)** - USDT/USD price
  feed
- **[IWBTCBTCOracle](./oracles/chainlink/IWBTCBTCOracle.sol)** - WBTC/BTC price
  feed
- **[IWBTCUSDOracle](./oracles/chainlink/IWBTCUSDOracle.sol)** - WBTC/USD price
  feed
- **[IweETHETHOracle](./oracles/chainlink/IweETHETHOracle.sol)** - weETH/ETH
  price feed
- **[IwstETHETHOracle](./oracles/chainlink/IwstETHETHOracle.sol)** - wstETH/ETH
  price feed
- **[IYFIUSDOracle](./oracles/chainlink/IYFIUSDOracle.sol)** - YFI/USD price
  feed
- **[IyUSDUSDOracle](./oracles/chainlink/IyUSDUSDOracle.sol)** - yUSD/USD price
  feed

#### RedStone Oracles

- **[IRedstoneAggregator](./oracles/redstone/IRedstoneAggregator.sol)** - Base
  RedStone aggregator interface
- **[IADAUSDOracle](./oracles/redstone/IADAUSDOracle.sol)** - Cardano/USD price
  feed
- **[IAUSDUSDOracle](./oracles/redstone/IAUSDUSDOracle.sol)** - AUSD/USD price
  feed (RedStone)
- **[IBTCUSDOracle](./oracles/redstone/IBTCUSDOracle.sol)** - Bitcoin/USD price
  feed (RedStone)
- **[IETHUSDOracle](./oracles/redstone/IETHUSDOracle.sol)** - Ethereum/USD price
  feed (RedStone)
- **[ILBTCBTCOracle](./oracles/redstone/ILBTCBTCOracle.sol)** - Lombard BTC/BTC
  price feed (RedStone)
- **[ISUIUSDOracle](./oracles/redstone/ISUIUSDOracle.sol)** - Sui/USD price feed
- **[IWBTCUSDOracle](./oracles/redstone/IWBTCUSDOracle.sol)** - WBTC/USD price
  feed (RedStone)
- **[IweETHETHOracle](./oracles/redstone/IweETHETHOracle.sol)** - weETH/ETH
  price feed (RedStone)
- **[IweETHUSDOracle](./oracles/redstone/IweETHUSDOracle.sol)** - weETH/USD
  price feed (RedStone)
- **[IwstETHstETHOracle](./oracles/redstone/IwstETHstETHOracle.sol)** -
  wstETH/stETH price feed (RedStone)
- **[IwstETHUSDOracle](./oracles/redstone/IwstETHUSDOracle.sol)** - wstETH/USD
  price feed (RedStone)
- **[IXRPUSDOracle](./oracles/redstone/IXRPUSDOracle.sol)** - XRP/USD price feed

### âš¡ **Account Abstraction (ERC-4337)**

**Use these when:** Building smart account systems or account abstraction features

#### Common Components

- **[IERC4337](./IERC4337.sol)** - Common interfaces and structures used across
  both v0.6.0 and v0.7.0 of the ERC-4337 standard, including IStakeManager and
  INonceManager.

#### v0.6.0 Implementation

- **[IEntryPoint](./AAv0.6.0/IEntryPoint.sol)** - Core entry point for user
  operations
- **[IERC4337Account](./AAv0.6.0/IERC4337Account.sol)** - Smart account
  interface
- **[ISenderCreator](./AAv0.6.0/ISenderCreator.sol)** - Helper for account
  creation

#### v0.7.0 Implementation

- **[IEntryPoint](./AAv0.7.0/IEntryPoint.sol)** - Updated entry point with
  latest features
- **[IEntryPointSimulations](./AAv0.7.0/IEntryPointSimulations.sol)** -
  Simulation capabilities for v0.7.0
- **[IERC4337Account](./AAv0.7.0/IERC4337Account.sol)** - Updated account
  interface with PackedUserOperation
- **[ISenderCreator](./AAv0.7.0/ISenderCreator.sol)** - v0.7.0 account creation
  helper

### ğŸ“œ **Legacy & Compatibility**

**Use these when:** Working with legacy systems or needing backward compatibility

- **[Multicall](./MultiCall1.sol)** - Original multicall implementation
- **[Multicall2](./MultiCall2.sol)** - Enhanced multicall with failure handling
- **[IERC20](./IERC20.sol)** - Standard ERC-20 token interface
- **[IERC4626](./IERC4626.sol)** - Tokenized vault standard interface

## ğŸ”§ How to Use These Interfaces

### 1. **Import the Interface**

```solidity
import "./contracts/tokens/IAUSD.sol";
import "./contracts/utils/KatanaAddresses.sol";
```

### 2. **Get the Contract Address**

```solidity
address ausdAddress = KatanaAddresses.getAUSDAddress();
```

### 3. **Create Contract Instance**

```solidity
IAUSD ausd = IAUSD(ausdAddress);
```

### 4. **Interact with the Contract**

```solidity
uint256 balance = ausd.balanceOf(msg.sender);
ausd.transfer(recipient, amount);
```

## ğŸ”„ Origin Chain Addresses

For cross-chain operations, some contracts exist on **origin chains**
(Ethereum/Sepolia) while being used in the context of **destination chains**
(Katana/Bokuto):

```solidity
// Access origin chain addresses from destination chain context
import "./contracts/utils/KatanaOriginAddresses.sol";

contract VaultBridgeIntegration {
    function bridgeUSDC() external {
        // Get the origin USDC vault address (on Ethereum)  
        address originVault = KatanaOriginAddresses.getvbUSDCAddress();
        
        // Get the destination bridged token (on Katana)
        address bridgedToken = KatanaAddresses.getbvbUSDCAddress();
    }
}
```

**Chain Context Mapping:**

- **Katana context** â†’ Origin addresses from **Ethereum**
- **Bokuto context** â†’ Origin addresses from **Sepolia**

## ğŸ—ï¸ Examples

Check out the `/examples` folder in the root repository for complete examples
showing how to:

- Build lending interfaces with Morpho
- Create DEX trading bots with SushiSwap  
- Implement NFT marketplaces with Seaport
- Build cross-chain applications with Vault Bridge
- Create yield strategies with Yearn and MetaMorpho

## ğŸ”„ Keeping Addresses Updated

Contract addresses are automatically extracted from the `@custom:network`
doccomments in each interface file. To add a new contract:

1. Create the interface file with proper `@custom:katana`,
   `@custom:bokuto` tags
2. Run `bun run build:addressutils` to regenerate address utilities
3. Use the new contract in your applications via the address management system

This ensures your addresses stay synchronized across Solidity libraries,
TypeScript utilities, and documentation.



================================================
FILE: contracts/IAgoraFaucet.sol
================================================
// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity ^0.8.4;

/**
 * @title IAgoraFaucet
 * @notice Interface for Agora test token faucet
 * @dev Provides testnet token distribution functionality
 * @custom:bokuto 0xd236c18D274E54FAccC3dd9DDA4b27965a73ee6C
 * @custom:tags testnet,faucet,utility
 */
interface IAgoraFaucet {
    error InsufficientFunds();
    error InvalidInitialization();
    error MaxAllowedExceeded();
    error MaxFrequencyExceeded();
    error NotInitializing();
    error SafeERC20FailedOperation(address token);
    event FundsRequested(address indexed receiver, uint256 amount);
    event Initialized(uint64 version);
    event SetLastDripTime(uint256 _lastDripTimestamp);
    event configureFaucet(
        uint256 faucetDripAmount,
        uint256 maxAmountToOwn,
        uint256 maxDripFrequency
    );

    function AGORA_FAUCET_STORAGE_SLOT() external view returns (bytes32);

    function faucetDripAmount() external view returns (uint256);

    function initialize(InitializeParams memory _params) external;

    function lastDripTimestamp() external view returns (uint256);

    function maxAmountToOwn() external view returns (uint256);

    function maxDripFrequency() external view returns (uint256);

    function requestFunds(address _receiver) external;

    function token() external view returns (address);
}

struct InitializeParams {
    address tokenToDistribute;
    uint256 faucetDripAmount;
    uint256 maxAmountToOwn;
    uint256 maxDripFrequency;
}

// THIS FILE WAS AUTOGENERATED FROM THE FOLLOWING ABI JSON:
/*
[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"InsufficientFunds","type":"error"},{"inputs":[],"name":"InvalidInitialization","type":"error"},{"inputs":[],"name":"MaxAllowedExceeded","type":"error"},{"inputs":[],"name":"MaxFrequencyExceeded","type":"error"},{"inputs":[],"name":"NotInitializing","type":"error"},{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"SafeERC20FailedOperation","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"receiver","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"FundsRequested","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint64","name":"version","type":"uint64"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"_lastDripTimestamp","type":"uint256"}],"name":"SetLastDripTime","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"faucetDripAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"maxAmountToOwn","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"maxDripFrequency","type":"uint256"}],"name":"configureFaucet","type":"event"},{"inputs":[],"name":"AGORA_FAUCET_STORAGE_SLOT","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"faucetDripAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"tokenToDistribute","type":"address"},{"internalType":"uint256","name":"faucetDripAmount","type":"uint256"},{"internalType":"uint256","name":"maxAmountToOwn","type":"uint256"},{"internalType":"uint256","name":"maxDripFrequency","type":"uint256"}],"internalType":"struct InitializeParams","name":"_params","type":"tuple"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"lastDripTimestamp","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"maxAmountToOwn","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"maxDripFrequency","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_receiver","type":"address"}],"name":"requestFunds","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"token","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}]
*/


================================================
FILE: contracts/IBatchDistributor.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IERC20.sol";

/**
 * @title IBatchDistributor
 * @dev Interface for the native and ERC-20 token batch distribution contract
 * @notice Allows gas-efficient distribution of ETH and ERC-20 tokens to multiple recipients in one transaction
 * @custom:katana 0x66C0499B1Df146dbaf4B1DEa1df436ba26DAfF21
 * @custom:bokuto 0x2A6fd05d3C6A373FBb073dea12bCee7C174AE606
 * @custom:tags utility,batch,distribution,erc20
 */
interface IBatchDistributor {
    /**
     * @dev Transaction struct for the recipient and amount data
     */
    struct Transaction {
        address payable recipient;
        uint256 amount;
    }

    /**
     * @dev Batch struct containing an array of transactions
     */
    struct Batch {
        Transaction[] txns;
    }

    /**
     * @dev Error thrown when an ETH transfer fails
     * @param emitter The contract that emitted the error
     */
    error EtherTransferFail(address emitter);

    /**
     * @notice Distributes ETH to multiple recipients in a single transaction
     * @dev Any excess ETH is refunded to the sender
     * @param batch A struct containing an array of recipient/amount pairs
     */
    function distributeEther(Batch calldata batch) external payable;

    /**
     * @notice Distributes ERC-20 tokens to multiple recipients in a single transaction
     * @dev Optimized to save gas by batching transfers
     * @param token The ERC-20 token contract address
     * @param batch A struct containing an array of recipient/amount pairs
     */
    function distributeToken(IERC20 token, Batch calldata batch) external;
} 


================================================
FILE: contracts/IBundler3.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IBundler3
 * @notice Interface for the Bundler3 contract, which enables batching multiple calls in a single transaction
 * @author Morpho Labs
 * @custom:contact security@morpho.org
 * @custom:bokuto 0xD0bDf3E62F6750Bd83A50b4001743898Af287009
 * @custom:tags morpho,bundler,batch,utility
 */
interface IBundler3 {
    /**
     * @notice Struct containing all the data needed to make a call
     * @param to The call target address
     * @param data The calldata to execute
     * @param value The ETH value to send with the call
     * @param skipRevert If true, other planned calls will continue executing even if this call reverts
     * @param callbackHash The hash of the reenter bundle data (if a callback is expected)
     */
    struct Call {
        address to;
        bytes data;
        uint256 value;
        bool skipRevert;
        bytes32 callbackHash;
    }

    /**
     * @notice Executes a sequence of calls in order
     * @dev Locks the initiator for the duration of the multicall
     * @param bundle The ordered array of calls to execute
     */
    function multicall(Call[] calldata bundle) external payable;

    /**
     * @notice Executes a sequence of calls during a callback
     * @dev Can only be called by the last unreturned callee with known data
     * @param bundle The ordered array of calls to execute
     */
    function reenter(Call[] calldata bundle) external;

    /**
     * @notice Returns the hash used to authorize reentry
     * @return The current reenter hash
     */
    function reenterHash() external view returns (bytes32);

    /**
     * @notice Returns the address that initiated the current multicall
     * @return The address of the multicall initiator
     */
    function initiator() external view returns (address);
} 


================================================
FILE: contracts/ICreate2Deployer.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title ICreate2Deployer
 * @dev Interface for the Create2Deployer contract on Katana
 * @notice Helper contract for using CREATE2 opcode with additional safety features and utilities
 * @custom:bokuto 0x13b0D85CcB8bf860b6b79AF3029fCA081AE9beF2
 */
interface ICreate2Deployer {
    /**
     * @notice Deploys a contract using CREATE2 opcode
     * @dev Allows creating contracts at deterministic addresses
     * @param value Amount of ETH to send to the created contract
     * @param salt Unique value for determining the contract address
     * @param code The contract bytecode to deploy
     */
    function deploy(uint256 value, bytes32 salt, bytes memory code) external;

    /**
     * @notice Deploys an ERC1820Implementer contract using CREATE2 opcode
     * @dev Specialized deployment for ERC1820 implementation
     * @param value Amount of ETH to send to the created contract
     * @param salt Unique value for determining the contract address
     */
    function deployERC1820Implementer(uint256 value, bytes32 salt) external;

    /**
     * @notice Computes the address where a contract would be deployed using CREATE2
     * @param salt Unique value for determining the contract address
     * @param codeHash Hash of the contract creation code
     * @return The computed address
     */
    function computeAddress(bytes32 salt, bytes32 codeHash) external view returns (address);

    /**
     * @notice Computes the address a contract would have if deployed by a specific deployer
     * @param salt Unique value for determining the contract address
     * @param codeHash Hash of the contract creation code
     * @param deployer Address of the contract that would deploy the new contract
     * @return The computed address
     */
    function computeAddressWithDeployer(
        bytes32 salt,
        bytes32 codeHash,
        address deployer
    ) external pure returns (address);

    /**
     * @notice Pauses the contract's deployments
     * @dev Can only be called by the contract owner
     */
    function pause() external;

    /**
     * @notice Unpauses the contract's deployments
     * @dev Can only be called by the contract owner
     */
    function unpause() external;
} 


================================================
FILE: contracts/ICreateX.sol
================================================
// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity ^0.8.4;

/**
 * @title CreateX Factory Interface Definition
 * @author pcaversaccio (https://web.archive.org/web/20230921103111/https://pcaversaccio.com/)
 * @custom:coauthor Matt Solomon (https://web.archive.org/web/20230921103335/https://mattsolomon.dev/)
 * @notice Advanced contract deployment factory supporting CREATE, CREATE2, and CREATE3 deployment patterns
 * @dev Deployed at the same address across all EVM chains: 0xba5Ed099633D3B313e4D5F7bdc1305d3c28ba5Ed
 * @custom:bokuto 0xba5Ed099633D3B313e4D5F7bdc1305d3c28ba5Ed
 * @custom:tags deployment,factory,create2,create3,utility
 */
interface ICreateX {
    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/
    /*                            TYPES                           */
    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/

    /**
     * @dev Struct for handling ETH values in deployment operations
     * @param constructorAmount ETH amount to send during contract creation
     * @param initCallAmount ETH amount to send during initialization call
     */
    struct Values {
        uint256 constructorAmount;
        uint256 initCallAmount;
    }

    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/
    /*                           EVENTS                           */
    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/

    /**
     * @dev Emitted when a contract is created with CREATE2 or CREATE3 (with salt)
     * @param newContract Address of the newly created contract
     * @param salt The salt used for address derivation
     */
    event ContractCreation(address indexed newContract, bytes32 indexed salt);
    
    /**
     * @dev Emitted when a contract is created with CREATE (no salt)
     * @param newContract Address of the newly created contract
     */
    event ContractCreation(address indexed newContract);
    
    /**
     * @dev Emitted when a CREATE3 proxy contract is deployed
     * @param newContract Address of the newly created proxy
     * @param salt The salt used for the proxy address derivation
     */
    event Create3ProxyContractCreation(address indexed newContract, bytes32 indexed salt);

    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/
    /*                        CUSTOM ERRORS                       */
    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/

    /**
     * @dev Thrown when contract creation fails
     * @param emitter The address that emitted the error
     */
    error FailedContractCreation(address emitter);
    
    /**
     * @dev Thrown when contract initialization fails
     * @param emitter The address that emitted the error
     * @param revertData The revert data from the failed initialization
     */
    error FailedContractInitialisation(address emitter, bytes revertData);
    
    /**
     * @dev Thrown when an invalid salt is provided
     * @param emitter The address that emitted the error
     */
    error InvalidSalt(address emitter);
    
    /**
     * @dev Thrown when an invalid nonce value is provided
     * @param emitter The address that emitted the error
     */
    error InvalidNonceValue(address emitter);
    
    /**
     * @dev Thrown when an ETH transfer fails
     * @param emitter The address that emitted the error
     * @param revertData The revert data from the failed transfer
     */
    error FailedEtherTransfer(address emitter, bytes revertData);

    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/
    /*                           CREATE                           */
    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/

    /**
     * @notice Deploys a contract using the standard CREATE opcode
     * @dev Uses the standard Ethereum CREATE opcode with nonce-based addressing
     * @param initCode The contract creation bytecode and constructor args
     * @return newContract Address of the newly deployed contract
     */
    function deployCreate(bytes memory initCode) external payable returns (address newContract);

    /**
     * @notice Deploys a contract using CREATE and initializes it with a separate call
     * @dev Useful for factory patterns that need post-deployment initialization
     * @param initCode The contract creation bytecode and constructor args
     * @param data Initialization calldata for the post-deployment call
     * @param values ETH amounts to send during creation and initialization
     * @param refundAddress Address to receive any unused ETH
     * @return newContract Address of the newly deployed contract
     */
    function deployCreateAndInit(
        bytes memory initCode,
        bytes memory data,
        Values memory values,
        address refundAddress
    ) external payable returns (address newContract);

    /**
     * @notice Deploys a contract using CREATE and initializes it, without refund
     * @dev Same as deployCreateAndInit but without refund parameter
     * @param initCode The contract creation bytecode and constructor args
     * @param data Initialization calldata for the post-deployment call
     * @param values ETH amounts to send during creation and initialization
     * @return newContract Address of the newly deployed contract
     */
    function deployCreateAndInit(
        bytes memory initCode,
        bytes memory data,
        Values memory values
    ) external payable returns (address newContract);

    /**
     * @notice Deploys a minimal proxy (EIP-1167 clone) using CREATE
     * @dev Gas-efficient way to deploy copies of an existing contract
     * @param implementation Address of the implementation contract to clone
     * @param data Initialization calldata for the post-deployment call
     * @return proxy Address of the newly deployed proxy contract
     */
    function deployCreateClone(address implementation, bytes memory data) external payable returns (address proxy);

    /**
     * @notice Computes the address where a contract will be deployed using CREATE
     * @dev Given a deployer address and nonce, computes the resulting contract address
     * @param deployer The address that will deploy the contract
     * @param nonce The deployer's nonce (transaction count)
     * @return computedAddress The address where the contract will be deployed
     */
    function computeCreateAddress(address deployer, uint256 nonce) external view returns (address computedAddress);

    /**
     * @notice Computes the address where a contract will be deployed by this factory
     * @dev Computes the resulting contract address using this contract's address and nonce
     * @param nonce The factory's nonce (transaction count)
     * @return computedAddress The address where the contract will be deployed
     */
    function computeCreateAddress(uint256 nonce) external view returns (address computedAddress);

    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/
    /*                           CREATE2                          */
    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/

    /**
     * @notice Deploys a contract using CREATE2 with a specified salt
     * @dev Produces deterministic addresses based on deployer, salt, and initcode
     * @param salt The salt used for address derivation
     * @param initCode The contract creation bytecode and constructor args
     * @return newContract Address of the newly deployed contract
     */
    function deployCreate2(bytes32 salt, bytes memory initCode) external payable returns (address newContract);

    /**
     * @notice Deploys a contract using CREATE2 with a default salt of bytes32(0)
     * @dev Simplified CREATE2 deployment with zero salt
     * @param initCode The contract creation bytecode and constructor args
     * @return newContract Address of the newly deployed contract
     */
    function deployCreate2(bytes memory initCode) external payable returns (address newContract);

    /**
     * @notice Deploys a contract using CREATE2 and initializes it with a separate call
     * @dev Most complete CREATE2 deployment option with salt, init call, and refund
     * @param salt The salt used for address derivation
     * @param initCode The contract creation bytecode and constructor args
     * @param data Initialization calldata for the post-deployment call
     * @param values ETH amounts to send during creation and initialization
     * @param refundAddress Address to receive any unused ETH
     * @return newContract Address of the newly deployed contract
     */
    function deployCreate2AndInit(
        bytes32 salt,
        bytes memory initCode,
        bytes memory data,
        Values memory values,
        address refundAddress
    ) external payable returns (address newContract);

    /**
     * @notice Deploys a contract using CREATE2 and initializes it without refund
     * @dev CREATE2 deployment with salt and init call but no refund
     * @param salt The salt used for address derivation
     * @param initCode The contract creation bytecode and constructor args
     * @param data Initialization calldata for the post-deployment call
     * @param values ETH amounts to send during creation and initialization
     * @return newContract Address of the newly deployed contract
     */
    function deployCreate2AndInit(
        bytes32 salt,
        bytes memory initCode,
        bytes memory data,
        Values memory values
    ) external payable returns (address newContract);

    /**
     * @notice Deploys a contract using CREATE2 with zero salt and initializes it
     * @dev Simplified CREATE2 with initialization and refund
     * @param initCode The contract creation bytecode and constructor args
     * @param data Initialization calldata for the post-deployment call
     * @param values ETH amounts to send during creation and initialization
     * @param refundAddress Address to receive any unused ETH
     * @return newContract Address of the newly deployed contract
     */
    function deployCreate2AndInit(
        bytes memory initCode,
        bytes memory data,
        Values memory values,
        address refundAddress
    ) external payable returns (address newContract);

    /**
     * @notice Deploys a contract using CREATE2 with zero salt and initializes it without refund
     * @dev Minimal CREATE2 with initialization
     * @param initCode The contract creation bytecode and constructor args
     * @param data Initialization calldata for the post-deployment call
     * @param values ETH amounts to send during creation and initialization
     * @return newContract Address of the newly deployed contract
     */
    function deployCreate2AndInit(
        bytes memory initCode,
        bytes memory data,
        Values memory values
    ) external payable returns (address newContract);

    /**
     * @notice Deploys a minimal proxy (EIP-1167 clone) using CREATE2
     * @dev Gas-efficient way to deploy deterministic proxies
     * @param salt The salt used for address derivation
     * @param implementation Address of the implementation contract to clone
     * @param data Initialization calldata for the post-deployment call
     * @return proxy Address of the newly deployed proxy contract
     */
    function deployCreate2Clone(
        bytes32 salt,
        address implementation,
        bytes memory data
    ) external payable returns (address proxy);

    /**
     * @notice Deploys a minimal proxy (EIP-1167 clone) using CREATE2 with zero salt
     * @dev Simplified version for deploying clones
     * @param implementation Address of the implementation contract to clone
     * @param data Initialization calldata for the post-deployment call
     * @return proxy Address of the newly deployed proxy contract
     */
    function deployCreate2Clone(address implementation, bytes memory data) external payable returns (address proxy);

    /**
     * @notice Computes the address where a contract would be deployed using CREATE2
     * @dev Returns address based on deployer, salt, and initcode hash
     * @param salt The salt used for address derivation
     * @param initCodeHash Hash of the contract creation bytecode
     * @param deployer The address that will deploy the contract
     * @return computedAddress The address where the contract will be deployed
     */
    function computeCreate2Address(
        bytes32 salt,
        bytes32 initCodeHash,
        address deployer
    ) external pure returns (address computedAddress);

    /**
     * @notice Computes the address where a contract would be deployed by this factory
     * @dev Returns address based on this factory, salt, and initcode hash
     * @param salt The salt used for address derivation
     * @param initCodeHash Hash of the contract creation bytecode
     * @return computedAddress The address where the contract will be deployed
     */
    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) external view returns (address computedAddress);

    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/
    /*                           CREATE3                          */
    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/

    /**
     * @notice Deploys a contract using CREATE3 pattern with specified salt
     * @dev Eliminates initcode dependency from address derivation (unlike CREATE2)
     * @param salt The salt used for address derivation
     * @param initCode The contract creation bytecode and constructor args
     * @return newContract Address of the newly deployed contract
     */
    function deployCreate3(bytes32 salt, bytes memory initCode) external payable returns (address newContract);

    /**
     * @notice Deploys a contract using CREATE3 with a default salt of bytes32(0)
     * @dev Simplified CREATE3 deployment with zero salt
     * @param initCode The contract creation bytecode and constructor args
     * @return newContract Address of the newly deployed contract
     */
    function deployCreate3(bytes memory initCode) external payable returns (address newContract);

    /**
     * @notice Deploys a contract using CREATE3 and initializes it with a separate call
     * @dev Most complete CREATE3 deployment option with salt, init call, and refund
     * @param salt The salt used for address derivation
     * @param initCode The contract creation bytecode and constructor args
     * @param data Initialization calldata for the post-deployment call
     * @param values ETH amounts to send during creation and initialization
     * @param refundAddress Address to receive any unused ETH
     * @return newContract Address of the newly deployed contract
     */
    function deployCreate3AndInit(
        bytes32 salt,
        bytes memory initCode,
        bytes memory data,
        Values memory values,
        address refundAddress
    ) external payable returns (address newContract);

    /**
     * @notice Deploys a contract using CREATE3 and initializes it without refund
     * @dev CREATE3 deployment with salt and init call but no refund
     * @param salt The salt used for address derivation
     * @param initCode The contract creation bytecode and constructor args
     * @param data Initialization calldata for the post-deployment call
     * @param values ETH amounts to send during creation and initialization
     * @return newContract Address of the newly deployed contract
     */
    function deployCreate3AndInit(
        bytes32 salt,
        bytes memory initCode,
        bytes memory data,
        Values memory values
    ) external payable returns (address newContract);

    /**
     * @notice Deploys a contract using CREATE3 with zero salt and initializes it
     * @dev Simplified CREATE3 with initialization and refund
     * @param initCode The contract creation bytecode and constructor args
     * @param data Initialization calldata for the post-deployment call
     * @param values ETH amounts to send during creation and initialization
     * @param refundAddress Address to receive any unused ETH
     * @return newContract Address of the newly deployed contract
     */
    function deployCreate3AndInit(
        bytes memory initCode,
        bytes memory data,
        Values memory values,
        address refundAddress
    ) external payable returns (address newContract);

    /**
     * @notice Deploys a contract using CREATE3 with zero salt and initializes it without refund
     * @dev Minimal CREATE3 with initialization
     * @param initCode The contract creation bytecode and constructor args
     * @param data Initialization calldata for the post-deployment call
     * @param values ETH amounts to send during creation and initialization
     * @return newContract Address of the newly deployed contract
     */
    function deployCreate3AndInit(
        bytes memory initCode,
        bytes memory data,
        Values memory values
    ) external payable returns (address newContract);

    /**
     * @notice Computes the address where a contract would be deployed using CREATE3
     * @dev CREATE3 addresses depend only on deployer and salt (not initcode)
     * @param salt The salt used for address derivation
     * @param deployer The address that will deploy the contract
     * @return computedAddress The address where the contract will be deployed
     */
    function computeCreate3Address(bytes32 salt, address deployer) external pure returns (address computedAddress);

    /**
     * @notice Computes the address where a contract would be deployed by this factory
     * @dev Returns address based on this factory and salt only
     * @param salt The salt used for address derivation
     * @return computedAddress The address where the contract will be deployed
     */
    function computeCreate3Address(bytes32 salt) external view returns (address computedAddress);
}


================================================
FILE: contracts/IDeterministicDeploymentProxy.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IDeterministicDeploymentProxy
 * @dev Interface for Deterministic Deployment Proxy on Katana
 * @notice This contract enables deploying other contracts at the same address across different EVM chains
 * @custom:bokuto 0x4e59b44847b379578588920cA78FbF26c0B4956C
 */
interface IDeterministicDeploymentProxy {
    /**
     * @dev Deploys a contract using CREATE2 to ensure the same deployment address across chains
     * @notice The calldata format is {bytes32 salt}{bytecode}
     * where:
     *   - salt: 32-byte value used to determine the deployment address
     *   - bytecode: The contract bytecode to deploy
     * @notice Any msg.value sent will be passed to the created contract
     * @return The address of the deployed contract (only returns the last 20 bytes)
     */
    function deploy(bytes calldata initCode) external payable returns (address);
} 


================================================
FILE: contracts/IERC20.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IERC20
 * @dev Interface for the ERC20 standard token contract
 * @custom:tags erc20,token,standard
 */
interface IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
} 


================================================
FILE: contracts/IERC4337.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IERC4337 Common Interfaces
 * @notice Shared types and interfaces for ERC-4337 Account Abstraction standard
 * @dev These interfaces are common between v0.6.0 and v0.7.0 versions
 * @custom:tags account-abstraction,erc4337,standard
 */

/**
 * @dev Validates user operations and handles their execution
 * @notice This interface defines common types used in ERC-4337
 */
interface IERC4337Common {
    /**
     * @dev Emitted when an account has been successfully deployed
     * @param userOpHash The hash of the user operation that deployed the account
     * @param sender The address of the deployed account
     * @param factory The factory that deployed the account
     * @param paymaster The paymaster used for this deployment
     */
    event AccountDeployed(bytes32 indexed userOpHash, address indexed sender, address factory, address paymaster);
    
    /**
     * @dev Emitted after each successful user operation
     * @param userOpHash The hash of the user operation
     * @param sender The sender account
     * @param paymaster The paying account (if different from sender)
     * @param nonce The nonce of the transaction
     * @param success Whether the operation succeeded
     * @param actualGasCost The gas cost of the operation
     * @param actualGasUsed The gas used by the operation
     */
    event UserOperationEvent(bytes32 indexed userOpHash, address indexed sender, address indexed paymaster, uint256 nonce, bool success, uint256 actualGasCost, uint256 actualGasUsed);
    
    /**
     * @dev Emitted when a user operation reverts with reason
     * @param userOpHash The hash of the user operation
     * @param sender The sender account
     * @param nonce The nonce of the transaction
     * @param revertReason The reason for reversion
     */
    event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason);
    
    /**
     * @dev Emitted before execution of a batch of operations
     */
    event BeforeExecution();
    
    /**
     * @dev Emitted when signature aggregator is changed
     * @param aggregator The address of the new aggregator
     */
    event SignatureAggregatorChanged(address indexed aggregator);
    
    /**
     * @dev Error thrown when an operation fails
     * @param opIndex Index of the failed operation
     * @param reason Reason for the failure
     */
    error FailedOp(uint256 opIndex, string reason);
    
    /**
     * @dev Error thrown when signature validation fails
     * @param aggregator The address of the aggregator that failed
     */
    error SignatureValidationFailed(address aggregator);
    
    /**
     * @dev Structure for returning validation results
     * @param returnInfo Gas and time-range returned values
     * @param senderInfo Stake information about the sender
     * @param factoryInfo Stake information about the factory
     * @param paymasterInfo Stake information about the paymaster
     */
    error ValidationResult(ReturnInfo returnInfo, StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo);
    
    /**
     * @dev Structure for returning validation results with aggregation
     * @param returnInfo Gas and time-range returned values
     * @param senderInfo Stake information about the sender
     * @param factoryInfo Stake information about the factory
     * @param paymasterInfo Stake information about the paymaster 
     * @param aggregatorInfo Signature aggregation info
     */
    error ValidationResultWithAggregation(ReturnInfo returnInfo, StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo, AggregatorStakeInfo aggregatorInfo);
    
    /**
     * @dev Result of sender address calculation
     * @param sender The calculated sender address
     */
    error SenderAddressResult(address sender);
    
    /**
     * @dev Result of simulation execution
     * @param preOpGas Gas used before the operation
     * @param paid Amount paid
     * @param validAfter Timestamp from which the operation is valid
     * @param validUntil Timestamp until which the operation is valid
     * @param targetSuccess Whether the target call succeeded
     * @param targetResult The result of the target call
     */
    error ExecutionResult(uint256 preOpGas, uint256 paid, uint48 validAfter, uint48 validUntil, bool targetSuccess, bytes targetResult);

    /**
     * @dev Gas and return values during simulation
     * @param preOpGas Gas consumed in validation
     * @param prefund Required prefund amount
     * @param sigFailed Whether signature validation failed
     * @param validAfter Timestamp from which the operation is valid
     * @param validUntil Timestamp until which the operation is valid
     * @param paymasterContext Context from paymaster validation
     */
    struct ReturnInfo {
        uint256 preOpGas;
        uint256 prefund;
        bool sigFailed;
        uint48 validAfter;
        uint48 validUntil;
        bytes paymasterContext;
    }

    /**
     * @dev Stake information
     * @param stake Amount staked
     * @param unstakeDelaySec Delay for unstaking
     */
    struct StakeInfo {
        uint256 stake;
        uint256 unstakeDelaySec;
    }

    /**
     * @dev Aggregator stake information
     * @param aggregator The aggregator address
     * @param stakeInfo The stake information
     */
    struct AggregatorStakeInfo {
        address aggregator;
        StakeInfo stakeInfo;
    }
}

/**
 * @title IStakeManager Interface
 * @notice Manages deposits and stakes for ERC-4337 entities
 * @custom:component Common component for both v0.6.0 and v0.7.0
 */
interface IStakeManager {
    /**
     * @dev Emitted when funds are deposited
     * @param account Account that received deposit
     * @param totalDeposit New total deposit for the account
     */
    event Deposited(address indexed account, uint256 totalDeposit);

    /**
     * @dev Emitted when funds are withdrawn
     * @param account Account that withdrew funds
     * @param withdrawAddress Address receiving the funds
     * @param amount Amount withdrawn
     */
    event Withdrawn(address indexed account, address withdrawAddress, uint256 amount);

    /**
     * @dev Emitted when stake or unstake delay are modified
     * @param account Account that locked stake
     * @param totalStaked Amount staked
     * @param unstakeDelaySec Unstake delay in seconds
     */
    event StakeLocked(address indexed account, uint256 totalStaked, uint256 unstakeDelaySec);

    /**
     * @dev Emitted once a stake is scheduled for withdrawal
     * @param account Account that unlocked stake
     * @param withdrawTime Time when the stake can be withdrawn
     */
    event StakeUnlocked(address indexed account, uint256 withdrawTime);

    /**
     * @dev Emitted when stake is withdrawn
     * @param account Account that withdrew stake
     * @param withdrawAddress Address receiving the stake
     * @param amount Amount withdrawn
     */
    event StakeWithdrawn(address indexed account, address withdrawAddress, uint256 amount);

    /**
     * @dev Deposit info for an account
     * @param deposit The entity's deposit
     * @param staked Whether the entity is staked
     * @param stake Amount of staked ether
     * @param unstakeDelaySec Minimum delay for unstaking
     * @param withdrawTime First timestamp when withdrawStake can be called
     */
    struct DepositInfo {
        uint112 deposit;
        bool staked;
        uint112 stake;
        uint32 unstakeDelaySec;
        uint48 withdrawTime;
    }

    /**
     * @dev Get deposit info for an account
     * @param account The account to query
     * @return info Full deposit information
     */
    function getDepositInfo(address account) external view returns (DepositInfo memory info);

    /**
     * @dev Get account balance
     * @param account The account to query
     * @return The deposit amount for the account
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Add to the deposit of an account
     * @param account The account to add funds to
     */
    function depositTo(address account) external payable;

    /**
     * @dev Add stake and set unstake delay
     * @param _unstakeDelaySec New unstake delay period
     */
    function addStake(uint32 _unstakeDelaySec) external payable;

    /**
     * @dev Request to unlock the stake
     * @notice Stake can be withdrawn after unstake delay
     */
    function unlockStake() external;

    /**
     * @dev Withdraw stake to an address
     * @param withdrawAddress Address to receive the stake
     */
    function withdrawStake(address payable withdrawAddress) external;

    /**
     * @dev Withdraw deposit to an address
     * @param withdrawAddress Address to receive the funds
     * @param withdrawAmount Amount to withdraw
     */
    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external;
}

/**
 * @title INonceManager Interface
 * @notice Manages nonces for ERC-4337 accounts
 * @custom:component Common component for both v0.6.0 and v0.7.0
 */
interface INonceManager {
    /**
     * @dev Get the next nonce for an account
     * @param sender The account address
     * @param key The nonce key (high 192 bits)
     * @return nonce Full nonce to use in the next UserOp
     */
    function getNonce(address sender, uint192 key) external view returns (uint256 nonce);

    /**
     * @dev Manually increment account nonce
     * @param key The nonce key
     */
    function incrementNonce(uint192 key) external;
} 


================================================
FILE: contracts/IERC4626.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IERC4626
 * @notice Minimal interface for ERC4626 tokenized vaults
 * @dev Only includes the functions needed for Morpho Chainlink Oracle integration
 * @custom:tags erc4626,vault,standard,defi
 */
interface IERC4626 {
    /**
     * @notice Converts a given number of shares to the amount of assets they represent
     * @param shares The amount of shares to convert
     * @return The amount of assets that the shares represent
     */
    function convertToAssets(uint256 shares) external view returns (uint256);
} 


================================================
FILE: contracts/IGnosisSafe.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IGnosisSafe
 * @dev Interface for the Gnosis Safe multisignature wallet on Katana
 * @notice This contract enables multisig wallet functionality with support for ERC191 signatures
 * @custom:bokuto 0x69f4D1788e39c87893C980c06EdF4b7f686e2938
 * @custom:tags gnosis,multisig,wallet,security
 */
interface IGnosisSafe {
    enum Operation {
        Call,
        DelegateCall
    }

    /// @dev Setup event emitted on Safe initialization
    event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);
    
    /// @dev Emitted when a new hash is approved by an owner
    event ApproveHash(bytes32 indexed approvedHash, address indexed owner);
    
    /// @dev Emitted when a message is signed
    event SignMsg(bytes32 indexed msgHash);
    
    /// @dev Emitted when an execution fails
    event ExecutionFailure(bytes32 txHash, uint256 payment);
    
    /// @dev Emitted when an execution succeeds
    event ExecutionSuccess(bytes32 txHash, uint256 payment);

    /**
     * @dev Initializes the Safe with owners and threshold
     * @param _owners List of Safe owners
     * @param _threshold Number of required confirmations for a Safe transaction
     * @param to Contract address for optional delegate call
     * @param data Data payload for optional delegate call
     * @param fallbackHandler Handler for fallback calls to this contract
     * @param paymentToken Token that should be used for the payment (0 is ETH)
     * @param payment Value that should be paid
     * @param paymentReceiver Address that should receive the payment (or 0 if tx.origin)
     */
    function setup(
        address[] calldata _owners,
        uint256 _threshold,
        address to,
        bytes calldata data,
        address fallbackHandler,
        address paymentToken,
        uint256 payment,
        address payable paymentReceiver
    ) external;

    /**
     * @dev Allows to execute a Safe transaction confirmed by required number of owners
     * @param to Destination address of Safe transaction
     * @param value Ether value of Safe transaction
     * @param data Data payload of Safe transaction
     * @param operation Operation type of Safe transaction
     * @param safeTxGas Gas that should be used for the Safe transaction
     * @param baseGas Gas costs that are independent of the transaction execution
     * @param gasPrice Gas price that should be used for the payment calculation
     * @param gasToken Token address (or 0 if ETH) that is used for the payment
     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin)
     * @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})
     * @return success Returns boolean indicating whether the transaction executed successfully
     */
    function execTransaction(
        address to,
        uint256 value,
        bytes calldata data,
        Operation operation,
        uint256 safeTxGas,
        uint256 baseGas,
        uint256 gasPrice,
        address gasToken,
        address payable refundReceiver,
        bytes calldata signatures
    ) external payable returns (bool success);

    /**
     * @dev Allows to execute a Safe transaction confirmed by required number of owners
     * and with specified nonce
     * @param to Destination address of Safe transaction
     * @param value Ether value of Safe transaction
     * @param data Data payload of Safe transaction
     * @param operation Operation type of Safe transaction
     * @param nonce Transaction nonce
     * @return success Returns boolean indicating whether the transaction executed successfully
     */
    function execTransactionFromModule(
        address to,
        uint256 value,
        bytes calldata data,
        Operation operation,
        uint256 nonce
    ) external returns (bool success);

    /**
     * @dev Marks a hash as approved
     * @param hashToApprove The hash that should be marked as approved for signatures
     */
    function approveHash(bytes32 hashToApprove) external;

    /**
     * @dev Returns the hash of a transaction with a specific nonce
     * @param to Destination address of Safe transaction
     * @param value Ether value of Safe transaction
     * @param data Data payload of Safe transaction
     * @param operation Operation type of Safe transaction
     * @param safeTxGas Gas that should be used for the Safe transaction
     * @param baseGas Gas costs for data used to trigger the safe transaction
     * @param gasPrice Maximum gas price that should be used for this transaction
     * @param gasToken Token address (or 0 if ETH) that is used for the payment
     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin)
     * @param _nonce Transaction nonce
     * @return Transaction hash
     */
    function getTransactionHash(
        address to,
        uint256 value,
        bytes calldata data,
        Operation operation,
        uint256 safeTxGas,
        uint256 baseGas,
        uint256 gasPrice,
        address gasToken,
        address refundReceiver,
        uint256 _nonce
    ) external view returns (bytes32);

    /**
     * @dev Returns hash to be signed by owners
     * @param to Destination address of Safe transaction
     * @param value Ether value of Safe transaction
     * @param data Data payload of Safe transaction
     * @param operation Operation type of Safe transaction
     * @param safeTxGas Gas that should be used for the Safe transaction
     * @param baseGas Gas costs for data used to trigger the safe transaction
     * @param gasPrice Maximum gas price that should be used for this transaction
     * @param gasToken Token address (or 0 if ETH) that is used for the payment
     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin)
     * @param _nonce Transaction nonce
     * @return Transaction hash bytes
     */
    function encodeTransactionData(
        address to,
        uint256 value,
        bytes calldata data,
        Operation operation,
        uint256 safeTxGas,
        uint256 baseGas,
        uint256 gasPrice,
        address gasToken,
        address refundReceiver,
        uint256 _nonce
    ) external view returns (bytes memory);

    /**
     * @dev Returns the chain id used by this contract
     * @return Chain ID
     */
    function getChainId() external view returns (uint256);

    /**
     * @dev Returns the domain separator for EIP-712 signing
     * @return Domain separator
     */
    function domainSeparator() external view returns (bytes32);

    /**
     * @dev Returns the current transaction nonce
     * @return Nonce value
     */
    function nonce() external view returns (uint256);

    /**
     * @dev Returns the Safe version string
     * @return Version string
     */
    function VERSION() external view returns (string memory);

    /**
     * @dev Checks if a hash is approved
     * @param owner Owner address
     * @param hash Hash to check
     * @return Approval status
     */
    function approvedHashes(address owner, bytes32 hash) external view returns (uint256);

    /**
     * @dev Adds an owner to the Safe
     * @param owner New owner address
     * @param _threshold New threshold
     */
    function addOwnerWithThreshold(address owner, uint256 _threshold) external;

    /**
     * @dev Removes an owner from the Safe
     * @param prevOwner Owner that points to the owner to be removed in the linked list
     * @param owner Owner address to be removed
     * @param _threshold New threshold
     */
    function removeOwner(address prevOwner, address owner, uint256 _threshold) external;

    /**
     * @dev Replaces an owner with a new owner
     * @param prevOwner Owner that points to the owner to be replaced in the linked list
     * @param oldOwner Owner address to be replaced
     * @param newOwner New owner address
     */
    function swapOwner(address prevOwner, address oldOwner, address newOwner) external;

    /**
     * @dev Changes the threshold of the Safe
     * @param _threshold New threshold
     */
    function changeThreshold(uint256 _threshold) external;

    /**
     * @dev Returns array of owners
     * @return Array of Safe owners
     */
    function getOwners() external view returns (address[] memory);

    /**
     * @dev Returns number of required confirmations
     * @return Safe threshold
     */
    function getThreshold() external view returns (uint256);

    /**
     * @dev Checks if an address is an owner
     * @param owner Address to check
     * @return Owner status
     */
    function isOwner(address owner) external view returns (bool);
} 


================================================
FILE: contracts/IGnosisSafeL2.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IGnosisSafe.sol";

/**
 * @title IGnosisSafeL2
 * @dev Interface for the Gnosis Safe L2 multisignature wallet on Katana
 * @notice This contract extends IGnosisSafe with L2-specific optimizations and events
 * @custom:bokuto 0xfb1bffC9d739B8D520DaF37dF666da4C687191EA
 */
interface IGnosisSafeL2 is IGnosisSafe {
    /**
     * @dev Emitted when a multisig transaction is executed through the Safe
     * @notice Contains more details than the standard SafeSuccess event for L2 indexing
     */
    event SafeMultiSigTransaction(
        address to,
        uint256 value,
        bytes data,
        Operation operation,
        uint256 safeTxGas,
        uint256 baseGas,
        uint256 gasPrice,
        address gasToken,
        address payable refundReceiver,
        bytes signatures,
        // Combined data containing nonce, sender and threshold
        bytes additionalInfo
    );

    /**
     * @dev Emitted when a transaction is executed by a module
     */
    event SafeModuleTransaction(
        address module, 
        address to, 
        uint256 value, 
        bytes data, 
        Operation operation
    );

    /**
     * @dev Allows to execute a Safe transaction confirmed by required number of owners
     * @notice This overrides the execTransaction method in GnosisSafe with L2 optimizations
     * @param to Destination address of Safe transaction
     * @param value Ether value of Safe transaction
     * @param data Data payload of Safe transaction
     * @param operation Operation type of Safe transaction
     * @param safeTxGas Gas that should be used for the Safe transaction
     * @param baseGas Gas costs that are independent of the transaction execution
     * @param gasPrice Gas price that should be used for the payment calculation
     * @param gasToken Token address (or 0 if ETH) that is used for the payment
     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin)
     * @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})
     * @return success Returns boolean indicating whether the transaction executed successfully
     */
    function execTransaction(
        address to,
        uint256 value,
        bytes calldata data,
        Operation operation,
        uint256 safeTxGas,
        uint256 baseGas,
        uint256 gasPrice,
        address gasToken,
        address payable refundReceiver,
        bytes memory signatures
    ) external payable override returns (bool success);

    /**
     * @dev Allows a Module to execute a Safe transaction without any further confirmations
     * @notice This overrides the execTransactionFromModule method in GnosisSafe with L2 optimizations
     * @param to Destination address of module transaction
     * @param value Ether value of module transaction
     * @param data Data payload of module transaction
     * @param operation Operation type of module transaction
     * @return success Returns boolean indicating whether the transaction executed successfully
     */
    function execTransactionFromModule(
        address to,
        uint256 value,
        bytes memory data,
        Operation operation
    ) external returns (bool success);

    /**
     * @dev Allows a Module to execute a Safe transaction without any further confirmations and with a specific nonce
     * @param to Destination address of module transaction
     * @param value Ether value of module transaction
     * @param data Data payload of module transaction
     * @param operation Operation type of module transaction
     * @param nonce Transaction nonce
     * @return success Returns boolean indicating whether the transaction executed successfully
     */
    function execTransactionFromModule(
        address to,
        uint256 value,
        bytes calldata data,
        Operation operation,
        uint256 nonce
    ) external override returns (bool success);
} 


================================================
FILE: contracts/ILxLyBridge.sol
================================================
// SPDX-License-Identifier: MIT OR Apache-2.0
pragma solidity ^0.8.28;

/**
 * @title ILxLyBridge
 * @notice Interface for Polygon LxLy Bridge contract
 * @dev Provides cross-chain bridging functionality
 * @custom:tags bridge,polygon,crosschain
 */
interface ILxLyBridge {
    function networkID() external view returns (uint32);
    function bridgeAsset(
        uint32 destinationNetwork,
        address destinationAddress,
        uint256 amount,
        address token,
        bool forceUpdateGlobalExitRoot,
        bytes calldata permitData
    ) external payable;
    function claimAsset(
        bytes32[32] calldata smtProofLocalExitRoot,
        bytes32[32] calldata smtProofRollupExitRoot,
        uint256 globalIndex,
        bytes32 mainnetExitRoot,
        bytes32 rollupExitRoot,
        uint32 originNetwork,
        address originTokenAddress,
        uint32 destinationNetwork,
        address destinationAddress,
        uint256 amount,
        bytes calldata metadata
    ) external;
    function claimMessage(
        bytes32[32] calldata smtProofLocalExitRoot,
        bytes32[32] calldata smtProofRollupExitRoot,
        uint256 globalIndex,
        bytes32 mainnetExitRoot,
        bytes32 rollupExitRoot,
        uint32 originNetwork,
        address originAddress,
        uint32 destinationNetwork,
        address destinationAddress,
        uint256 amount,
        bytes calldata metadata
    ) external;
    function bridgeMessage(
        uint32 destinationNetwork,
        address destinationAddress,
        bool forceUpdateGlobalExitRoot,
        bytes calldata metadata
    ) external payable;
    function wrappedAddressIsNotMintable(address wrappedAddress) external view returns (bool isNotMintable);
}



================================================
FILE: contracts/IMulticall3.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IMulticall3
 * @dev Interface for Multicall3 contract on Katana
 * @notice Allows batching multiple read-only calls into a single transaction
 * @custom:bokuto 0xcA11bde05977b3631167028862bE2a173976CA11
 * @custom:tags utility,multicall,batch
 */
interface IMulticall3 {
    struct Call {
        address target;
        bytes callData;
    }

    struct Call3 {
        address target;
        bool allowFailure;
        bytes callData;
    }

    struct Call3Value {
        address target;
        bool allowFailure;
        uint256 value;
        bytes callData;
    }

    struct Result {
        bool success;
        bytes returnData;
    }

    /**
     * @notice Aggregates results from multiple contract calls (Multicall1 compatible)
     * @param calls An array of Call structs
     * @return blockNumber The block number where the calls were executed
     * @return returnData An array of bytes containing the responses
     */
    function aggregate(Call[] calldata calls) external payable returns (uint256 blockNumber, bytes[] memory returnData);

    /**
     * @notice Aggregates calls without requiring all to succeed (Multicall2 compatible)
     * @param requireSuccess If true, require all calls to succeed
     * @param calls An array of Call structs
     * @return returnData An array of Result structs
     */
    function tryAggregate(bool requireSuccess, Call[] calldata calls) external payable returns (Result[] memory returnData);

    /**
     * @notice Aggregates calls with block info (Multicall2 compatible)
     * @param requireSuccess If true, require all calls to succeed
     * @param calls An array of Call structs
     * @return blockNumber The block number where the calls were executed
     * @return blockHash The hash of the block where the calls were executed
     * @return returnData An array of Result structs
     */
    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls) external payable returns (
        uint256 blockNumber,
        bytes32 blockHash,
        Result[] memory returnData
    );

    /**
     * @notice Aggregates calls with block info, requiring all to succeed (Multicall2 compatible)
     * @param calls An array of Call structs
     * @return blockNumber The block number where the calls were executed
     * @return blockHash The hash of the block where the calls were executed
     * @return returnData An array of Result structs
     */
    function blockAndAggregate(Call[] calldata calls) external payable returns (
        uint256 blockNumber,
        bytes32 blockHash,
        Result[] memory returnData
    );

    /**
     * @notice Aggregates calls with per-call failure flags (Multicall3 specific)
     * @param calls An array of Call3 structs
     * @return returnData An array of Result structs
     */
    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);

    /**
     * @notice Aggregates calls with ETH value and per-call failure flags (Multicall3 specific)
     * @param calls An array of Call3Value structs
     * @return returnData An array of Result structs
     */
    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);

    /**
     * @notice Returns the block hash for a given block number
     * @param blockNumber The block number
     * @return blockHash The block hash
     */
    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);

    /**
     * @notice Returns the current block number
     * @return blockNumber The block number
     */
    function getBlockNumber() external view returns (uint256 blockNumber);

    /**
     * @notice Returns the current block's coinbase address
     * @return coinbase The coinbase address
     */
    function getCurrentBlockCoinbase() external view returns (address coinbase);

    /**
     * @notice Returns the current block's difficulty
     * @return difficulty The block difficulty
     */
    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);

    /**
     * @notice Returns the current block's gas limit
     * @return gaslimit The gas limit
     */
    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);

    /**
     * @notice Returns the current block's timestamp
     * @return timestamp The timestamp
     */
    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);

    /**
     * @notice Returns the ETH balance of a given address
     * @param addr The address to check
     * @return balance The ETH balance
     */
    function getEthBalance(address addr) external view returns (uint256 balance);

    /**
     * @notice Returns the hash of the previous block
     * @return blockHash The block hash
     */
    function getLastBlockHash() external view returns (bytes32 blockHash);

    /**
     * @notice Returns the current block's base fee (EIP-1559)
     * @return basefee The base fee
     */
    function getBasefee() external view returns (uint256 basefee);

    /**
     * @notice Returns the current chain ID
     * @return chainid The chain ID
     */
    function getChainId() external view returns (uint256 chainid);
} 


================================================
FILE: contracts/IMultiSend.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IMultiSend
 * @dev Interface for the MultiSend contract on Katana
 * @notice This contract allows batching multiple transactions into a single transaction
 * @custom:bokuto 0x998739BFdAAdde7C933B942a68053933098f9EDa
 */
interface IMultiSend {
    /**
     * @dev Sends multiple transactions and reverts all if one fails
     * @param transactions Encoded batch of transactions
     * @notice The format for the transactions bytes is:
     * (operation, to, value, data.length, data)+
     * where:
     *   - operation: 0 = call, 1 = delegatecall
     *   - to: target address
     *   - value: ether value
     *   - data.length: length of the data
     *   - data: call data
     */
    function multiSend(bytes memory transactions) external payable;
} 


================================================
FILE: contracts/IMultiSendCallOnly.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IMultiSendCallOnly
 * @dev Interface for the MultiSendCallOnly contract on Katana
 * @notice This contract allows batching multiple transactions into a single transaction, but only allows CALL operations (no delegatecall)
 * @custom:bokuto 0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B
 */
interface IMultiSendCallOnly {
    /**
     * @dev Sends multiple transactions and reverts all if one fails
     * @param transactions Encoded batch of transactions
     * @notice The format for the transactions bytes is:
     * (operation, to, value, data.length, data)+
     * where:
     *   - operation: must be 0 (call only, 1 for delegatecall will revert)
     *   - to: target address
     *   - value: ether value
     *   - data.length: length of the data
     *   - data: call data
     * @notice Unlike MultiSend, this function only allows normal calls (no delegatecall), making it safer for use with user wallets
     */
    function multiSend(bytes memory transactions) external payable;
} 


================================================
FILE: contracts/IPermit2.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IPermit2
 * @notice Comprehensive interface for Uniswap's Permit2 system, combining allowance transfers and signature-based transfers
 * @dev Unifies functionality from multiple Permit2 interfaces for token approvals and transfers
 * @custom:bokuto 0x000000000022D473030F116dDEE9F6B43aC78BA3
 * @custom:tags utility,permit,erc20,signature,uniswap
 */
interface IPermit2 {
    /// -----------------------------------------------------------------------
    /// CONSTANTS
    /// -----------------------------------------------------------------------
    
    /**
     * @dev EIP-712 types for AllowanceTransfer
     * @dev See https://eips.ethereum.org/EIPS/eip-712
     */
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    
    /// @dev The EIP-712 typeHash for the permit data struct
    /// @dev keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
    function PERMIT_TYPEHASH() external view returns (bytes32);
    
    /// @dev The EIP-712 typeHash for the permit with allowance data struct
    /// @dev keccak256("PermitWithAllowance(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline,uint48 expiration)");
    function PERMIT_WITH_ALLOWANCE_TYPEHASH() external view returns (bytes32);
    
    /// @dev The EIP-712 typeHash for the permit batch data struct
    /// @dev keccak256("PermitBatch(address owner,PermitDetails[] details,uint256 nonce,uint256 deadline)")
    function PERMIT_BATCH_TYPEHASH() external view returns (bytes32);
    
    /// @dev The EIP-712 typeHash for the permit details data struct
    /// @dev keccak256("PermitDetails(address token,uint160 amount,uint48 expiration,uint48 nonce)")
    function PERMIT_DETAILS_TYPEHASH() external view returns (bytes32);
    
    /// @dev The EIP-712 typeHash for the permit batch with allowance data struct
    /// @dev keccak256("PermitBatchWithAllowance(address owner,PermitDetailsWithAllowance[] details,uint256 nonce,uint256 deadline)")
    function PERMIT_BATCH_WITH_ALLOWANCE_TYPEHASH() external view returns (bytes32);
    
    /// @dev The EIP-712 typeHash for the permit details with allowance data struct
    /// @dev keccak256("PermitDetailsWithAllowance(address token,uint160 amount,uint48 expiration,uint48 nonce,address allowanceTarget,uint48 allowanceExpiration)")
    function PERMIT_DETAILS_WITH_ALLOWANCE_TYPEHASH() external view returns (bytes32);
    
    /// @dev The EIP-712 typeHash for the transfer details struct
    /// @dev keccak256("TransferDetails(address to,uint256 amount)");
    function TRANSFER_DETAILS_TYPEHASH() external view returns (bytes32);
    
    /// @dev The EIP-712 typeHash for the token permissions data struct
    /// @dev keccak256("TokenPermissions(address token,uint256 amount)");
    function TOKEN_PERMISSIONS_TYPEHASH() external view returns (bytes32);
    
    /// @dev The EIP-712 typeHash for the permit transfer data struct
    /// @dev keccak256("PermitTransferFrom(TokenPermissions permitted,address spender,uint256 nonce,uint256 deadline)");
    function PERMIT_TRANSFER_FROM_TYPEHASH() external view returns (bytes32);
    
    /// @dev The EIP-712 typeHash for the permit transfer batch data struct
    /// @dev keccak256("PermitBatchTransferFrom(TokenPermissions[] permitted,address spender,uint256 nonce,uint256 deadline)");
    function PERMIT_BATCH_TRANSFER_FROM_TYPEHASH() external view returns (bytes32);
    
    /// @dev The EIP-712 typeHash for the permit witness transfer data struct
    /// @dev keccak256("PermitWitnessTransferFrom(TokenPermissions permitted,address spender,uint256 nonce,uint256 deadline,bytes32 witness)");
    function PERMIT_WITNESS_TRANSFER_FROM_TYPEHASH() external view returns (bytes32);
    
    /// @dev The EIP-712 typeHash for the permit witness transfer batch data struct
    /// @dev keccak256("PermitBatchWitnessTransferFrom(TokenPermissions[] permitted,address spender,uint256 nonce,uint256 deadline,bytes32 witness)");
    function PERMIT_BATCH_WITNESS_TRANSFER_FROM_TYPEHASH() external view returns (bytes32);

    /// -----------------------------------------------------------------------
    /// STRUCTS
    /// -----------------------------------------------------------------------
    
    /**
     * @notice Details for the permit allowance
     * @param token The token address
     * @param amount The maximum amount allowed to spend
     * @param expiration Expiration timestamp for the permit
     * @param nonce A unique value for each permit
     */
    struct PermitDetails {
        address token;
        uint160 amount;
        uint48 expiration;
        uint48 nonce;
    }
    
    /**
     * @notice Extended details for the permit allowance with allowance target
     * @param token The token address
     * @param amount The maximum amount allowed to spend
     * @param expiration Expiration timestamp for the permit
     * @param nonce A unique value for each permit
     * @param allowanceTarget The target address for the allowance
     * @param allowanceExpiration Expiration timestamp for the allowance
     */
    struct PermitDetailsWithAllowance {
        address token;
        uint160 amount;
        uint48 expiration;
        uint48 nonce;
        address allowanceTarget;
        uint48 allowanceExpiration;
    }
    
    /**
     * @notice Transfer details for token transfers
     * @param to The recipient address
     * @param amount The amount to transfer
     */
    struct TransferDetails {
        address to;
        uint256 amount;
    }
    
    /**
     * @notice Allowance transfer details
     * @param from The source address
     * @param to The recipient address
     * @param amount The amount to transfer
     * @param token The token address
     */
    struct AllowanceTransferDetails {
        address from;
        address to;
        uint160 amount;
        address token;
    }
    
    /**
     * @notice Token permissions for signature-based transfers
     * @param token The token address
     * @param amount The amount allowed to transfer
     */
    struct TokenPermissions {
        address token;
        uint256 amount;
    }
    
    /**
     * @notice Single signed transfer parameters
     * @param permitted Token permissions for the transfer
     * @param nonce A unique value for each permit
     * @param deadline Expiration timestamp for the signature
     */
    struct PermitTransferFrom {
        TokenPermissions permitted;
        address spender;
        uint256 nonce;
        uint256 deadline;
    }
    
    /**
     * @notice Signed transfer parameters with a witness
     * @param permitted Token permissions for the transfer
     * @param nonce A unique value for each permit
     * @param deadline Expiration timestamp for the signature
     * @param witness Additional data to be verified
     */
    struct PermitWitnessTransferFrom {
        TokenPermissions permitted;
        address spender;
        uint256 nonce;
        uint256 deadline;
        bytes32 witness;
    }
    
    /**
     * @notice Batch signed transfer parameters
     * @param permitted Array of token permissions for multiple transfers
     * @param nonce A unique value for each permit
     * @param deadline Expiration timestamp for the signature
     */
    struct PermitBatchTransferFrom {
        TokenPermissions[] permitted;
        address spender;
        uint256 nonce;
        uint256 deadline;
    }
    
    /**
     * @notice Batch signed transfer parameters with a witness
     * @param permitted Array of token permissions for multiple transfers
     * @param nonce A unique value for each permit
     * @param deadline Expiration timestamp for the signature
     * @param witness Additional data to be verified
     */
    struct PermitBatchWitnessTransferFrom {
        TokenPermissions[] permitted;
        address spender;
        uint256 nonce;
        uint256 deadline;
        bytes32 witness;
    }
    
    /**
     * @notice Packed allowance for a token
     * @param amount The approved amount
     * @param expiration The expiration timestamp
     * @param nonce The current nonce for the allowance
     */
    struct PackedAllowance {
        uint160 amount;
        uint48 expiration;
        uint48 nonce;
    }

    /// -----------------------------------------------------------------------
    /// EVENTS
    /// -----------------------------------------------------------------------
    
    /**
     * @notice Emitted when an allowance is approved
     * @param owner The owner of the tokens
     * @param token The token address
     * @param spender The address allowed to spend the tokens
     * @param amount The maximum amount allowed to spend
     * @param expiration The expiration timestamp for the permit
     * @param nonce The nonce for the permit
     */
    event Approval(
        address indexed owner, 
        address indexed token, 
        address indexed spender, 
        uint160 amount, 
        uint48 expiration, 
        uint48 nonce
    );
    
    /**
     * @notice Emitted when an allowance is revoked
     * @param owner The owner of the tokens
     * @param token The token address
     * @param spender The address that was allowed to spend the tokens
     * @param nonce The nonce for the revoked permit
     */
    event Lockdown(
        address indexed owner, 
        address indexed token, 
        address indexed spender, 
        uint48 nonce
    );
    
    /**
     * @notice Emitted when a token is transferred using the allowance
     * @param owner The owner of the tokens
     * @param token The token address
     * @param spender The address that spent the tokens
     * @param amount The amount that was spent
     */
    event Transfer(
        address indexed owner, 
        address indexed token, 
        address indexed spender, 
        uint160 amount, 
        uint48 expiration, 
        uint48 nonce
    );
    
    /**
     * @notice Emitted when a transfer has been performed via signature
     * @param token The token address
     * @param from The source address
     * @param to The recipient address
     * @param amount The amount transferred
     * @param nonce The nonce used for the signature
     */
    event SignatureTransfer(
        address indexed token, 
        address indexed from, 
        address indexed to, 
        uint256 amount, 
        uint256 nonce
    );

    /// -----------------------------------------------------------------------
    /// ERRORS
    /// -----------------------------------------------------------------------
    
    /// @notice The signature is invalid
    error InvalidSignature();
    
    /// @notice The signature has expired
    error SignatureExpired();
    
    /// @notice The signature has already been used
    error InvalidNonce();
    
    /// @notice The permit has expired
    error PermitExpired();
    
    /// @notice The requested amount exceeds the allowance
    error InsufficientAllowance();
    
    /// @notice Signature data must include a witness
    error WitnessRequired();
    
    /// @notice Additional data must be provided when using witness mode
    error MissingWitness();
    
    /// @notice Multiple copies of the same token provided
    error TokenContractMismatch();
    
    /// @notice The amount must be less than 2^160
    error InvalidAmount();

    /// -----------------------------------------------------------------------
    /// ALLOWANCE TRANSFER FUNCTIONS
    /// -----------------------------------------------------------------------
    
    /**
     * @notice Approve a spender to use the owner's tokens via owner's signature
     * @param owner The owner of the tokens
     * @param spender The address being approved to spend the tokens
     * @param amount The maximum amount allowed to spend
     * @param deadline The deadline by which the signature must be used
     * @param signature The owner's signature authorizing the approval
     */
    function permit(
        address owner,
        address spender,
        uint160 amount,
        uint256 deadline,
        bytes calldata signature
    ) external;
    
    /**
     * @notice Approve a spender to use the owner's tokens via owner's signature with expiration
     * @param owner The owner of the tokens
     * @param spender The address being approved to spend the tokens
     * @param amount The maximum amount allowed to spend
     * @param expiration The expiration timestamp for the allowance
     * @param deadline The deadline by which the signature must be used
     * @param signature The owner's signature authorizing the approval
     */
    function permitWithAllowance(
        address owner,
        address spender,
        uint160 amount,
        uint48 expiration,
        uint256 deadline,
        bytes calldata signature
    ) external;
    
    /**
     * @notice Batch approve spenders to use the owner's tokens via owner's signature
     * @param owner The owner of the tokens
     * @param permitDetails Array of permit details including tokens, amounts, and expirations
     * @param deadline The deadline by which the signature must be used
     * @param signature The owner's signature authorizing the approvals
     */
    function permitBatch(
        address owner,
        PermitDetails[] calldata permitDetails,
        uint256 deadline,
        bytes calldata signature
    ) external;
    
    /**
     * @notice Batch approve spenders to use the owner's tokens via owner's signature with allowance targets
     * @param owner The owner of the tokens
     * @param permitDetails Array of permit details including tokens, amounts, expirations, and allowance targets
     * @param deadline The deadline by which the signature must be used
     * @param signature The owner's signature authorizing the approvals
     */
    function permitBatchWithAllowance(
        address owner,
        PermitDetailsWithAllowance[] calldata permitDetails,
        uint256 deadline,
        bytes calldata signature
    ) external;
    
    /**
     * @notice Approve a spender for all token allowances owned by the caller
     * @param token The token address
     * @param spender The address being approved to spend the tokens
     * @param amount The maximum amount allowed to spend
     * @param expiration The expiration timestamp for the allowance
     */
    function approve(
        address token,
        address spender,
        uint160 amount,
        uint48 expiration
    ) external;
    
    /**
     * @notice Approve multiple allowances in a single transaction
     * @param approvals Array of allowance details
     */
    function approveBatch(PermitDetails[] calldata approvals) external;
    
    /**
     * @notice Increase the current allowance for a spender
     * @param token The token address
     * @param spender The address being approved to spend the tokens
     * @param amount The amount to increase the allowance by
     * @param expiration The new expiration timestamp (0 to keep the current one)
     */
    function increaseAllowance(
        address token,
        address spender,
        uint160 amount,
        uint48 expiration
    ) external;
    
    /**
     * @notice Revokes the allowance for a spender on a given token
     * @param token The token address
     * @param spender The address to revoke approval from
     */
    function revoke(address token, address spender) external;
    
    /**
     * @notice Revoke multiple allowances in a single transaction
     * @param approvals Array of token and spender pairs to revoke
     */
    function revokeBatch(PermitDetails[] calldata approvals) external;
    
    /**
     * @notice Revoke all allowances from all spenders across all tokens
     */
    function lockdown(PermitDetails[] calldata approvals) external;
    
    /**
     * @notice Transfer tokens from the owner to a recipient
     * @param from The owner of the tokens
     * @param to The recipient address
     * @param amount The amount to transfer
     * @param token The token address
     */
    function transferFrom(
        address from,
        address to,
        uint160 amount,
        address token
    ) external;
    
    /**
     * @notice Transfer multiple tokens from owners to recipients
     * @param transferDetails Array of transfer details
     */
    function transferFromBatch(
        AllowanceTransferDetails[] calldata transferDetails
    ) external;
    
    /**
     * @notice Retrieve the current allowance for a token-spender pair
     * @param owner The owner of the tokens
     * @param token The token address
     * @param spender The spender address
     * @return amount The current approved amount
     * @return expiration The expiration timestamp for the allowance
     * @return nonce The current nonce for the allowance
     */
    function allowance(
        address owner,
        address token,
        address spender
    ) external view returns (uint160 amount, uint48 expiration, uint48 nonce);

    /// -----------------------------------------------------------------------
    /// SIGNATURE TRANSFER FUNCTIONS
    /// -----------------------------------------------------------------------
    
    /**
     * @notice Transfer tokens with a signed permission
     * @param permit The signed permit data
     * @param transferDetails The transfer details
     * @param owner The owner of the tokens
     * @param signature The owner's signature authorizing the transfer
     */
    function permitTransferFrom(
        PermitTransferFrom calldata permit,
        TransferDetails calldata transferDetails,
        address owner,
        bytes calldata signature
    ) external;
    
    /**
     * @notice Transfer tokens with a signed permission that includes a witness value
     * @param permit The signed permit data with witness
     * @param transferDetails The transfer details
     * @param owner The owner of the tokens
     * @param signature The owner's signature authorizing the transfer
     * @param witnessData Additional data that resolves to the witness hash
     */
    function permitWitnessTransferFrom(
        PermitWitnessTransferFrom calldata permit,
        TransferDetails calldata transferDetails,
        address owner,
        bytes calldata signature,
        bytes calldata witnessData
    ) external;
    
    /**
     * @notice Transfer multiple tokens with a signed permission
     * @param permit The signed batch permit data
     * @param transferDetails Array of transfer details
     * @param owner The owner of the tokens
     * @param signature The owner's signature authorizing the transfers
     */
    function permitBatchTransferFrom(
        PermitBatchTransferFrom calldata permit,
        TransferDetails[] calldata transferDetails,
        address owner,
        bytes calldata signature
    ) external;
    
    /**
     * @notice Transfer multiple tokens with a signed permission that includes a witness value
     * @param permit The signed batch permit data with witness
     * @param transferDetails Array of transfer details
     * @param owner The owner of the tokens
     * @param signature The owner's signature authorizing the transfers
     * @param witnessData Additional data that resolves to the witness hash
     */
    function permitBatchWitnessTransferFrom(
        PermitBatchWitnessTransferFrom calldata permit,
        TransferDetails[] calldata transferDetails,
        address owner,
        bytes calldata signature,
        bytes calldata witnessData
    ) external;
    
    /**
     * @notice Check if the nonce has been used for an owner
     * @param owner The owner address
     * @param nonce The nonce to check
     * @return True if the nonce has been used, false otherwise
     */
    function nonceBitmap(address owner, uint256 nonce) external view returns (uint256);
    
    /**
     * @notice Invalidate an ordered nonce for the caller
     * @param token The token address
     * @param spender The spender address
     * @param newNonce The new nonce to use
     */
    function invalidateNonces(address token, address spender, uint48 newNonce) external;
} 


================================================
FILE: contracts/IRIP7212.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IRIP7212 - Precompile for secp256r1 (P-256) Curve Support
 * @notice Interface for the RIP-7212 precompile that enables efficient verification of P-256 signatures
 * @dev Located at address 0x0000000000000000000000000000000000000100 on chains that support RIP-7212
 * @custom:bokuto 0x0000000000000000000000000000000000000100
 * @custom:tags utility,cryptography,precompile,signature-verification
 */
interface IRIP7212 {
    /**
     * @notice Verifies a secp256r1 (P-256) signature
     * @dev This precompile significantly reduces gas costs for P-256 signature verification (only ~3450 gas)
     * @param hash The 32-byte message hash that was signed
     * @param r The r component of the ECDSA signature (32 bytes)
     * @param s The s component of the ECDSA signature (32 bytes)
     * @param x The x-coordinate of the public key (32 bytes)
     * @param y The y-coordinate of the public key (32 bytes)
     * @return valid True if the signature is valid, false otherwise
     */
    function verify(
        bytes32 hash,
        bytes32 r,
        bytes32 s,
        bytes32 x,
        bytes32 y
    ) external view returns (bool valid);
    
    /**
     * @notice Batch verifies multiple secp256r1 (P-256) signatures
     * @dev Efficiently verifies multiple signatures in a single call
     * @param hashes Array of 32-byte message hashes
     * @param rs Array of r components of the ECDSA signatures
     * @param ss Array of s components of the ECDSA signatures
     * @param xs Array of x-coordinates of the public keys
     * @param ys Array of y-coordinates of the public keys
     * @return valid True if all signatures are valid, false otherwise
     */
    function batchVerify(
        bytes32[] calldata hashes,
        bytes32[] calldata rs,
        bytes32[] calldata ss,
        bytes32[] calldata xs,
        bytes32[] calldata ys
    ) external view returns (bool valid);
} 


================================================
FILE: contracts/ISafeExecutor.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./ISushiRouter.sol";

/**
 * @title ISafeExecutor
 * @notice Interface for the SafeExecutor contract used by SushiRouter
 * @dev This contract executes swap operations without having token approvals,
 *      making it safer for interacting with other contracts
 */
interface ISafeExecutor {
    /**
     * @notice Execute a call to the specified executor address
     * @dev Forwards the call to the executor and bubbles up any revert
     * @param executor The address of the executor contract
     * @param executorData The calldata to send to the executor
     */
    function execute(
        address executor,
        bytes calldata executorData
    ) external payable;

    /**
     * @notice Execute multiple calls in sequence
     * @dev Forwards calls to multiple executors and bubbles up any revert
     * @param executors Array of executor details (address, value, and calldata)
     */
    function executeMultiple(
        ISushiRouter.Executor[] calldata executors
    ) external payable;
} 


================================================
FILE: contracts/ISushiRouter.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IERC20.sol";

/**
 * @title ISushiRouter
 * @notice Interface for SushiSwap's router contract
 * @dev Provides functions for swapping tokens through SushiSwap's liquidity pools
 * @custom:bokuto 0xAC4c6e212A361c968F1725b4d055b47E63F80b75
 * @dev The address 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE is used to represent the native token (ETH)
 * @custom:tags sushi,defi,amm,router,swap
 */
interface ISushiRouter {
    /**
     * @notice Error thrown when output amount is less than the minimum required
     * @param tokenOut The address of the output token
     * @param amountOut The actual output amount
     */
    error MinimalOutputBalanceViolation(address tokenOut, uint256 amountOut);

    /**
     * @notice Input token structure for multi-swap operations
     * @param token The input token
     * @param amountIn The amount to transfer (0 means use all available balance minus 1)
     * @param transferTo The address to transfer tokens to
     */
    struct InputToken {
        IERC20 token;
        uint256 amountIn;
        address transferTo;
    }

    /**
     * @notice Output token structure for multi-swap operations
     * @param token The output token
     * @param recipient The recipient of the output tokens
     * @param amountOutMin The minimum amount of output tokens required
     */
    struct OutputToken {
        IERC20 token;
        address recipient;
        uint256 amountOutMin;
    }

    /**
     * @notice Executor structure for swap operations
     * @param executor The address of the executor contract
     * @param value The amount of ETH to send
     * @param data The calldata to send to the executor
     */
    struct Executor {
        address executor;
        uint256 value;
        bytes data;
    }

    /**
     * @notice Swaps one token for another using SushiSwap
     * @dev If tokenIn is the native token (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE), use amountIn of 0 and include the value in msg.value
     * @param tokenIn The input token
     * @param amountIn The amount of input tokens to swap (0 means use all available balance minus 1)
     * @param recipient The recipient of the output tokens
     * @param tokenOut The output token
     * @param amountOutMin The minimum amount of output tokens required
     * @param executor The address of the executor contract
     * @param executorData The calldata to send to the executor
     * @return amountOut The amount of output tokens received
     */
    function snwap(
        IERC20 tokenIn,
        uint256 amountIn,
        address recipient,
        IERC20 tokenOut,
        uint256 amountOutMin,
        address executor,
        bytes calldata executorData
    ) external payable returns (uint256 amountOut);

    /**
     * @notice Swaps multiple tokens using SushiSwap in a batch
     * @dev Can execute multiple swaps in a single transaction
     * @param inputTokens Array of input tokens with their amounts
     * @param outputTokens Array of output tokens with their minimum amounts
     * @param executors Array of executors to handle the swaps
     * @return amountOut Array of output amounts received
     */
    function snwapMultiple(
        InputToken[] calldata inputTokens,
        OutputToken[] calldata outputTokens,
        Executor[] calldata executors
    ) external payable returns (uint256[] memory amountOut);
} 


================================================
FILE: contracts/MultiCall1.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.12;

/// @title Multicall - Aggregate results from multiple read-only function calls
/// @author Michael Elliot <mike@makerdao.com>
/// @author Joshua Levine <joshua@makerdao.com>
/// @author Nick Johnson <arachnid@notdot.net>
/// @custom:katana 0x1F4c1E0afBeb5b5B86d7722549274434b29884F6
/// @custom:bokuto 0x1a593e35B50A6BD65f23aa022C910FF0Cef58ACd
/// @custom:tags utility,multicall,batch

contract Multicall {
    struct Call {
        address target;
        bytes callData;
    }

    function aggregate(Call[] calldata calls) public returns (uint256 blockNumber, bytes[] memory returnData) {
        blockNumber = block.number;
        returnData = new bytes[](calls.length);
        for (uint256 i = 0; i < calls.length; i++) {
            (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);
            require(success);
            returnData[i] = ret;
        }
    }

    // Helper functions
    function getEthBalance(address addr) public view returns (uint256 balance) {
        balance = addr.balance;
    }

    function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {
        blockHash = blockhash(blockNumber);
    }

    function getLastBlockHash() public view returns (bytes32 blockHash) {
        blockHash = blockhash(block.number - 1);
    }

    function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {
        timestamp = block.timestamp;
    }

    function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {
        difficulty = block.difficulty;
    }

    function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {
        gaslimit = block.gaslimit;
    }

    function getCurrentBlockCoinbase() public view returns (address coinbase) {
        coinbase = block.coinbase;
    }
}



================================================
FILE: contracts/MultiCall2.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.12;

/// @title Multicall2 - Aggregate results from multiple read-only function calls
/// @author Michael Elliot <mike@makerdao.com>
/// @author Joshua Levine <joshua@makerdao.com>
/// @author Nick Johnson <arachnid@notdot.net>
/// @custom:katana 0xe9128E672bc08E12deb1C2048E9f91e6D6E08e74
/// @custom:bokuto 0xafc9dD4B1416f61c86A5540423D29abdFf665dbB
/// @custom:tags utility,multicall,batch
contract Multicall2 {
    struct Call {
        address target;
        bytes callData;
    }

    struct Result {
        bool success;
        bytes returnData;
    }

    function aggregate(Call[] calldata calls) public returns (uint256 blockNumber, bytes[] memory returnData) {
        blockNumber = block.number;
        returnData = new bytes[](calls.length);
        for (uint256 i = 0; i < calls.length; i++) {
            (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);
            require(success, "Multicall aggregate: call failed");
            returnData[i] = ret;
        }
    }

    function tryAggregate(bool requireSuccess, Call[] calldata calls) public returns (Result[] memory returnData) {
        returnData = new Result[](calls.length);
        for (uint256 i = 0; i < calls.length; i++) {
            (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);

            if (requireSuccess) {
                require(success, "Multicall2 aggregate: call failed");
            }

            returnData[i] = Result(success, ret);
        }
    }

    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls) public returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {
        blockNumber = block.number;
        blockHash = blockhash(block.number);
        returnData = tryAggregate(requireSuccess, calls);
    }

    function blockAndAggregate(Call[] calldata calls) public returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {
        (blockNumber, blockHash, returnData) = tryBlockAndAggregate(true, calls);
    }

    function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {
        blockHash = blockhash(blockNumber);
    }

    function getBlockNumber() public view returns (uint256 blockNumber) {
        blockNumber = block.number;
    }

    function getCurrentBlockCoinbase() public view returns (address coinbase) {
        coinbase = block.coinbase;
    }

    function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {
        difficulty = block.difficulty;
    }

    function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {
        gaslimit = block.gaslimit;
    }

    function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {
        timestamp = block.timestamp;
    }

    function getEthBalance(address addr) public view returns (uint256 balance) {
        balance = addr.balance;
    }

    function getLastBlockHash() public view returns (bytes32 blockHash) {
        blockHash = blockhash(block.number - 1);
    }
}




================================================
FILE: contracts/AAv0.6.0/IEntryPoint.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IERC4337.sol";
import "./IERC4337Account.sol";

/**
 * @title IEntryPoint v0.6.0
 * @notice Account-Abstraction (EIP-4337) singleton EntryPoint
 * @dev Only one instance required on each chain
 * @custom:tags account-abstraction,erc4337,entrypoint,v0.6.0
 */
interface IEntryPoint is IStakeManager, INonceManager {
    /**
     * @notice UserOps grouped by aggregator
     */
    struct UserOpsPerAggregator {
        UserOperation[] userOps;
        // aggregator address
        IAggregator aggregator;
        // aggregated signature
        bytes signature;
    }

    /**
     * @dev Execute a batch of UserOperations
     * @param ops Operations to execute
     * @param beneficiary Address to receive fees
     */
    function handleOps(UserOperation[] calldata ops, address payable beneficiary) external;

    /**
     * @dev Execute a batch of UserOperation with Aggregators
     * @param opsPerAggregator Operations grouped by aggregator
     * @param beneficiary Address to receive fees
     */
    function handleAggregatedOps(
        UserOpsPerAggregator[] calldata opsPerAggregator,
        address payable beneficiary
    ) external;

    /**
     * @dev Generate a request ID for the operation
     * @param userOp The user operation
     * @return Request ID (hash)
     */
    function getUserOpHash(UserOperation calldata userOp) external view returns (bytes32);

    /**
     * @dev Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp
     * @param userOp The user operation to validate
     * @dev This method always reverts to return validation result
     */
    function simulateValidation(UserOperation calldata userOp) external;

    /**
     * @dev Get counterfactual sender address
     * @param initCode The constructor code
     * @dev This method always reverts with sender address
     */
    function getSenderAddress(bytes memory initCode) external;

    /**
     * @dev Simulate full execution of a UserOperation
     * @param op The user operation to simulate
     * @param target If non-zero, the call target after simulation
     * @param targetCallData Call data for the target
     * @dev This method always reverts with ExecutionResult
     */
    function simulateHandleOp(
        UserOperation calldata op,
        address target,
        bytes calldata targetCallData
    ) external;
}

/**
 * @title IAggregator Interface (v0.6.0)
 * @notice Aggregated Signatures validator
 */
interface IAggregator {
    /**
     * @dev Validate aggregated signature
     * @param userOps Array of operations to validate
     * @param signature Aggregated signature
     */
    function validateSignatures(
        UserOperation[] calldata userOps,
        bytes calldata signature
    ) external view;

    /**
     * @dev Validate signature of a single userOp
     * @param userOp The operation to validate
     * @return sigForUserOp Signature to include in the userOp
     */
    function validateUserOpSignature(
        UserOperation calldata userOp
    ) external view returns (bytes memory sigForUserOp);

    /**
     * @dev Aggregate multiple signatures
     * @param userOps Array of operations to aggregate
     * @return aggregatedSignature The aggregated signature
     */
    function aggregateSignatures(
        UserOperation[] calldata userOps
    ) external view returns (bytes memory aggregatedSignature);
}

/**
 * @title IPaymaster Interface (v0.6.0)
 * @notice Paymaster interface for paying gas for user operations
 */
interface IPaymaster {
    /**
     * @dev Paymaster operation modes
     */
    enum PostOpMode {
        opSucceeded, // User op succeeded
        opReverted, // User op reverted
        postOpReverted // Post-operation handling reverted
    }

    /**
     * @dev Validate paymaster for user operation
     * @param userOp The user operation
     * @param userOpHash Hash of the user operation
     * @param maxCost Maximum cost of the transaction
     * @return context Context for post-operation
     * @return validationData Validation data (see IAccount for format)
     */
    function validatePaymasterUserOp(
        UserOperation calldata userOp,
        bytes32 userOpHash,
        uint256 maxCost
    ) external returns (bytes memory context, uint256 validationData);

    /**
     * @dev Post-operation handler
     * @param mode Operation mode
     * @param context Context from validatePaymasterUserOp
     * @param actualGasCost Actual gas cost used so far
     */
    function postOp(
        PostOpMode mode,
        bytes calldata context,
        uint256 actualGasCost
    ) external;
} 


================================================
FILE: contracts/AAv0.6.0/IERC4337Account.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title ERC-4337 v0.6.0 Account Interface
 * @notice Interface for accounts that can be validated by the EntryPoint
 * @custom:tags account-abstraction,erc4337,account,v0.6.0
 */
interface IAccount {
    /**
     * @dev Validates a user operation signature and nonce
     * @notice The EntryPoint will call this method before executing the user operation
     * @param userOp The user operation to validate
     * @param userOpHash The hash of the user's request data
     * @param missingAccountFunds Missing funds that the account must provide to execute the op
     * @return validationData Packed validation data (first 20 bytes is validating contract, last 12 bytes is validUntil and validAfter)
     *    <20-byte> sigAuthorizer: 0 for valid signature, 1 for invalid signature, otherwise address of signature authorizer
     *    <6-byte> validUntil: last timestamp this operation is valid (0 for no expiry)
     *    <6-byte> validAfter: first timestamp this operation is valid
     */
    function validateUserOp(
        UserOperation calldata userOp,
        bytes32 userOpHash,
        uint256 missingAccountFunds
    ) external returns (uint256 validationData);
}

/**
 * @dev User Operation struct matching v0.6.0 EntryPoint
 * @notice Structured data for an operation sent to the EntryPoint
 */
struct UserOperation {
    address sender;
    uint256 nonce;
    bytes initCode;
    bytes callData;
    uint256 callGasLimit;
    uint256 verificationGasLimit;
    uint256 preVerificationGas;
    uint256 maxFeePerGas;
    uint256 maxPriorityFeePerGas;
    bytes paymasterAndData;
    bytes signature;
} 


================================================
FILE: contracts/AAv0.6.0/ISenderCreator.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title ISenderCreator Interface (v0.6.0)
 * @notice Helper contract for creating sender accounts
 * @dev Used by the EntryPoint to deploy new accounts using the "initCode"
 * @custom:tags account-abstraction,erc4337,creator,v0.6.0
 */
interface ISenderCreator {
    /**
     * @dev Create a sender account using provided initialization code
     * @param initCode Initialization code for the new account
     * @return sender The address of the created account
     */
    function createSender(bytes calldata initCode) external returns (address sender);
} 


================================================
FILE: contracts/AAv0.7.0/IEntryPoint.sol
================================================
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

/**
 * @title IEntryPoint v0.7.0
 * @notice Account-Abstraction (EIP-4337) singleton EntryPoint
 * @dev Only one instance required on each chain
 * @custom:tags account-abstraction,erc4337,entrypoint,v0.7.0
 */
interface MyInterface {
    error DelegateAndRevert(bool success, bytes ret);
    error FailedOp(uint256 opIndex, string reason);
    error FailedOpWithRevert(uint256 opIndex, string reason, bytes inner);
    error PostOpReverted(bytes returnData);
    error ReentrancyGuardReentrantCall();
    error SenderAddressResult(address sender);
    error SignatureValidationFailed(address aggregator);
    event AccountDeployed(
        bytes32 indexed userOpHash,
        address indexed sender,
        address factory,
        address paymaster
    );
    event BeforeExecution();
    event Deposited(address indexed account, uint256 totalDeposit);
    event PostOpRevertReason(
        bytes32 indexed userOpHash,
        address indexed sender,
        uint256 nonce,
        bytes revertReason
    );
    event SignatureAggregatorChanged(address indexed aggregator);
    event StakeLocked(
        address indexed account,
        uint256 totalStaked,
        uint256 unstakeDelaySec
    );
    event StakeUnlocked(address indexed account, uint256 withdrawTime);
    event StakeWithdrawn(
        address indexed account,
        address withdrawAddress,
        uint256 amount
    );
    event UserOperationEvent(
        bytes32 indexed userOpHash,
        address indexed sender,
        address indexed paymaster,
        uint256 nonce,
        bool success,
        uint256 actualGasCost,
        uint256 actualGasUsed
    );
    event UserOperationPrefundTooLow(
        bytes32 indexed userOpHash,
        address indexed sender,
        uint256 nonce
    );
    event UserOperationRevertReason(
        bytes32 indexed userOpHash,
        address indexed sender,
        uint256 nonce,
        bytes revertReason
    );
    event Withdrawn(
        address indexed account,
        address withdrawAddress,
        uint256 amount
    );

    function addStake(uint32 unstakeDelaySec) external payable;

    function balanceOf(address account) external view returns (uint256);

    function delegateAndRevert(address target, bytes memory data) external;

    function depositTo(address account) external payable;

    function deposits(address)
        external
        view
        returns (
            uint256 deposit,
            bool staked,
            uint112 stake,
            uint32 unstakeDelaySec,
            uint48 withdrawTime
        );

    function getDepositInfo(address account)
        external
        view
        returns (IStakeManager.DepositInfo memory info);

    function getNonce(address sender, uint192 key)
        external
        view
        returns (uint256 nonce);

    function getSenderAddress(bytes memory initCode) external;

    function getUserOpHash(PackedUserOperation memory userOp)
        external
        view
        returns (bytes32);

    function handleAggregatedOps(
        IEntryPoint.UserOpsPerAggregator[] memory opsPerAggregator,
        address beneficiary
    ) external;

    function handleOps(PackedUserOperation[] memory ops, address beneficiary)
        external;

    function incrementNonce(uint192 key) external;

    function innerHandleOp(
        bytes memory callData,
        EntryPoint.UserOpInfo memory opInfo,
        bytes memory context
    ) external returns (uint256 actualGasCost);

    function nonceSequenceNumber(address, uint192)
        external
        view
        returns (uint256);

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

    function unlockStake() external;

    function withdrawStake(address withdrawAddress) external;

    function withdrawTo(address withdrawAddress, uint256 withdrawAmount)
        external;

    receive() external payable;
}

interface IStakeManager {
    struct DepositInfo {
        uint256 deposit;
        bool staked;
        uint112 stake;
        uint32 unstakeDelaySec;
        uint48 withdrawTime;
    }
}

interface IEntryPoint {
    struct UserOpsPerAggregator {
        PackedUserOperation[] userOps;
        address aggregator;
        bytes signature;
    }
}

interface EntryPoint {
    struct MemoryUserOp {
        address sender;
        uint256 nonce;
        uint256 verificationGasLimit;
        uint256 callGasLimit;
        uint256 paymasterVerificationGasLimit;
        uint256 paymasterPostOpGasLimit;
        uint256 preVerificationGas;
        address paymaster;
        uint256 maxFeePerGas;
        uint256 maxPriorityFeePerGas;
    }

    struct UserOpInfo {
        MemoryUserOp mUserOp;
        bytes32 userOpHash;
        uint256 prefund;
        uint256 contextOffset;
        uint256 preOpGas;
    }
}

struct PackedUserOperation {
    address sender;
    uint256 nonce;
    bytes initCode;
    bytes callData;
    bytes32 accountGasLimits;
    uint256 preVerificationGas;
    bytes32 gasFees;
    bytes paymasterAndData;
    bytes signature;
}

// THIS FILE WAS AUTOGENERATED FROM THE FOLLOWING ABI JSON:
/*
[{"inputs":[{"internalType":"bool","name":"success","type":"bool"},{"internalType":"bytes","name":"ret","type":"bytes"}],"name":"DelegateAndRevert","type":"error"},{"inputs":[{"internalType":"uint256","name":"opIndex","type":"uint256"},{"internalType":"string","name":"reason","type":"string"}],"name":"FailedOp","type":"error"},{"inputs":[{"internalType":"uint256","name":"opIndex","type":"uint256"},{"internalType":"string","name":"reason","type":"string"},{"internalType":"bytes","name":"inner","type":"bytes"}],"name":"FailedOpWithRevert","type":"error"},{"inputs":[{"internalType":"bytes","name":"returnData","type":"bytes"}],"name":"PostOpReverted","type":"error"},{"inputs":[],"name":"ReentrancyGuardReentrantCall","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"}],"name":"SenderAddressResult","type":"error"},{"inputs":[{"internalType":"address","name":"aggregator","type":"address"}],"name":"SignatureValidationFailed","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"userOpHash","type":"bytes32"},{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"address","name":"factory","type":"address"},{"indexed":false,"internalType":"address","name":"paymaster","type":"address"}],"name":"AccountDeployed","type":"event"},{"anonymous":false,"inputs":[],"name":"BeforeExecution","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":false,"internalType":"uint256","name":"totalDeposit","type":"uint256"}],"name":"Deposited","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"userOpHash","type":"bytes32"},{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"uint256","name":"nonce","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"revertReason","type":"bytes"}],"name":"PostOpRevertReason","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"aggregator","type":"address"}],"name":"SignatureAggregatorChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":false,"internalType":"uint256","name":"totalStaked","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"unstakeDelaySec","type":"uint256"}],"name":"StakeLocked","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":false,"internalType":"uint256","name":"withdrawTime","type":"uint256"}],"name":"StakeUnlocked","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":false,"internalType":"address","name":"withdrawAddress","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"StakeWithdrawn","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"userOpHash","type":"bytes32"},{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":true,"internalType":"address","name":"paymaster","type":"address"},{"indexed":false,"internalType":"uint256","name":"nonce","type":"uint256"},{"indexed":false,"internalType":"bool","name":"success","type":"bool"},{"indexed":false,"internalType":"uint256","name":"actualGasCost","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"actualGasUsed","type":"uint256"}],"name":"UserOperationEvent","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"userOpHash","type":"bytes32"},{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"uint256","name":"nonce","type":"uint256"}],"name":"UserOperationPrefundTooLow","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"userOpHash","type":"bytes32"},{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"uint256","name":"nonce","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"revertReason","type":"bytes"}],"name":"UserOperationRevertReason","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":false,"internalType":"address","name":"withdrawAddress","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Withdrawn","type":"event"},{"inputs":[{"internalType":"uint32","name":"unstakeDelaySec","type":"uint32"}],"name":"addStake","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"target","type":"address"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"delegateAndRevert","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"depositTo","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"deposits","outputs":[{"internalType":"uint256","name":"deposit","type":"uint256"},{"internalType":"bool","name":"staked","type":"bool"},{"internalType":"uint112","name":"stake","type":"uint112"},{"internalType":"uint32","name":"unstakeDelaySec","type":"uint32"},{"internalType":"uint48","name":"withdrawTime","type":"uint48"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"getDepositInfo","outputs":[{"components":[{"internalType":"uint256","name":"deposit","type":"uint256"},{"internalType":"bool","name":"staked","type":"bool"},{"internalType":"uint112","name":"stake","type":"uint112"},{"internalType":"uint32","name":"unstakeDelaySec","type":"uint32"},{"internalType":"uint48","name":"withdrawTime","type":"uint48"}],"internalType":"struct IStakeManager.DepositInfo","name":"info","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint192","name":"key","type":"uint192"}],"name":"getNonce","outputs":[{"internalType":"uint256","name":"nonce","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"initCode","type":"bytes"}],"name":"getSenderAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"bytes","name":"initCode","type":"bytes"},{"internalType":"bytes","name":"callData","type":"bytes"},{"internalType":"bytes32","name":"accountGasLimits","type":"bytes32"},{"internalType":"uint256","name":"preVerificationGas","type":"uint256"},{"internalType":"bytes32","name":"gasFees","type":"bytes32"},{"internalType":"bytes","name":"paymasterAndData","type":"bytes"},{"internalType":"bytes","name":"signature","type":"bytes"}],"internalType":"struct PackedUserOperation","name":"userOp","type":"tuple"}],"name":"getUserOpHash","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"components":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"bytes","name":"initCode","type":"bytes"},{"internalType":"bytes","name":"callData","type":"bytes"},{"internalType":"bytes32","name":"accountGasLimits","type":"bytes32"},{"internalType":"uint256","name":"preVerificationGas","type":"uint256"},{"internalType":"bytes32","name":"gasFees","type":"bytes32"},{"internalType":"bytes","name":"paymasterAndData","type":"bytes"},{"internalType":"bytes","name":"signature","type":"bytes"}],"internalType":"struct PackedUserOperation[]","name":"userOps","type":"tuple[]"},{"internalType":"contract IAggregator","name":"aggregator","type":"address"},{"internalType":"bytes","name":"signature","type":"bytes"}],"internalType":"struct IEntryPoint.UserOpsPerAggregator[]","name":"opsPerAggregator","type":"tuple[]"},{"internalType":"address payable","name":"beneficiary","type":"address"}],"name":"handleAggregatedOps","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"bytes","name":"initCode","type":"bytes"},{"internalType":"bytes","name":"callData","type":"bytes"},{"internalType":"bytes32","name":"accountGasLimits","type":"bytes32"},{"internalType":"uint256","name":"preVerificationGas","type":"uint256"},{"internalType":"bytes32","name":"gasFees","type":"bytes32"},{"internalType":"bytes","name":"paymasterAndData","type":"bytes"},{"internalType":"bytes","name":"signature","type":"bytes"}],"internalType":"struct PackedUserOperation[]","name":"ops","type":"tuple[]"},{"internalType":"address payable","name":"beneficiary","type":"address"}],"name":"handleOps","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint192","name":"key","type":"uint192"}],"name":"incrementNonce","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"callData","type":"bytes"},{"components":[{"components":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"uint256","name":"verificationGasLimit","type":"uint256"},{"internalType":"uint256","name":"callGasLimit","type":"uint256"},{"internalType":"uint256","name":"paymasterVerificationGasLimit","type":"uint256"},{"internalType":"uint256","name":"paymasterPostOpGasLimit","type":"uint256"},{"internalType":"uint256","name":"preVerificationGas","type":"uint256"},{"internalType":"address","name":"paymaster","type":"address"},{"internalType":"uint256","name":"maxFeePerGas","type":"uint256"},{"internalType":"uint256","name":"maxPriorityFeePerGas","type":"uint256"}],"internalType":"struct EntryPoint.MemoryUserOp","name":"mUserOp","type":"tuple"},{"internalType":"bytes32","name":"userOpHash","type":"bytes32"},{"internalType":"uint256","name":"prefund","type":"uint256"},{"internalType":"uint256","name":"contextOffset","type":"uint256"},{"internalType":"uint256","name":"preOpGas","type":"uint256"}],"internalType":"struct EntryPoint.UserOpInfo","name":"opInfo","type":"tuple"},{"internalType":"bytes","name":"context","type":"bytes"}],"name":"innerHandleOp","outputs":[{"internalType":"uint256","name":"actualGasCost","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"uint192","name":"","type":"uint192"}],"name":"nonceSequenceNumber","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"unlockStake","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address payable","name":"withdrawAddress","type":"address"}],"name":"withdrawStake","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address payable","name":"withdrawAddress","type":"address"},{"internalType":"uint256","name":"withdrawAmount","type":"uint256"}],"name":"withdrawTo","outputs":[],"stateMutability":"nonpayable","type":"function"},{"stateMutability":"payable","type":"receive"}]
*/


================================================
FILE: contracts/AAv0.7.0/IEntryPointSimulations.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEntryPoint.sol";

/**
 * @title IEntryPointSimulations Interface (v0.7.0)
 * @notice Extended simulation interface for EntryPoint
 * @custom:tags account-abstraction,erc4337,simulation,v0.7.0
 */
interface IEntryPointSimulations is IEntryPoint {
    /**
     * @dev Result of an execution simulation
     */
    struct ExecutionResult {
        uint256 preOpGas;
        uint256 paid;
        uint256 accountValidationData;
        uint256 paymasterValidationData;
        bool targetSuccess;
        bytes targetResult;
    }

    /**
     * @dev Simulate validation with detailed result
     * @param userOp The user operation to validate
     * @return preOpGas The gas used before operation execution
     * @return prefund The amount prefunded for the operation
     * @return actualAggregator The aggregator used for signature validation
     * @return paymasterContext The context returned by the paymaster
     */
    function simulateValidation(
        PackedUserOperation calldata userOp
    ) external returns (
        uint256 preOpGas,
        uint256 prefund,
        address actualAggregator,
        bytes memory paymasterContext
    );

    /**
     * @dev Simulate handle operation with detailed result
     * @param op The user operation to simulate
     * @param target The target for post-op call
     * @param targetCallData The call data for the target
     * @return executionResult The execution result structure
     */
    function simulateHandleOp(
        PackedUserOperation calldata op,
        address target,
        bytes calldata targetCallData
    ) external returns (ExecutionResult memory executionResult);
} 


================================================
FILE: contracts/AAv0.7.0/IERC4337Account.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title ERC-4337 v0.7.0 Account Interface
 * @notice Interface for accounts that can be validated by the EntryPoint
 * @custom:tags account-abstraction,erc4337,account,v0.7.0
 */
interface IAccount {
    /**
     * @dev Validates a user operation signature and nonce
     * @notice The EntryPoint will call this method before executing the user operation
     * @param userOp The user operation to validate
     * @param userOpHash The hash of the user's request data
     * @param missingAccountFunds Missing funds that the account must provide to execute the op
     * @return validationData Packed validation data (first 20 bytes is validating contract, last 12 bytes is validUntil and validAfter)
     *    <20-byte> sigAuthorizer: 0 for valid signature, 1 for invalid signature, otherwise address of signature authorizer
     *    <6-byte> validUntil: last timestamp this operation is valid (0 for no expiry)
     *    <6-byte> validAfter: first timestamp this operation is valid
     */
    function validateUserOp(
        PackedUserOperation calldata userOp,
        bytes32 userOpHash,
        uint256 missingAccountFunds
    ) external returns (uint256 validationData);
}

/**
 * @dev Packed User Operation struct matching v0.7.0 EntryPoint
 * @notice More gas-efficient version of the UserOperation struct
 */
struct PackedUserOperation {
    address sender;
    uint256 nonce;
    bytes initCode;
    bytes callData;
    bytes32 accountGasLimits;
    uint256 preVerificationGas;
    bytes32 gasFees;
    bytes paymasterAndData;
    bytes signature;
} 


================================================
FILE: contracts/AAv0.7.0/ISenderCreator.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title ISenderCreator Interface (v0.7.0)
 * @notice Helper contract for creating sender accounts
 * @dev Used by the EntryPoint to deploy new accounts using the "initCode"
 * @custom:tags account-abstraction,erc4337,creator,v0.7.0
 */
interface ISenderCreator {
    /**
     * @dev Create a sender account using provided initialization code
     * @param initCode Initialization code for the new account
     * @return sender The address of the created account
     */
    function createSender(bytes calldata initCode) external returns (address sender);
} 


================================================
FILE: contracts/agglayer/IBridgeExtension.sol
================================================
// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity ^0.8.20;

/**
 * @title IBridgeExtension
 * @notice Interface for the Bridge Extension contract
 * @custom:katana 0x64B20Eb25AEd030FD510EF93B9135278B152f6a6
 * @custom:tags agglayer,bridge,polygon,extension
 */
interface IBridgeExtension {
    error AddressEmptyCode(address target);
    error AddressInsufficientBalance(address account);
    error AlreadyClaimed();
    error AmountDoesNotMatchMsgValue();
    error BridgeAddressNotAllowed();
    error ClaimNotSet();
    error DestinationNetworkInvalid();
    error EmergencyStateNotAllowed();
    error EtherTransferFailed();
    error FailedInnerCall();
    error FailedProxyDeployment();
    error GasTokenNetworkMustBeZeroOnEther();
    error GlobalExitRootInvalid();
    error InputArraysLengthMismatch();
    error InvalidGlobalIndex();
    error InvalidInitializeFunction();
    error InvalidProxyAdmin(address proxyAdmin);
    error InvalidSmtProof();
    error InvalidSovereignWETHAddressParams();
    error InvalidZeroAddress();
    error InvalidZeroNetworkID();
    error InvalidZeroProxyAdminOwner(address proxyAdmin);
    error LocalBalanceTreeOverflow(
        uint32 originNetwork,
        address originTokenAddress,
        uint256 amount,
        uint256 localBalanceTreeAmount
    );
    error LocalBalanceTreeUnderflow(
        uint32 originNetwork,
        address originTokenAddress,
        uint256 amount,
        uint256 localBalanceTreeAmount
    );
    error MerkleTreeFull();
    error MessageFailed();
    error MsgValueNotZero();
    error NativeTokenIsEther();
    error NoValueInMessagesOnGasTokenNetworks();
    error NotValidAmount();
    error NotValidOwner();
    error NotValidSignature();
    error NotValidSpender();
    error OnlyBridgeManager();
    error OnlyEmergencyBridgePauser();
    error OnlyEmergencyBridgeUnpauser();
    error OnlyEmergencyState();
    error OnlyGlobalExitRootRemover();
    error OnlyNotEmergencyState();
    error OnlyPendingEmergencyBridgePauser();
    error OnlyPendingEmergencyBridgeUnpauser();
    error OnlyPendingProxiedTokensManager();
    error OnlyProxiedTokensManager();
    error OnlyRollupManager();
    error OriginNetworkInvalid();
    error SafeERC20FailedOperation(address token);
    error TokenAlreadyMapped();
    error TokenAlreadyUpdated();
    error TokenNotMapped();
    error TokenNotRemapped();
    error WETHRemappingNotSupportedOnGasTokenNetworks();
    event AcceptEmergencyBridgePauserRole(
        address oldEmergencyBridgePauser,
        address newEmergencyBridgePauser
    );
    event AcceptEmergencyBridgeUnpauserRole(
        address oldEmergencyBridgeUnpauser,
        address newEmergencyBridgeUnpauser
    );
    event AcceptProxiedTokensManagerRole(
        address oldProxiedTokensManager,
        address newProxiedTokensManager
    );
    event BridgeEvent(
        uint8 leafType,
        uint32 originNetwork,
        address originAddress,
        uint32 destinationNetwork,
        address destinationAddress,
        uint256 amount,
        bytes metadata,
        uint32 depositCount
    );
    event ClaimEvent(
        uint256 globalIndex,
        uint32 originNetwork,
        address originAddress,
        address destinationAddress,
        uint256 amount
    );
    event EmergencyStateActivated();
    event EmergencyStateDeactivated();
    event Initialized(uint8 version);
    event MigrateLegacyToken(
        address sender,
        address legacyTokenAddress,
        address updatedTokenAddress,
        uint256 amount
    );
    event NewWrappedToken(
        uint32 originNetwork,
        address originTokenAddress,
        address wrappedTokenAddress,
        bytes metadata
    );
    event RemoveLegacySovereignTokenAddress(address sovereignTokenAddress);
    event SetBridgeManager(address bridgeManager);
    event SetSovereignTokenAddress(
        uint32 originNetwork,
        address originTokenAddress,
        address sovereignTokenAddress,
        bool isNotMintable
    );
    event SetSovereignWETHAddress(
        address sovereignWETHTokenAddress,
        bool isNotMintable
    );
    event TransferEmergencyBridgePauserRole(
        address currentEmergencyBridgePauser,
        address newEmergencyBridgePauser
    );
    event TransferEmergencyBridgeUnpauserRole(
        address currentEmergencyBridgeUnpauser,
        address newEmergencyBridgeUnpauser
    );
    event TransferProxiedTokensManagerRole(
        address currentProxiedTokensManager,
        address newProxiedTokensManager
    );
    event UpdatedClaimedGlobalIndexHashChain(
        bytes32 claimedGlobalIndex,
        bytes32 newClaimedGlobalIndexHashChain
    );
    event UpdatedUnsetGlobalIndexHashChain(
        bytes32 unsetGlobalIndex,
        bytes32 newUnsetGlobalIndexHashChain
    );

    function BRIDGE_SOVEREIGN_VERSION() external view returns (string memory);

    function BRIDGE_VERSION() external view returns (string memory);

    function INIT_BYTECODE_TRANSPARENT_PROXY()
        external
        view
        returns (bytes memory);

    function WETHToken() external view returns (address);

    function acceptEmergencyBridgePauserRole() external;

    function acceptEmergencyBridgeUnpauserRole() external;

    function acceptProxiedTokensManagerRole() external;

    function activateEmergencyState() external;

    function bridgeAsset(
        uint32 destinationNetwork,
        address destinationAddress,
        uint256 amount,
        address token,
        bool forceUpdateGlobalExitRoot,
        bytes memory permitData
    ) external payable;

    function bridgeManager() external view returns (address);

    function bridgeMessage(
        uint32 destinationNetwork,
        address destinationAddress,
        bool forceUpdateGlobalExitRoot,
        bytes memory metadata
    ) external payable;

    function bridgeMessageWETH(
        uint32 destinationNetwork,
        address destinationAddress,
        uint256 amountWETH,
        bool forceUpdateGlobalExitRoot,
        bytes memory metadata
    ) external;

    function calculateRoot(
        bytes32 leafHash,
        bytes32[32] memory smtProof,
        uint32 index
    ) external pure returns (bytes32);

    function claimAsset(
        bytes32[32] memory smtProofLocalExitRoot,
        bytes32[32] memory smtProofRollupExitRoot,
        uint256 globalIndex,
        bytes32 mainnetExitRoot,
        bytes32 rollupExitRoot,
        uint32 originNetwork,
        address originTokenAddress,
        uint32 destinationNetwork,
        address destinationAddress,
        uint256 amount,
        bytes memory metadata
    ) external;

    function claimMessage(
        bytes32[32] memory smtProofLocalExitRoot,
        bytes32[32] memory smtProofRollupExitRoot,
        uint256 globalIndex,
        bytes32 mainnetExitRoot,
        bytes32 rollupExitRoot,
        uint32 originNetwork,
        address originAddress,
        uint32 destinationNetwork,
        address destinationAddress,
        uint256 amount,
        bytes memory metadata
    ) external;

    function claimedBitMap(uint256) external view returns (uint256);

    function claimedGlobalIndexHashChain() external view returns (bytes32);

    function computeTokenProxyAddress(
        uint32 originNetwork,
        address originTokenAddress
    ) external view returns (address);

    function deactivateEmergencyState() external;

    function deployWrappedTokenAndRemap(
        uint32 originNetwork,
        address originTokenAddress,
        bool isNotMintable
    ) external;

    function depositCount() external view returns (uint256);

    function emergencyBridgePauser() external view returns (address);

    function emergencyBridgeUnpauser() external view returns (address);

    function gasTokenAddress() external view returns (address);

    function gasTokenMetadata() external view returns (bytes memory);

    function gasTokenNetwork() external view returns (uint32);

    function getLeafValue(
        uint8 leafType,
        uint32 originNetwork,
        address originAddress,
        uint32 destinationNetwork,
        address destinationAddress,
        uint256 amount,
        bytes32 metadataHash
    ) external pure returns (bytes32);

    function getProxiedTokensManager() external view returns (address);

    function getRoot() external view returns (bytes32);

    function getTokenMetadata(address token)
        external
        view
        returns (bytes memory);

    function getTokenWrappedAddress(
        uint32 originNetwork,
        address originTokenAddress
    ) external view returns (address);

    function getWrappedTokenBridgeImplementation()
        external
        view
        returns (address);

    function globalExitRootManager() external view returns (address);

    function initialize(
        uint32 _networkID,
        address _gasTokenAddress,
        uint32 _gasTokenNetwork,
        address _globalExitRootManager,
        address _polygonRollupManager,
        bytes memory _gasTokenMetadata,
        address _bridgeManager,
        address _sovereignWETHAddress,
        bool _sovereignWETHAddressIsNotMintable,
        address _emergencyBridgePauser,
        address _emergencyBridgeUnpauser,
        address _proxiedTokensManager
    ) external;

    function initialize() external pure;

    function initialize(
        uint32,
        address,
        uint32,
        address,
        address,
        bytes memory
    ) external;

    function isClaimed(uint32 leafIndex, uint32 sourceBridgeNetwork)
        external
        view
        returns (bool);

    function isEmergencyState() external view returns (bool);

    function lastUpdatedDepositCount() external view returns (uint32);

    function localBalanceTree(bytes32 tokenInfoHash)
        external
        view
        returns (uint256 amount);

    function migrateLegacyToken(
        address legacyTokenAddress,
        uint256 amount,
        bytes memory permitData
    ) external;

    function networkID() external view returns (uint32);

    function pendingEmergencyBridgePauser() external view returns (address);

    function pendingEmergencyBridgeUnpauser() external view returns (address);

    function pendingProxiedTokensManager() external view returns (address);

    function polygonRollupManager() external view returns (address);

    function proxiedTokensManager() external view returns (address);

    function removeLegacySovereignTokenAddress(
        address legacySovereignTokenAddress
    ) external;

    function setBridgeManager(address _bridgeManager) external;

    function setMultipleSovereignTokenAddress(
        uint32[] memory originNetworks,
        address[] memory originTokenAddresses,
        address[] memory sovereignTokenAddresses,
        bool[] memory isNotMintable
    ) external;

    function setSovereignWETHAddress(
        address sovereignWETHTokenAddress,
        bool isNotMintable
    ) external;

    function tokenInfoToWrappedToken(bytes32) external view returns (address);

    function transferEmergencyBridgePauserRole(address newEmergencyBridgePauser)
        external;

    function transferEmergencyBridgeUnpauserRole(
        address newEmergencyBridgeUnpauser
    ) external;

    function transferProxiedTokensManagerRole(address newProxiedTokensManager)
        external;

    function unsetGlobalIndexHashChain() external view returns (bytes32);

    function unsetMultipleClaims(uint256[] memory globalIndexes) external;

    function updateGlobalExitRoot() external;

    function verifyMerkleProof(
        bytes32 leafHash,
        bytes32[32] memory smtProof,
        uint32 index,
        bytes32 root
    ) external pure returns (bool);

    function wrappedAddressIsNotMintable(address wrappedAddress)
        external
        view
        returns (bool isNotMintable);

    function wrappedTokenBytecodeStorer() external view returns (address);

    function wrappedTokenToTokenInfo(address)
        external
        view
        returns (uint32 originNetwork, address originTokenAddress);
}



================================================
FILE: contracts/agglayer/IBridgeL2SovereignChain.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IBridgeL2SovereignChain
 * @notice Interface for the BridgeL2SovereignChain contract which handles cross-chain message passing
 * @custom:tags agglayer,bridge,polygon,crosschain,sovereign
 */
interface IBridgeL2SovereignChain {
    /**
     * @notice Data structure for a bridge message
     * @param originAddress Address that triggered the message on the origin network
     * @param originNetwork Network identifier where the message originated
     * @param destinationAddress Address to receive the message on the destination network
     * @param destinationNetwork Network identifier where the message will be delivered
     * @param amount Amount of tokens to be transferred
     * @param metadata Additional data to be used by the destination contract
     */
    struct BridgeMessage {
        address originAddress;
        uint32 originNetwork;
        address destinationAddress;
        uint32 destinationNetwork;
        uint256 amount;
        bytes metadata;
    }

    /**
     * @notice Event emitted when a bridge operation is initiated
     * @param originNetwork Origin network identifier
     * @param originAddress Origin sender address
     * @param destinationNetwork Destination network identifier
     * @param destinationAddress Destination receiver address
     * @param amount Token amount
     * @param metadata Additional data included in the message
     * @param depositCount Unique identifier for the message
     */
    event BridgeEvent(
        uint32 indexed originNetwork,
        address indexed originAddress,
        uint32 indexed destinationNetwork,
        address destinationAddress,
        uint256 amount,
        bytes metadata,
        uint32 depositCount
    );

    /**
     * @notice Event emitted when a bridge operation is claimed
     * @param originNetwork Origin network identifier
     * @param originAddress Origin sender address
     * @param destinationNetwork Destination network identifier
     * @param destinationAddress Destination receiver address
     * @param amount Token amount
     * @param metadata Additional data included in the message
     * @param depositCount Unique identifier for the message
     */
    event ClaimEvent(
        uint32 indexed originNetwork,
        address indexed originAddress,
        uint32 indexed destinationNetwork,
        address destinationAddress,
        uint256 amount,
        bytes metadata,
        uint32 depositCount
    );

    /**
     * @notice Initializes the bridge with required parameters
     * @param _networkID Current network identifier
     * @param _globalExitRootManager Address of the GlobalExitRootManager contract
     * @param _polygonZkEVMaddress Address of the Polygon ZkEVM contract
     */
    function initialize(
        uint32 _networkID,
        address _globalExitRootManager,
        address _polygonZkEVMaddress
    ) external;

    /**
     * @notice Bridges assets to a destination network
     * @param destinationNetwork Network identifier where funds will be claimed
     * @param destinationAddress Address that will receive the funds
     * @param amount Amount of tokens to bridge
     * @param token Token address to bridge (0x0 for native assets)
     * @param permitData Data for ERC20 permit if token approval is needed
     * @param metadata Additional data to be used by the destination contract
     * @return depositCount Unique identifier for the bridge operation
     */
    function bridgeAsset(
        uint32 destinationNetwork,
        address destinationAddress,
        uint256 amount,
        address token,
        bytes calldata permitData,
        bytes calldata metadata
    ) external payable returns (uint32);

    /**
     * @notice Bridges a message to a destination network
     * @param destinationNetwork Network identifier where the message will be delivered
     * @param destinationAddress Address that will receive the message
     * @param metadata Message data to be bridged
     * @return depositCount Unique identifier for the bridge operation
     */
    function bridgeMessage(
        uint32 destinationNetwork,
        address destinationAddress,
        bytes calldata metadata
    ) external payable returns (uint32);

    /**
     * @notice Claims a bridge message on the destination chain
     * @param smtProof Merkle proof of the message inclusion
     * @param index Index of the message in the Merkle tree
     * @param mainnetExitRoot Exit root from the mainnet
     * @param rollupExitRoot Exit root from the rollup
     * @param originNetwork Origin network identifier
     * @param originAddress Origin sender address
     * @param destinationNetwork Destination network identifier
     * @param destinationAddress Destination receiver address
     * @param amount Token amount
     * @param metadata Additional data included in the message
     */
    function claimMessage(
        bytes32[] calldata smtProof,
        uint32 index,
        bytes32 mainnetExitRoot,
        bytes32 rollupExitRoot,
        uint32 originNetwork,
        address originAddress,
        uint32 destinationNetwork,
        address destinationAddress,
        uint256 amount,
        bytes calldata metadata
    ) external;

    /**
     * @notice Checks if a message has already been claimed
     * @param originNetwork Origin network identifier
     * @param originAddress Origin sender address
     * @param destinationNetwork Destination network identifier
     * @param destinationAddress Destination receiver address
     * @param amount Token amount
     * @param metadata Message data
     * @param depositCount Unique identifier for the message
     * @return True if the message has been claimed
     */
    function isClaimed(
        uint32 originNetwork,
        address originAddress,
        uint32 destinationNetwork,
        address destinationAddress,
        uint256 amount,
        bytes calldata metadata,
        uint32 depositCount
    ) external view returns (bool);

    /**
     * @notice Returns the current network identifier
     * @return The network ID
     */
    function networkID() external view returns (uint32);

    /**
     * @notice Returns the deposit count, which is used as an identifier for messages
     * @return The current deposit count
     */
    function depositCount() external view returns (uint32);

    /**
     * @notice Returns the address of the GlobalExitRootManager contract
     * @return The address of the GlobalExitRootManager
     */
    function globalExitRootManager() external view returns (address);

    /**
     * @notice Returns the address of the PolygonZkEVM contract
     * @return The address of the PolygonZkEVM
     */
    function polygonZkEVMaddress() external view returns (address);
} 


================================================
FILE: contracts/agglayer/IGlobalExitRootManagerL2SovereignChain.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IGlobalExitRootManagerL2SovereignChain
 * @notice Interface for the GlobalExitRootManagerL2SovereignChain contract which manages exit roots
 * @dev Proxy. Implementation address: 0x282a631D9F3Ef04Bf1A44B4C9e8bDC8EB278917f
 * @custom:tags agglayer,bridge,polygon,exit-root,sovereign
 */
interface IGlobalExitRootManagerL2SovereignChain {
    /**
     * @notice Emitted when a new global exit root is updated
     * @param mainnetExitRoot Mainnet exit root
     * @param rollupExitRoot Rollup exit root
     * @param globalExitRoot Global exit root (a combination of both roots)
     */
    event UpdateGlobalExitRoot(
        bytes32 indexed mainnetExitRoot,
        bytes32 indexed rollupExitRoot,
        bytes32 indexed globalExitRoot
    );

    /**
     * @notice Initializes the contract with required parameters
     * @param _bridgeAddress Address of the Bridge contract
     * @param _rollupAddress Address of the Rollup contract
     */
    function initialize(address _bridgeAddress, address _rollupAddress) external;

    /**
     * @notice Updates the exit roots from L1 (mainnet)
     * @param newRoot New root from L1
     */
    function updateExitRoot(bytes32 newRoot) external;

    /**
     * @notice Returns the last global exit root
     * @return The last global exit root
     */
    function getLastGlobalExitRoot() external view returns (bytes32);

    /**
     * @notice Returns a global exit root by index
     * @param index Index of the global exit root
     * @return The global exit root at the specified index
     */
    function globalExitRootMap(uint256 index) external view returns (bytes32);

    /**
     * @notice Returns true if the global exit root exists
     * @param globalExitRoot Global exit root to check
     * @return True if the global exit root exists
     */
    function isGlobalExitRoot(bytes32 globalExitRoot) external view returns (bool);

    /**
     * @notice Returns the current mainnet exit root
     * @return The current mainnet exit root
     */
    function mainnetExitRoot() external view returns (bytes32);

    /**
     * @notice Returns the current rollup exit root
     * @return The current rollup exit root
     */
    function rollupExitRoot() external view returns (bytes32);

    /**
     * @notice Returns the address of the bridge contract
     * @return The bridge contract address
     */
    function bridgeAddress() external view returns (address);

    /**
     * @notice Returns the address of the rollup contract
     * @return The rollup contract address
     */
    function rollupAddress() external view returns (address);

    /**
     * @notice Returns the last global exit root and its timestamp
     * @return The last global exit root
     * @return The timestamp when the last global exit root was updated
     */
    function getLastGlobalExitRootAndTimestamp() external view returns (bytes32, uint256);

    /**
     * @notice Returns the timestamp of a global exit root
     * @param globalExitRoot The global exit root to query
     * @return The timestamp of the global exit root, or 0 if it doesn't exist
     */
    function globalExitRootMapTimestamp(bytes32 globalExitRoot) external view returns (uint256);
} 


================================================
FILE: contracts/agglayer/IPolygonZkEVMDeployer.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IPolygonZkEVMDeployer
 * @notice Interface for the PolygonZkEVMDeployer contract which manages deployments of rollup components
 * @custom:tags agglayer,polygon,deployment,zkevm,rollup
 */
interface IPolygonZkEVMDeployer {
    /**
     * @notice Initializes a new PolygonZkEVM deployment
     * @param _admin Address that will be the admin of all the contracts
     * @param _chainID L2 chainID
     * @param _version Version of the PolygonZkEVM deployment
     * @param _gasTokenAddress Address of the token used to pay gas fees
     * @param _gasTokenNetwork Network where the token is deployed
     * @param _gasTokenMetadata Additional information about the token
     * @param _rollupVerifier RollupVerifier address
     */
    function initialize(
        address _admin,
        uint64 _chainID,
        string calldata _version,
        address _gasTokenAddress,
        uint32 _gasTokenNetwork,
        bytes calldata _gasTokenMetadata,
        address _rollupVerifier
    ) external;

    /**
     * @notice Checks if an account is the admin of the contract
     * @param account The address to check
     * @return True if the account is the admin
     */
    function isAdmin(address account) external view returns (bool);

    /**
     * @notice Returns the L2 chain ID of this deployment
     * @return The chain ID
     */
    function chainID() external view returns (uint64);

    /**
     * @notice Returns the version of this deployment
     * @return The version string
     */
    function version() external view returns (string memory);

    /**
     * @notice Returns the RollupVerifier address
     * @return The RollupVerifier address
     */
    function rollupVerifier() external view returns (address);

    /**
     * @notice Returns the gas token address
     * @return The address of the token used for gas
     */
    function gasTokenAddress() external view returns (address);

    /**
     * @notice Returns the gas token network
     * @return The network ID where the gas token is deployed
     */
    function gasTokenNetwork() external view returns (uint32);

    /**
     * @notice Returns the gas token metadata
     * @return The gas token metadata
     */
    function gasTokenMetadata() external view returns (bytes memory);
} 


================================================
FILE: contracts/agglayer/IPolygonZkEVMTimelock.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IPolygonZkEVMTimelock
 * @notice Interface for the PolygonZkEVMTimelock contract which manages governance actions with time delays
 * @custom:tags agglayer,polygon,governance,timelock,zkevm
 */
interface IPolygonZkEVMTimelock {
    /**
     * @notice Emitted when a new operation is scheduled
     * @param operationId Unique identifier of the operation
     * @param predecessor Optional dependency before execution
     * @param target Contract address for the operation
     * @param value ETH value to send
     * @param data Function call data
     * @param delay Execution delay in seconds
     */
    event OperationScheduled(
        bytes32 indexed operationId,
        bytes32 indexed predecessor,
        address target,
        uint256 value,
        bytes data,
        uint256 delay
    );

    /**
     * @notice Emitted when an operation becomes ready for execution
     * @param operationId Unique identifier of the operation
     * @param index Index of the operation in the ready queue
     */
    event OperationReady(bytes32 indexed operationId, uint256 indexed index);

    /**
     * @notice Emitted when an operation is executed
     * @param operationId Unique identifier of the operation
     * @param target Contract address for the operation
     * @param value ETH value sent
     * @param data Function call data
     * @param timestamp Execution timestamp
     */
    event OperationExecuted(
        bytes32 indexed operationId,
        address target,
        uint256 value,
        bytes data,
        uint256 timestamp
    );

    /**
     * @notice Emitted when an operation is cancelled
     * @param operationId Unique identifier of the operation
     */
    event OperationCancelled(bytes32 indexed operationId);

    /**
     * @notice Emitted when the minimum delay is changed
     * @param oldDelay Previous minimum delay
     * @param newDelay New minimum delay
     */
    event MinDelayChange(uint256 oldDelay, uint256 newDelay);

    /**
     * @notice Initialize the timelock with required parameters
     * @param minDelay Minimum delay for operations
     * @param admin Address of the admin
     * @param proposers Array of addresses that can propose operations
     * @param executors Array of addresses that can execute operations
     */
    function initialize(
        uint256 minDelay,
        address admin,
        address[] memory proposers,
        address[] memory executors
    ) external;

    /**
     * @notice Schedule an operation with a delay
     * @param target Contract address for the operation
     * @param value ETH value to send
     * @param data Function call data
     * @param predecessor Optional dependency before execution
     * @param salt Random value to allow having multiple operations with same parameters
     * @param delay Execution delay in seconds
     * @return operationId Unique identifier of the scheduled operation
     */
    function schedule(
        address target,
        uint256 value,
        bytes calldata data,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay
    ) external returns (bytes32 operationId);

    /**
     * @notice Schedule a batch of operations with a delay
     * @param targets Array of contract addresses for the operations
     * @param values Array of ETH values to send
     * @param datas Array of function call data
     * @param predecessor Optional dependency before execution
     * @param salt Random value to allow having multiple operations with same parameters
     * @param delay Execution delay in seconds
     * @return operationId Unique identifier of the scheduled batch operation
     */
    function scheduleBatch(
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata datas,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay
    ) external returns (bytes32 operationId);

    /**
     * @notice Cancel a scheduled operation
     * @param operationId Unique identifier of the operation
     */
    function cancel(bytes32 operationId) external;

    /**
     * @notice Execute a scheduled operation
     * @param target Contract address for the operation
     * @param value ETH value to send
     * @param data Function call data
     * @param predecessor Optional dependency before execution
     * @param salt Random value that was used when scheduling
     * @return result Return data from the execution
     */
    function execute(
        address target,
        uint256 value,
        bytes calldata data,
        bytes32 predecessor,
        bytes32 salt
    ) external payable returns (bytes memory result);

    /**
     * @notice Execute a scheduled batch operation
     * @param targets Array of contract addresses for the operations
     * @param values Array of ETH values to send
     * @param datas Array of function call data
     * @param predecessor Optional dependency before execution
     * @param salt Random value that was used when scheduling
     * @return results Array of return data from each execution
     */
    function executeBatch(
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata datas,
        bytes32 predecessor,
        bytes32 salt
    ) external payable returns (bytes[] memory results);

    /**
     * @notice Update the minimum delay for operations
     * @param newDelay New minimum delay in seconds
     */
    function updateDelay(uint256 newDelay) external;

    /**
     * @notice Returns an operation state
     * @param operationId Unique identifier of the operation
     * @return The current state of the operation (0=unknown, 1=pending, 2=ready, 3=done)
     */
    function getOperationState(bytes32 operationId) external view returns (uint8);

    /**
     * @notice Returns whether an operation is pending
     * @param operationId Unique identifier of the operation
     * @return True if the operation is pending
     */
    function isOperationPending(bytes32 operationId) external view returns (bool);

    /**
     * @notice Returns whether an operation is ready for execution
     * @param operationId Unique identifier of the operation
     * @return True if the operation is ready
     */
    function isOperationReady(bytes32 operationId) external view returns (bool);

    /**
     * @notice Returns whether an operation has been executed
     * @param operationId Unique identifier of the operation
     * @return True if the operation has been executed
     */
    function isOperationDone(bytes32 operationId) external view returns (bool);

    /**
     * @notice Returns the timestamp when an operation becomes ready for execution
     * @param operationId Unique identifier of the operation
     * @return The timestamp when the operation is ready (0 if none)
     */
    function getTimestamp(bytes32 operationId) external view returns (uint256);

    /**
     * @notice Returns the minimum delay for operations
     * @return The minimum delay in seconds
     */
    function getMinDelay() external view returns (uint256);

    /**
     * @notice Generates the operation ID for a single call operation
     * @param target Contract address for the operation
     * @param value ETH value to send
     * @param data Function call data
     * @param predecessor Optional dependency before execution
     * @param salt Random value to allow having multiple operations with same parameters
     * @return The operation ID
     */
    function hashOperation(
        address target,
        uint256 value,
        bytes calldata data,
        bytes32 predecessor,
        bytes32 salt
    ) external pure returns (bytes32);

    /**
     * @notice Generates the operation ID for a batch operation
     * @param targets Array of contract addresses for the operations
     * @param values Array of ETH values to send
     * @param datas Array of function call data
     * @param predecessor Optional dependency before execution
     * @param salt Random value to allow having multiple operations with same parameters
     * @return The operation ID
     */
    function hashOperationBatch(
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata datas,
        bytes32 predecessor,
        bytes32 salt
    ) external pure returns (bytes32);

    /**
     * @notice Returns whether an address has proposal permissions
     * @param account Address to check
     * @return True if the account can propose operations
     */
    function isProposer(address account) external view returns (bool);

    /**
     * @notice Returns whether an address has execution permissions
     * @param account Address to check
     * @return True if the account can execute operations
     */
    function isExecutor(address account) external view returns (bool);

    /**
     * @notice Grants proposal permissions to an account
     * @param account Address to grant permissions
     */
    function grantProposer(address account) external;

    /**
     * @notice Revokes proposal permissions from an account
     * @param account Address to revoke permissions
     */
    function revokeProposer(address account) external;

    /**
     * @notice Grants execution permissions to an account
     * @param account Address to grant permissions
     */
    function grantExecutor(address account) external;

    /**
     * @notice Revokes execution permissions from an account
     * @param account Address to revoke permissions
     */
    function revokeExecutor(address account) external;

    /**
     * @notice Renounces proposal permissions for the caller
     */
    function renounceProposer() external;

    /**
     * @notice Renounces execution permissions for the caller
     */
    function renounceExecutor() external;
} 


================================================
FILE: contracts/agglayer/IProxyAdmin.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IProxyAdmin
 * @notice Interface for the ProxyAdmin contract which manages transparent proxy contracts
 * @custom:tags agglayer,polygon,proxy,admin,governance
 */
interface IProxyAdmin {
    /**
     * @notice Returns the implementation address of a proxy
     * @param proxy Address of the TransparentUpgradeableProxy
     * @return The address of the implementation
     */
    function getProxyImplementation(address proxy) external view returns (address);

    /**
     * @notice Returns the admin address of a proxy
     * @param proxy Address of the TransparentUpgradeableProxy
     * @return The address of the admin
     */
    function getProxyAdmin(address proxy) external view returns (address);

    /**
     * @notice Changes the admin of a proxy
     * @param proxy Address of the TransparentUpgradeableProxy
     * @param newAdmin Address of the new admin
     */
    function changeProxyAdmin(address proxy, address newAdmin) external;

    /**
     * @notice Upgrades a proxy to a new implementation
     * @param proxy Address of the TransparentUpgradeableProxy
     * @param implementation Address of the new implementation
     */
    function upgrade(address proxy, address implementation) external;

    /**
     * @notice Upgrades a proxy to a new implementation and calls a function on the new implementation
     * @param proxy Address of the TransparentUpgradeableProxy
     * @param implementation Address of the new implementation
     * @param data Function call data to be executed on the implementation after upgrade
     */
    function upgradeAndCall(address proxy, address implementation, bytes memory data) external payable;

    /**
     * @notice Transfers ownership of the contract to a new account
     * @param newOwner Address of the new owner
     */
    function transferOwnership(address newOwner) external;

    /**
     * @notice Returns the address of the current owner
     * @return The address of the owner
     */
    function owner() external view returns (address);

    /**
     * @notice Returns the address of the pending owner
     * @return The address of the pending owner
     */
    function pendingOwner() external view returns (address);

    /**
     * @notice Leaves the contract without owner, making it impossible to call `onlyOwner` functions
     */
    function renounceOwnership() external;
} 


================================================
FILE: contracts/morpho/IMetaMorpho.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IMorphoBlue.sol";

/**
 * @title IMetaMorpho
 * @notice Interface for MetaMorpho vaults - ERC4626 yield aggregators for Morpho Blue markets
 * @author Morpho Labs
 * @custom:contact security@morpho.org
 * @custom:tags morpho,defi,vault,erc4626,metamorpho
 */
interface IMetaMorpho {
    /**
     * @notice Represents an allocation to a specific market with an amount of assets
     * @param marketParams The market parameters
     * @param assets The amount of assets to allocate
     */
    struct MarketAllocation {
        IMorphoBlue.MarketParams marketParams;
        uint256 assets;
    }

    /**
     * @notice The address of the Morpho Blue contract
     * @return The Morpho contract address
     */
    function MORPHO() external view returns (address);

    /**
     * @notice Returns the current configuration of a market
     * @param id The market identifier
     * @return cap The maximum amount of assets that can be allocated to this market
     * @return enabled Whether the market is enabled
     * @return removableAt The timestamp when the market can be removed (if pending removal)
     */
    function config(IMorphoBlue.Id id) external view returns (uint184 cap, bool enabled, uint64 removableAt);

    /**
     * @notice Returns the address of the curator responsible for market allocations
     * @return The curator address
     */
    function curator() external view returns (address);

    /**
     * @notice Checks if an address is an allocator that can rebalance funds
     * @param target The address to check
     * @return True if the address is an allocator
     */
    function isAllocator(address target) external view returns (bool);

    /**
     * @notice Returns the current fee charged on yield
     * @return The fee rate (scaled by 1e18)
     */
    function fee() external view returns (uint96);

    /**
     * @notice Returns the ordered list of markets to supply into when new deposits come in
     * @param index The index in the queue
     * @return The market ID at the given index
     */
    function supplyQueue(uint256 index) external view returns (IMorphoBlue.Id);

    /**
     * @notice Returns the ordered list of markets to withdraw from when users request withdrawals
     * @param index The index in the queue
     * @return The market ID at the given index
     */
    function withdrawQueue(uint256 index) external view returns (IMorphoBlue.Id);

    /**
     * @notice Updates the supply cap for a market
     * @param marketParams The market parameters
     * @param newSupplyCap The new maximum amount of assets that can be allocated to this market
     */
    function submitCap(IMorphoBlue.MarketParams memory marketParams, uint256 newSupplyCap) external;

    /**
     * @notice Sets the supply queue order for allocating deposits
     * @param newSupplyQueue The new ordered list of market IDs to supply into
     */
    function setSupplyQueue(IMorphoBlue.Id[] calldata newSupplyQueue) external;

    /**
     * @notice Updates the withdraw queue order
     * @param indexes The indexes of each market in the previous withdraw queue, in the new order
     */
    function updateWithdrawQueue(uint256[] calldata indexes) external;

    /**
     * @notice Reallocates the vault's liquidity across markets
     * @param allocations Array of market allocations with target asset amounts
     */
    function reallocate(MarketAllocation[] calldata allocations) external;
} 


================================================
FILE: contracts/morpho/IMetaMorphoFactory.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IMetaMorphoFactory
 * @notice Interface for MetaMorpho Factory, which creates MetaMorpho vaults for Morpho Blue
 * @author Morpho Labs
 * @custom:contact security@morpho.org
 * @custom:tags morpho,defi,factory,vault,metamorpho
 */
interface IMetaMorphoFactory {
    /**
     * @notice Emitted when a new MetaMorpho vault is created
     * @param metaMorpho The address of the new MetaMorpho vault
     * @param sender The address that created the vault
     * @param initialOwner The initial owner of the vault
     * @param initialTimelock The initial timelock duration
     * @param asset The underlying asset of the vault
     * @param name The name of the vault token
     * @param symbol The symbol of the vault token
     * @param salt The salt used for CREATE2 deployment
     */
    event CreateMetaMorpho(
        address indexed metaMorpho,
        address indexed sender,
        address initialOwner,
        uint256 initialTimelock,
        address asset,
        string name,
        string symbol,
        bytes32 salt
    );

    /**
     * @notice The address of the Morpho Blue contract
     * @return The Morpho contract address
     */
    function MORPHO() external view returns (address);

    /**
     * @notice Checks if an address is a MetaMorpho vault created by this factory
     * @param target The address to check
     * @return True if the address is a MetaMorpho vault, false otherwise
     */
    function isMetaMorpho(address target) external view returns (bool);

    /**
     * @notice Creates a new MetaMorpho vault
     * @param initialOwner The initial owner of the vault
     * @param initialTimelock The initial timelock duration for governance actions
     * @param asset The underlying asset of the vault
     * @param name The name of the vault token
     * @param symbol The symbol of the vault token
     * @param salt The salt to use for the CREATE2 deployment
     * @return metaMorpho The address of the newly created MetaMorpho vault
     */
    function createMetaMorpho(
        address initialOwner,
        uint256 initialTimelock,
        address asset,
        string memory name,
        string memory symbol,
        bytes32 salt
    ) external returns (address metaMorpho);
} 


================================================
FILE: contracts/morpho/IMorphoAdaptiveIRM.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IMorphoBlue.sol";

/**
 * @title IMorphoAdaptiveIRM
 * @notice Interface for Morpho's Adaptive Curve Interest Rate Model (IRM)
 * @dev This IRM dynamically adjusts interest rates based on market utilization
 * @custom:tags morpho,defi,irm,interest-rate,adaptive
 */
interface IMorphoAdaptiveIRM {
    /**
     * @notice Emitted when a borrow rate is updated
     * @param id The market identifier
     * @param avgBorrowRate The average borrow rate
     * @param rateAtTarget The rate at target utilization
     */
    event BorrowRateUpdate(IMorphoBlue.Id indexed id, uint256 avgBorrowRate, uint256 rateAtTarget);

    /**
     * @notice The address of Morpho Blue contract
     * @return The address of Morpho
     */
    function MORPHO() external view returns (address);

    /**
     * @notice Returns the rate at target utilization for a given market
     * @dev The rate at target utilization determines the height of the interest rate curve
     * @param id The market identifier
     * @return The rate at target utilization (scaled by 1e18)
     */
    function rateAtTarget(IMorphoBlue.Id id) external view returns (int256);

    /**
     * @notice Calculates the current borrow rate for a market without changing state
     * @dev Returns the average borrow rate per second (scaled by 1e18)
     * @param marketParams The market parameters
     * @param market The market state
     * @return The borrow rate per second (scaled by 1e18)
     */
    function borrowRateView(
        IMorphoBlue.MarketParams memory marketParams, 
        IMorphoBlue.Market memory market
    ) external view returns (uint256);

    /**
     * @notice Calculates and updates the current borrow rate for a market
     * @dev Updates the rateAtTarget state variable for the market
     * @dev Only callable by the Morpho contract
     * @param marketParams The market parameters
     * @param market The market state
     * @return The borrow rate per second (scaled by 1e18)
     */
    function borrowRate(
        IMorphoBlue.MarketParams memory marketParams, 
        IMorphoBlue.Market memory market
    ) external returns (uint256);
} 


================================================
FILE: contracts/morpho/IMorphoBlue.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IMorphoBlue
 * @notice Interface for Morpho Blue lending protocol
 * @dev This interface combines the core functions and types from the Morpho Blue protocol
 * @custom:tags morpho,defi,lending,blue,protocol
 */
interface IMorphoBlue {
    /**
     * @notice Market identifier type
     */
    type Id is bytes32;

    /**
     * @notice Market parameters
     * @param loanToken The address of the token to be borrowed/supplied
     * @param collateralToken The address of the token to be used as collateral
     * @param oracle The address of the oracle used to price the collateral against the loan token
     * @param irm The address of the interest rate model
     * @param lltv The liquidation loan-to-value (scaled by 1e18)
     */
    struct MarketParams {
        address loanToken;
        address collateralToken;
        address oracle;
        address irm;
        uint256 lltv;
    }

    /**
     * @notice Position of a user in a market
     * @dev For `feeRecipient`, `supplyShares` does not contain accrued shares since the last interest accrual
     * @param supplyShares The supply shares amount
     * @param borrowShares The borrow shares amount
     * @param collateral The collateral amount
     */
    struct Position {
        uint256 supplyShares;
        uint128 borrowShares;
        uint128 collateral;
    }

    /**
     * @notice Market state
     * @dev `totalSupplyAssets` and `totalBorrowAssets` do not contain accrued interest since the last interest accrual
     * @dev `totalSupplyShares` does not contain additional shares accrued by `feeRecipient` since the last interest accrual
     * @param totalSupplyAssets The total amount of assets supplied
     * @param totalSupplyShares The total amount of supply shares
     * @param totalBorrowAssets The total amount of assets borrowed
     * @param totalBorrowShares The total amount of borrow shares
     * @param lastUpdate The timestamp of the last interest accrual
     * @param fee The fee rate (scaled by 1e18)
     */
    struct Market {
        uint128 totalSupplyAssets;
        uint128 totalSupplyShares;
        uint128 totalBorrowAssets;
        uint128 totalBorrowShares;
        uint128 lastUpdate;
        uint128 fee;
    }

    /**
     * @notice Authorization data for delegated operations
     * @param authorizer The account delegating authorization
     * @param authorized The account being authorized
     * @param isAuthorized Whether the authorization is granted or revoked
     * @param nonce The nonce for preventing replay attacks
     * @param deadline The deadline after which the signature is no longer valid
     */
    struct Authorization {
        address authorizer;
        address authorized;
        bool isAuthorized;
        uint256 nonce;
        uint256 deadline;
    }

    /**
     * @notice EIP-712 signature components
     * @param v The recovery ID
     * @param r The first 32 bytes of the signature
     * @param s The second 32 bytes of the signature
     */
    struct Signature {
        uint8 v;
        bytes32 r;
        bytes32 s;
    }

    /**
     * @notice The EIP-712 domain separator
     * @dev Every EIP-712 signed message based on this domain separator can be reused on chains with the same chain ID
     */
    function DOMAIN_SEPARATOR() external view returns (bytes32);

    /**
     * @notice The owner of the contract
     */
    function owner() external view returns (address);

    /**
     * @notice The fee recipient for all markets
     */
    function feeRecipient() external view returns (address);

    /**
     * @notice Checks if an interest rate model is enabled
     * @param irm The address of the interest rate model
     */
    function isIrmEnabled(address irm) external view returns (bool);

    /**
     * @notice Checks if a liquidation loan-to-value is enabled
     * @param lltv The liquidation loan-to-value
     */
    function isLltvEnabled(uint256 lltv) external view returns (bool);

    /**
     * @notice Checks if an account is authorized to manage another account's positions
     * @param authorizer The account delegating authorization
     * @param authorized The account to check authorization for
     */
    function isAuthorized(address authorizer, address authorized) external view returns (bool);

    /**
     * @notice Returns the current nonce for an account
     * @param authorizer The account to get the nonce for
     */
    function nonce(address authorizer) external view returns (uint256);

    /**
     * @notice Sets a new owner for the contract
     * @param newOwner The new owner address
     */
    function setOwner(address newOwner) external;

    /**
     * @notice Enables an interest rate model
     * @param irm The address of the interest rate model to enable
     */
    function enableIrm(address irm) external;

    /**
     * @notice Enables a liquidation loan-to-value
     * @param lltv The liquidation loan-to-value to enable
     */
    function enableLltv(uint256 lltv) external;

    /**
     * @notice Sets the fee for a market
     * @param marketParams The market parameters
     * @param newFee The new fee rate (scaled by 1e18)
     */
    function setFee(MarketParams memory marketParams, uint256 newFee) external;

    /**
     * @notice Sets a new fee recipient
     * @param newFeeRecipient The new fee recipient address
     */
    function setFeeRecipient(address newFeeRecipient) external;

    /**
     * @notice Creates a new market
     * @param marketParams The market parameters
     */
    function createMarket(MarketParams memory marketParams) external;

    /**
     * @notice Supplies assets or shares to a market
     * @param marketParams The market parameters
     * @param assets The amount of assets to supply (set to 0 if using shares)
     * @param shares The amount of shares to mint (set to 0 if using assets)
     * @param onBehalf The address that will own the increased supply position
     * @param data Arbitrary data to pass to the callback
     * @return assetsSupplied The amount of assets supplied
     * @return sharesSupplied The amount of shares minted
     */
    function supply(
        MarketParams memory marketParams,
        uint256 assets,
        uint256 shares,
        address onBehalf,
        bytes memory data
    ) external returns (uint256 assetsSupplied, uint256 sharesSupplied);

    /**
     * @notice Withdraws assets or shares from a market
     * @param marketParams The market parameters
     * @param assets The amount of assets to withdraw (set to 0 if using shares)
     * @param shares The amount of shares to burn (set to 0 if using assets)
     * @param onBehalf The address of the owner of the supply position
     * @param receiver The address that will receive the withdrawn assets
     * @return assetsWithdrawn The amount of assets withdrawn
     * @return sharesWithdrawn The amount of shares burned
     */
    function withdraw(
        MarketParams memory marketParams,
        uint256 assets,
        uint256 shares,
        address onBehalf,
        address receiver
    ) external returns (uint256 assetsWithdrawn, uint256 sharesWithdrawn);

    /**
     * @notice Borrows assets or shares from a market
     * @param marketParams The market parameters
     * @param assets The amount of assets to borrow (set to 0 if using shares)
     * @param shares The amount of shares to mint (set to 0 if using assets)
     * @param onBehalf The address that will own the increased borrow position
     * @param receiver The address that will receive the borrowed assets
     * @return assetsBorrowed The amount of assets borrowed
     * @return sharesBorrowed The amount of shares minted
     */
    function borrow(
        MarketParams memory marketParams,
        uint256 assets,
        uint256 shares,
        address onBehalf,
        address receiver
    ) external returns (uint256 assetsBorrowed, uint256 sharesBorrowed);

    /**
     * @notice Repays a borrow position
     * @param marketParams The market parameters
     * @param assets The amount of assets to repay (set to 0 if using shares)
     * @param shares The amount of shares to burn (set to 0 if using assets)
     * @param onBehalf The address of the owner of the debt position
     * @param data Arbitrary data to pass to the callback
     * @return assetsRepaid The amount of assets repaid
     * @return sharesRepaid The amount of shares burned
     */
    function repay(
        MarketParams memory marketParams,
        uint256 assets,
        uint256 shares,
        address onBehalf,
        bytes memory data
    ) external returns (uint256 assetsRepaid, uint256 sharesRepaid);

    /**
     * @notice Supplies collateral to a market
     * @param marketParams The market parameters
     * @param assets The amount of collateral to supply
     * @param onBehalf The address that will own the increased collateral position
     * @param data Arbitrary data to pass to the callback
     */
    function supplyCollateral(
        MarketParams memory marketParams,
        uint256 assets,
        address onBehalf,
        bytes memory data
    ) external;

    /**
     * @notice Withdraws collateral from a market
     * @param marketParams The market parameters
     * @param assets The amount of collateral to withdraw
     * @param onBehalf The address of the owner of the collateral position
     * @param receiver The address that will receive the collateral assets
     */
    function withdrawCollateral(
        MarketParams memory marketParams,
        uint256 assets,
        address onBehalf,
        address receiver
    ) external;

    /**
     * @notice Liquidates an unhealthy position
     * @param marketParams The market parameters
     * @param borrower The owner of the position
     * @param seizedAssets The amount of collateral to seize (set to 0 if using repaidShares)
     * @param repaidShares The amount of shares to repay (set to 0 if using seizedAssets)
     * @param data Arbitrary data to pass to the callback
     * @return The amount of assets seized
     * @return The amount of assets repaid
     */
    function liquidate(
        MarketParams memory marketParams,
        address borrower,
        uint256 seizedAssets,
        uint256 repaidShares,
        bytes memory data
    ) external returns (uint256, uint256);

    /**
     * @notice Executes a flash loan
     * @param token The token to flash loan
     * @param assets The amount of assets to flash loan
     * @param data Arbitrary data to pass to the callback
     */
    function flashLoan(address token, uint256 assets, bytes calldata data) external;

    /**
     * @notice Sets the authorization for an address to manage the caller's positions
     * @param authorized The authorized address
     * @param newIsAuthorized The new authorization status
     */
    function setAuthorization(address authorized, bool newIsAuthorized) external;

    /**
     * @notice Sets authorization using a signature
     * @param authorization The authorization data
     * @param signature The signature
     */
    function setAuthorizationWithSig(Authorization calldata authorization, Signature calldata signature) external;

    /**
     * @notice Accrues interest for a market
     * @param marketParams The market parameters
     */
    function accrueInterest(MarketParams memory marketParams) external;

    /**
     * @notice Returns the data stored on the different slots
     * @param slots The storage slots to read
     * @return The values stored in the slots
     */
    function extSloads(bytes32[] memory slots) external view returns (bytes32[] memory);

    /**
     * @notice Returns the position of a user in a market
     * @param id The market identifier
     * @param user The user address
     * @return The position data
     */
    function position(Id id, address user) external view returns (Position memory);

    /**
     * @notice Returns the state of a market
     * @param id The market identifier
     * @return The market state
     */
    function market(Id id) external view returns (Market memory);

    /**
     * @notice Returns the market parameters for a market ID
     * @param id The market identifier
     * @return The market parameters
     */
    function idToMarketParams(Id id) external view returns (MarketParams memory);
} 


================================================
FILE: contracts/morpho/IMorphoCallbacks.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @custom:tags morpho,defi,callbacks,hooks
 */

/**
 * @title IMorphoLiquidateCallback
 * @notice Interface that liquidators willing to use `liquidate`'s callback must implement
 */
interface IMorphoLiquidateCallback {
    /**
     * @notice Callback called when a liquidation occurs
     * @dev The callback is called only if data is not empty
     * @param repaidAssets The amount of repaid assets
     * @param data Arbitrary data passed to the `liquidate` function
     */
    function onMorphoLiquidate(uint256 repaidAssets, bytes calldata data) external;
}

/**
 * @title IMorphoRepayCallback
 * @notice Interface that users willing to use `repay`'s callback must implement
 */
interface IMorphoRepayCallback {
    /**
     * @notice Callback called when a repayment occurs
     * @dev The callback is called only if data is not empty
     * @param assets The amount of repaid assets
     * @param data Arbitrary data passed to the `repay` function
     */
    function onMorphoRepay(uint256 assets, bytes calldata data) external;
}

/**
 * @title IMorphoSupplyCallback
 * @notice Interface that users willing to use `supply`'s callback must implement
 */
interface IMorphoSupplyCallback {
    /**
     * @notice Callback called when a supply occurs
     * @dev The callback is called only if data is not empty
     * @param assets The amount of supplied assets
     * @param data Arbitrary data passed to the `supply` function
     */
    function onMorphoSupply(uint256 assets, bytes calldata data) external;
}

/**
 * @title IMorphoSupplyCollateralCallback
 * @notice Interface that users willing to use `supplyCollateral`'s callback must implement
 */
interface IMorphoSupplyCollateralCallback {
    /**
     * @notice Callback called when a supply of collateral occurs
     * @dev The callback is called only if data is not empty
     * @param assets The amount of supplied collateral
     * @param data Arbitrary data passed to the `supplyCollateral` function
     */
    function onMorphoSupplyCollateral(uint256 assets, bytes calldata data) external;
}

/**
 * @title IMorphoFlashLoanCallback
 * @notice Interface that users willing to use `flashLoan`'s callback must implement
 */
interface IMorphoFlashLoanCallback {
    /**
     * @notice Callback called when a flash loan occurs
     * @dev The callback is called only if data is not empty
     * @param assets The amount of assets that was flash loaned
     * @param data Arbitrary data passed to the `flashLoan` function
     */
    function onMorphoFlashLoan(uint256 assets, bytes calldata data) external;
} 


================================================
FILE: contracts/morpho/IMorphoChainlinkOracleV2.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IERC4626.sol";
import "../oracles/chainlink/IAggregatorV3Interface.sol";
import "./IMorphoOracle.sol";

/**
 * @title IMorphoChainlinkOracleV2
 * @notice Interface for Morpho's Chainlink Oracle V2, which combines ERC4626 vault assets with Chainlink price feeds
 * @author Morpho Labs
 * @custom:contact security@morpho.org
 * @custom:tags morpho,oracle,chainlink,defi
 */
interface IMorphoChainlinkOracleV2 is IMorphoOracle {
    /**
     * @notice Returns the address of the base ERC4626 vault
     * @return The base vault address
     */
    function BASE_VAULT() external view returns (IERC4626);

    /**
     * @notice Returns the base vault conversion sample
     * @return The sample amount used to convert vault shares to assets
     */
    function BASE_VAULT_CONVERSION_SAMPLE() external view returns (uint256);

    /**
     * @notice Returns the address of the quote ERC4626 vault
     * @return The quote vault address
     */
    function QUOTE_VAULT() external view returns (IERC4626);

    /**
     * @notice Returns the quote vault conversion sample
     * @return The sample amount used to convert vault shares to assets
     */
    function QUOTE_VAULT_CONVERSION_SAMPLE() external view returns (uint256);

    /**
     * @notice Returns the address of the first base feed
     * @return The first base Chainlink feed
     */
    function BASE_FEED_1() external view returns (IAggregatorV3Interface);

    /**
     * @notice Returns the address of the second base feed
     * @return The second base Chainlink feed
     */
    function BASE_FEED_2() external view returns (IAggregatorV3Interface);

    /**
     * @notice Returns the address of the first quote feed
     * @return The first quote Chainlink feed
     */
    function QUOTE_FEED_1() external view returns (IAggregatorV3Interface);

    /**
     * @notice Returns the address of the second quote feed
     * @return The second quote Chainlink feed
     */
    function QUOTE_FEED_2() external view returns (IAggregatorV3Interface);

    /**
     * @notice Returns the price scale factor, calculated at contract creation
     * @return The scale factor for price calculations
     */
    function SCALE_FACTOR() external view returns (uint256);
} 


================================================
FILE: contracts/morpho/IMorphoChainlinkOracleV2Factory.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IERC4626.sol";
import "../oracles/chainlink/IAggregatorV3Interface.sol";
import "./IMorphoChainlinkOracleV2.sol";

/**
 * @title IMorphoChainlinkOracleV2Factory
 * @notice Interface for the factory that creates Morpho Chainlink Oracle V2 instances
 * @author Morpho Labs
 * @custom:contact security@morpho.org
 * @custom:tags morpho,oracle,chainlink,factory,defi
 */
interface IMorphoChainlinkOracleV2Factory {
    /**
     * @notice Emitted when a new Chainlink oracle is created
     * @param caller The address that created the oracle
     * @param oracle The address of the new oracle contract
     */
    event CreateMorphoChainlinkOracleV2(address caller, address oracle);

    /**
     * @notice Checks if an address was deployed by this factory
     * @param target The address to check
     * @return Whether the address is a MorphoChainlinkOracleV2 deployed by this factory
     */
    function isMorphoChainlinkOracleV2(address target) external view returns (bool);

    /**
     * @notice Creates a new Morpho Chainlink Oracle V2
     * @dev Here is the list of assumptions that guarantees the oracle behaves as expected:
     * - The vaults, if set, are ERC4626-compliant
     * - The feeds, if set, are Chainlink-interface-compliant
     * - Decimals passed as argument are correct
     * - The base vaults's sample shares quoted as assets and the base feed prices don't overflow when multiplied
     * - The quote vault's sample shares quoted as assets and the quote feed prices don't overflow when multiplied
     * @param baseVault Base vault (address zero to omit)
     * @param baseVaultConversionSample Sample amount of base vault shares for conversion precision
     * @param baseFeed1 First base feed (address zero if price = 1)
     * @param baseFeed2 Second base feed (address zero if price = 1)
     * @param baseTokenDecimals Base token decimals
     * @param quoteVault Quote vault (address zero to omit)
     * @param quoteVaultConversionSample Sample amount of quote vault shares for conversion precision
     * @param quoteFeed1 First quote feed (address zero if price = 1)
     * @param quoteFeed2 Second quote feed (address zero if price = 1)
     * @param quoteTokenDecimals Quote token decimals
     * @param salt The salt to use for the CREATE2 deployment
     * @return oracle The created oracle address
     */
    function createMorphoChainlinkOracleV2(
        IERC4626 baseVault,
        uint256 baseVaultConversionSample,
        IAggregatorV3Interface baseFeed1,
        IAggregatorV3Interface baseFeed2,
        uint256 baseTokenDecimals,
        IERC4626 quoteVault,
        uint256 quoteVaultConversionSample,
        IAggregatorV3Interface quoteFeed1,
        IAggregatorV3Interface quoteFeed2,
        uint256 quoteTokenDecimals,
        bytes32 salt
    ) external returns (IMorphoChainlinkOracleV2 oracle);
} 


================================================
FILE: contracts/morpho/IMorphoOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IMorphoOracle
 * @notice Interface for oracles used by Morpho Blue
 * @dev It is the user's responsibility to select markets with safe oracles
 * @custom:tags morpho,oracle,defi,interface
 */
interface IMorphoOracle {
    /**
     * @notice Returns the price of 1 asset of collateral token quoted in 1 asset of loan token
     * @dev The price is scaled by 1e36
     * @dev It corresponds to the price of 10**(collateral token decimals) assets of collateral token quoted in
     * 10**(loan token decimals) assets of loan token with `36 + loan token decimals - collateral token decimals`
     * decimals of precision
     * @return The price of the collateral token in loan token units
     */
    function price() external view returns (uint256);
} 


================================================
FILE: contracts/morpho/IPreLiquidation.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IMorphoBlue.sol";

/**
 * @title IPreLiquidation
 * @notice Interface for the PreLiquidation contract that enables early liquidations for Morpho Blue positions
 * @author Morpho Labs
 * @custom:contact security@morpho.org
 * @custom:tags morpho,defi,liquidation,preliquidation
 */
interface IPreLiquidation {
    /**
     * @notice Pre-liquidation parameters for a Morpho Blue market
     * @param preLltv The maximum LTV of a position before allowing pre-liquidation, scaled by WAD
     * @param preLCF1 The pre-liquidation close factor when position LTV equals preLltv, scaled by WAD
     * @param preLCF2 The pre-liquidation close factor when position LTV equals LLTV, scaled by WAD
     * @param preLIF1 The pre-liquidation incentive factor when position LTV equals preLltv, scaled by WAD
     * @param preLIF2 The pre-liquidation incentive factor when position LTV equals LLTV, scaled by WAD
     * @param preLiquidationOracle The oracle used to assess whether a position can be pre-liquidated
     */
    struct PreLiquidationParams {
        uint256 preLltv;
        uint256 preLCF1;
        uint256 preLCF2;
        uint256 preLIF1;
        uint256 preLIF2;
        address preLiquidationOracle;
    }

    /**
     * @notice Emitted when a position is pre-liquidated
     * @param id The market ID where the pre-liquidation occurred
     * @param preliquidator The address that performed the pre-liquidation
     * @param borrower The address of the position's owner
     * @param repaidAssets The amount of debt repaid
     * @param repaidShares The amount of borrow shares repaid
     * @param seizedAssets The amount of collateral seized
     */
    event PreLiquidate(
        IMorphoBlue.Id indexed id,
        address indexed preliquidator,
        address indexed borrower,
        uint256 repaidAssets,
        uint256 repaidShares,
        uint256 seizedAssets
    );

    /**
     * @notice Returns the address of the Morpho Blue contract
     * @return The Morpho contract address
     */
    function MORPHO() external view returns (address);

    /**
     * @notice Returns the ID of the Morpho market for which this contract was created
     * @return The market ID
     */
    function ID() external view returns (IMorphoBlue.Id);

    /**
     * @notice Returns the market parameters for the associated Morpho market
     * @return The market parameters
     */
    function marketParams() external view returns (IMorphoBlue.MarketParams memory);

    /**
     * @notice Returns the pre-liquidation parameters for this contract
     * @return The pre-liquidation parameters
     */
    function preLiquidationParams() external view returns (PreLiquidationParams memory);

    /**
     * @notice Pre-liquidates a position that is within the pre-liquidation LTV range
     * @dev Either seizedAssets or repaidShares must be zero (exactly one must be specified)
     * @dev The position must be within the pre-liquidation range (LTV > preLltv but LTV <= LLTV)
     * @dev The pre-liquidation close factor and incentive factor scale linearly based on the position's LTV
     * @param borrower The owner of the position to pre-liquidate
     * @param seizedAssets The amount of collateral to seize (if repaidShares is zero)
     * @param repaidShares The amount of debt shares to repay (if seizedAssets is zero)
     * @param data Arbitrary data to pass to the onPreLiquidate callback (pass empty bytes if not using callback)
     * @return seizedAssets The amount of collateral seized
     * @return repaidAssets The amount of debt repaid
     */
    function preLiquidate(
        address borrower, 
        uint256 seizedAssets, 
        uint256 repaidShares, 
        bytes calldata data
    ) external returns (uint256, uint256);
} 


================================================
FILE: contracts/morpho/IPreLiquidationCallback.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IPreLiquidationCallback
 * @notice Interface that pre-liquidators must implement to receive callbacks during pre-liquidation
 * @author Morpho Labs
 * @custom:contact security@morpho.org
 * @custom:tags morpho,defi,liquidation,callback,preliquidation
 */
interface IPreLiquidationCallback {
    /**
     * @notice Callback function called when a pre-liquidation occurs
     * @dev This callback is only called if non-empty data is passed to the preLiquidate function
     * @param repaidAssets The amount of debt assets repaid in the pre-liquidation
     * @param data Arbitrary data that was passed to the preLiquidate function
     */
    function onPreLiquidate(uint256 repaidAssets, bytes calldata data) external;
} 


================================================
FILE: contracts/morpho/IPreLiquidationFactory.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IMorphoBlue.sol";
import "./IPreLiquidation.sol";

/**
 * @title IPreLiquidationFactory
 * @notice Interface for the PreLiquidation Factory that creates pre-liquidation contracts for Morpho Blue markets
 * @author Morpho Labs
 * @custom:contact security@morpho.org
 * @custom:tags morpho,defi,liquidation,factory,preliquidation
 */
interface IPreLiquidationFactory {
    /**
     * @notice Emitted when a new PreLiquidation contract is created
     * @param preLiquidation The address of the newly created PreLiquidation contract
     * @param id The ID of the Morpho market for which this PreLiquidation contract was created
     * @param params The pre-liquidation parameters for the created contract
     */
    event CreatePreLiquidation(
        address indexed preLiquidation, 
        IMorphoBlue.Id indexed id, 
        IPreLiquidation.PreLiquidationParams params
    );

    /**
     * @notice Returns the address of the Morpho Blue contract
     * @return The Morpho contract address
     */
    function MORPHO() external view returns (address);

    /**
     * @notice Verifies if an address is a PreLiquidation contract created by this factory
     * @param target The address to check
     * @return True if the address is a PreLiquidation contract, false otherwise
     */
    function isPreLiquidation(address target) external view returns (bool);

    /**
     * @notice Creates a new PreLiquidation contract for a specific Morpho Blue market
     * @dev Will revert if a PreLiquidation contract with the same parameters already exists
     * @param id The ID of the Morpho market for which to create a PreLiquidation contract
     * @param preLiquidationParams The parameters for the PreLiquidation contract
     * @return preLiquidation The address of the newly created PreLiquidation contract
     */
    function createPreLiquidation(
        IMorphoBlue.Id id, 
        IPreLiquidation.PreLiquidationParams calldata preLiquidationParams
    ) external returns (address preLiquidation);
} 


================================================
FILE: contracts/morpho/IPublicAllocator.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IMorphoBlue.sol";
import "./IMetaMorpho.sol";

/**
 * @title IPublicAllocator
 * @notice Interface for PublicAllocator, which enables permissionless reallocation of MetaMorpho vaults
 * @author Morpho Labs
 * @custom:contact security@morpho.org
 * @custom:tags morpho,defi,allocator,liquidity
 */
interface IPublicAllocator {
    /**
     * @notice Maximum settable flow cap, ensuring caps can always be stored on 128 bits
     * @dev The actual max possible flow cap is type(uint128).max-1
     * @return The maximum settable flow cap value
     */
    function MAX_SETTABLE_FLOW_CAP() external pure returns (uint128);

    /**
     * @notice Defines maximum allowed inflow and outflow for a market
     * @param maxIn The maximum allowed inflow in a market
     * @param maxOut The maximum allowed outflow in a market
     */
    struct FlowCaps {
        uint128 maxIn;
        uint128 maxOut;
    }

    /**
     * @notice Configuration for updating flow caps for a specific market
     * @param id Market ID for which to change flow caps
     * @param caps New flow caps for this market
     */
    struct FlowCapsConfig {
        IMorphoBlue.Id id;
        FlowCaps caps;
    }

    /**
     * @notice Defines a withdrawal from a specific market
     * @param marketParams The market parameters from which to withdraw
     * @param amount The amount to withdraw
     */
    struct Withdrawal {
        IMorphoBlue.MarketParams marketParams;
        uint128 amount;
    }

    /**
     * @notice The Morpho Blue contract
     * @return The Morpho contract address
     */
    function MORPHO() external view returns (address);

    /**
     * @notice Returns the admin for a given vault
     * @param vault The MetaMorpho vault
     * @return The admin address for the vault
     */
    function admin(address vault) external view returns (address);

    /**
     * @notice Returns the current ETH fee for a given vault
     * @param vault The MetaMorpho vault
     * @return The fee amount in ETH
     */
    function fee(address vault) external view returns (uint256);

    /**
     * @notice Returns the accrued ETH fee for a given vault
     * @param vault The MetaMorpho vault
     * @return The accrued fee amount in ETH
     */
    function accruedFee(address vault) external view returns (uint256);

    /**
     * @notice Returns the maximum inflow and outflow for a given market in a vault
     * @param vault The MetaMorpho vault
     * @param id The market identifier
     * @return Flow caps for the specified market
     */
    function flowCaps(address vault, IMorphoBlue.Id id) external view returns (FlowCaps memory);

    /**
     * @notice Reallocates funds from multiple markets to one target market
     * @dev Requires payment of the vault's fee
     * @dev Validates that flow caps are respected and market parameters are valid
     * @param vault The MetaMorpho vault to reallocate
     * @param withdrawals The markets to withdraw from and the amounts to withdraw
     * @param supplyMarketParams The market to supply the withdrawn funds to
     */
    function reallocateTo(
        address vault, 
        Withdrawal[] calldata withdrawals, 
        IMorphoBlue.MarketParams calldata supplyMarketParams
    ) external payable;

    /**
     * @notice Sets the admin for a given vault
     * @param vault The MetaMorpho vault
     * @param newAdmin The new admin address
     */
    function setAdmin(address vault, address newAdmin) external;

    /**
     * @notice Sets the fee for a given vault
     * @param vault The MetaMorpho vault
     * @param newFee The new fee amount in ETH
     */
    function setFee(address vault, uint256 newFee) external;

    /**
     * @notice Sets the maximum inflow and outflow through public allocation for markets
     * @param vault The MetaMorpho vault
     * @param config Array of market IDs and their flow cap configurations
     */
    function setFlowCaps(address vault, FlowCapsConfig[] calldata config) external;

    /**
     * @notice Transfers the accrued fees to a recipient
     * @param vault The MetaMorpho vault
     * @param feeRecipient The address to receive the fees
     */
    function transferFee(address vault, address payable feeRecipient) external;

    /**
     * @notice Emitted when a new admin is set for a vault
     * @param sender The address that set the admin
     * @param vault The MetaMorpho vault
     * @param newAdmin The new admin address
     */
    event SetAdmin(address indexed sender, address indexed vault, address indexed newAdmin);

    /**
     * @notice Emitted when a new fee is set for a vault
     * @param sender The address that set the fee
     * @param vault The MetaMorpho vault
     * @param newFee The new fee amount
     */
    event SetFee(address indexed sender, address indexed vault, uint256 newFee);

    /**
     * @notice Emitted when flow caps are set for markets
     * @param sender The address that set the flow caps
     * @param vault The MetaMorpho vault
     * @param config The flow cap configurations
     */
    event SetFlowCaps(address indexed sender, address indexed vault, FlowCapsConfig[] config);

    /**
     * @notice Emitted when fees are transferred
     * @param sender The address that initiated the transfer
     * @param vault The MetaMorpho vault
     * @param amount The amount transferred
     * @param recipient The recipient of the fees
     */
    event TransferFee(address indexed sender, address indexed vault, uint256 amount, address indexed recipient);

    /**
     * @notice Emitted when a withdrawal is performed during reallocation
     * @param sender The address that performed the reallocation
     * @param vault The MetaMorpho vault
     * @param marketId The market ID from which funds were withdrawn
     * @param amount The amount withdrawn
     */
    event PublicWithdrawal(address indexed sender, address indexed vault, IMorphoBlue.Id indexed marketId, uint128 amount);

    /**
     * @notice Emitted when a reallocation is completed
     * @param sender The address that performed the reallocation
     * @param vault The MetaMorpho vault
     * @param marketId The market ID to which funds were supplied
     * @param amount The total amount reallocated
     */
    event PublicReallocateTo(address indexed sender, address indexed vault, IMorphoBlue.Id indexed marketId, uint128 amount);
} 


================================================
FILE: contracts/nft/IBulkWriter.sol
================================================
// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity ^0.8.20;

/**
 * @title IBulkWriter
 * @notice Utility batch methods to interact with ERCs 7401 (Nestable NFTs) and 6220 (Equippable NFTs)
 * @dev Interface for bulk operations on RMRK NFT collections
 * @custom:katana 0xcd891c3de90dcdF99549E9B6402BFAa695DEc69B
 * @custom:bokuto 0xA681A7BE7A87bDA505c1a947b172b8A1988E329A
 * @custom:tags nft,erc721,rmrk,bulk,utility
 */
interface IBulkWriter {
    error RMRKCanOnlyDoBulkOperationsOnOwnedTokens();
    error RMRKCanOnlyDoBulkOperationsWithOneTokenAtATime();

    function bulkEquip(
        address collection,
        uint256 tokenId,
        RMRKBulkWriter.IntakeUnequip[] memory unequips,
        IERC6220.IntakeEquip[] memory equips
    ) external;

    function bulkTransferAllChildren(
        address collection,
        uint256 tokenId,
        address to,
        uint256 destinationId
    ) external;

    function bulkTransferChildren(
        address collection,
        uint256 tokenId,
        uint256[] memory childrenIndexes,
        address to,
        uint256 destinationId
    ) external;

    function replaceEquip(address collection, IERC6220.IntakeEquip memory data)
        external;
}

interface RMRKBulkWriter {
    struct IntakeUnequip {
        uint64 assetId;
        uint64 slotPartId;
    }
}

interface IERC6220 {
    struct IntakeEquip {
        uint256 tokenId;
        uint256 childIndex;
        uint64 assetId;
        uint64 slotPartId;
        uint64 childAssetId;
    }
}


================================================
FILE: contracts/nft/ICatalogFactory.sol
================================================
// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity ^0.8.20;

/**
 * @title ICatalogFactory
 * @notice Factory to create Catalog instances, necessary to configure composability and equippability of NFTs (ERC6220)
 * @dev Interface for deploying and managing RMRK catalog contracts
 * @custom:katana 0xC0137140B2D2a146d20dBbb0153e5Ac1048f30E3
 * @custom:bokuto 0xC0137140B2D2a146d20dBbb0153e5Ac1048f30E3
 * @custom:tags nft,erc721,rmrk,catalog,factory
 */
interface ICatalogFactory {
    event CatalogDeployed(address indexed deployer, address indexed catalog);

    function deployCatalog(string memory metadataURI, string memory type_)
        external
        returns (address);

    function getDeployerCatalogAtIndex(address deployer, uint256 index)
        external
        view
        returns (address catalogAddress);

    function getDeployerCatalogs(address deployer)
        external
        view
        returns (address[] memory);

    function getLastDeployerCatalog(address deployer)
        external
        view
        returns (address catalogAddress);

    function getTotalDeployerCatalogs(address deployer)
        external
        view
        returns (uint256 total);
}


================================================
FILE: contracts/nft/ICatalogUtils.sol
================================================
// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity ^0.8.20;

/**
 * @title ICatalogUtils
 * @notice Utility methods to interact with Catalog instances (ERC6220)
 * @dev Interface for catalog utility operations in RMRK NFT ecosystem
 * @custom:katana 0xB1e10B768E9d56A51f1C80d70414989ECAf87fd0
 * @custom:bokuto 0xB1e10B768E9d56A51f1C80d70414989ECAf87fd0
 * @custom:tags nft,erc721,rmrk,catalog,utility
 */
interface ICatalogUtils {
    error RMRKNotComposableAsset();

    function getCatalogData(address catalog)
        external
        view
        returns (
            address owner,
            string memory type_,
            string memory metadataURI
        );

    function getCatalogDataAndExtendedParts(
        address catalog,
        uint64[] memory partIds
    )
        external
        view
        returns (
            address owner,
            string memory type_,
            string memory metadataURI,
            RMRKCatalogUtils.ExtendedPart[] memory parts
        );

    function getExtendedParts(address catalog, uint64[] memory partIds)
        external
        view
        returns (RMRKCatalogUtils.ExtendedPart[] memory parts);

    function getOrphanEquipmentsFromChildAsset(
        address parentAddress,
        uint256 parentId
    )
        external
        view
        returns (RMRKCatalogUtils.ExtendedEquipment[] memory equipments);

    function getOrphanEquipmentsFromParentAsset(
        address parentAddress,
        uint256 parentId,
        address catalogAddress,
        uint64[] memory slotPartIds
    )
        external
        view
        returns (RMRKCatalogUtils.ExtendedEquipment[] memory equipments);

    function getSlotPartsAndCatalog(
        address tokenAddress,
        uint256 tokenId,
        uint64 assetId
    )
        external
        view
        returns (uint64[] memory parentSlotPartIds, address catalogAddress);

    function splitSlotAndFixedParts(
        uint64[] memory allPartIds,
        address catalogAddress
    )
        external
        view
        returns (uint64[] memory slotPartIds, uint64[] memory fixedPartIds);
}

interface RMRKCatalogUtils {
    struct ExtendedPart {
        uint64 partId;
        uint8 itemType;
        uint8 z;
        address[] equippable;
        bool equippableToAll;
        string metadataURI;
    }

    struct ExtendedEquipment {
        uint64 parentAssetId;
        uint64 slotId;
        address childAddress;
        uint256 childId;
        uint64 childAssetId;
    }
}


================================================
FILE: contracts/nft/IRenderUtils.sol
================================================
// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity ^0.8.20;

/**
 * @title IRenderUtils
 * @notice Utility methods to get batch get full state of NFTs following 5773 (MultiAsset NFTs), 6220 (Equippable NFTs) and 7401 (Nestable NFTs) ERCs
 * @dev Interface for rendering and state retrieval of RMRK NFT collections
 * @custom:katana 0xA681A7BE7A87bDA505c1a947b172b8A1988E329A
 * @custom:bokuto 0xcd891c3de90dcdF99549E9B6402BFAa695DEc69B
 * @custom:tags nft,erc721,rmrk,rendering,utility
 */
interface IRenderUtils {
    error RMRKChildNotFoundInParent();
    error RMRKMismachedArrayLength();
    error RMRKNotComposableAsset();
    error RMRKParentIsNotNFT();
    error RMRKTokenHasNoAssets();
    error RMRKUnexpectedParent();

    function checkExpectedParent(
        address childAddress,
        uint256 childId,
        address expectedParent,
        uint256 expectedParentId
    ) external view;

    function composeEquippables(
        address target,
        uint256 tokenId,
        uint64 assetId
    )
        external
        view
        returns (
            string memory metadataURI,
            uint64 equippableGroupId,
            address catalogAddress,
            RMRKEquipRenderUtils.FixedPart[] memory fixedParts,
            RMRKEquipRenderUtils.EquippedSlotPart[] memory slotParts
        );

    function directOwnerOfWithParentsPerspective(
        address collection,
        uint256 tokenId
    )
        external
        view
        returns (
            address directOwner,
            uint256 ownerId,
            bool isNFT,
            bool inParentsActiveChildren,
            bool inParentsPendingChildren
        );

    function equippedChildrenOf(
        address parentAddress,
        uint256 parentId,
        uint64 parentAssetId
    ) external view returns (IERC6220.Equipment[] memory equippedChildren);

    function getAllEquippableSlotsFromParent(
        address targetChild,
        uint256 childId,
        bool onlyEquipped
    )
        external
        view
        returns (
            uint256 childIndex,
            RMRKEquipRenderUtils.EquippableData[] memory equippableData
        );

    function getAssetIdWithTopPriority(address target, uint256 tokenId)
        external
        view
        returns (uint64 maxPriorityAssetId, uint64 maxPriority);

    function getAssetsById(
        address target,
        uint256 tokenId,
        uint64[] memory assetIds
    ) external view returns (string[] memory assets);

    function getChildIndex(
        address parentAddress,
        uint256 parentId,
        address childAddress,
        uint256 childId
    ) external view returns (uint256 index);

    function getChildrenWithTopMetadata(address parentAddress, uint256 parentId)
        external
        view
        returns (
            RMRKEquipRenderUtils.ChildWithTopAssetMetadata[]
                memory childrenWithMetadata
        );

    function getEquippableSlotsFromParent(
        address childAddress,
        uint256 childId,
        address parentAddress,
        uint256 parentId,
        uint64 parentAssetId
    )
        external
        view
        returns (RMRKEquipRenderUtils.EquippableData[] memory equippableData);

    function getEquippableSlotsFromParent(
        address targetChild,
        uint256 childId,
        uint64 parentAssetId
    )
        external
        view
        returns (
            uint256 childIndex,
            RMRKEquipRenderUtils.EquippableData[] memory equippableData
        );

    function getEquippableSlotsFromParentForPendingChild(
        address targetChild,
        uint256 childId,
        uint64 parentAssetId
    )
        external
        view
        returns (
            uint256 childIndex,
            RMRKEquipRenderUtils.EquippableData[] memory equippableData
        );

    function getEquipped(
        address target,
        uint256 tokenId,
        uint64 assetId
    )
        external
        view
        returns (
            uint64[] memory slotPartIds,
            IERC6220.Equipment[] memory childrenEquipped,
            string[] memory childrenAssetMetadata
        );

    function getExtendedActiveAssets(address target, uint256 tokenId)
        external
        view
        returns (
            RMRKMultiAssetRenderUtils.ExtendedActiveAsset[] memory activeAssets
        );

    function getExtendedEquippableActiveAssets(address target, uint256 tokenId)
        external
        view
        returns (
            RMRKEquipRenderUtils.ExtendedEquippableActiveAsset[]
                memory activeAssets
        );

    function getExtendedNft(uint256 tokenId, address targetCollection)
        external
        view
        returns (RMRKRenderUtils.ExtendedNft memory data);

    function getExtendedPendingAssets(address target, uint256 tokenId)
        external
        view
        returns (
            RMRKEquipRenderUtils.ExtendedPendingAsset[] memory pendingAssets
        );

    function getParent(address childAddress, uint256 childId)
        external
        view
        returns (address parentAddress, uint256 parentId);

    function getPendingAssets(address target, uint256 tokenId)
        external
        view
        returns (RMRKMultiAssetRenderUtils.PendingAsset[] memory pendingAssets);

    function getPendingChildIndex(
        address parentAddress,
        uint256 parentId,
        address childAddress,
        uint256 childId
    ) external view returns (uint256 index);

    function getSlotPartsAndCatalog(
        address tokenAddress,
        uint256 tokenId,
        uint64 assetId
    )
        external
        view
        returns (uint64[] memory parentSlotPartIds, address catalogAddress);

    function getTopAsset(address target, uint256 tokenId)
        external
        view
        returns (
            uint64 topAssetId,
            uint64 topAssetPriority,
            string memory topAssetMetadata
        );

    function getTopAssetAndEquippableDataForToken(
        address target,
        uint256 tokenId
    )
        external
        view
        returns (
            RMRKEquipRenderUtils.ExtendedEquippableActiveAsset memory topAsset
        );

    function getTopAssetMetaForToken(address target, uint256 tokenId)
        external
        view
        returns (string memory metadata);

    function getTopAssetMetadataForTokens(
        address target,
        uint256[] memory tokenIds
    ) external view returns (string[] memory metadata);

    function getTotalDescendants(address collection, uint256 tokenId)
        external
        view
        returns (uint256 totalDescendants, bool hasMoreThanOneLevelOfNesting_);

    function hasMoreThanOneLevelOfNesting(address collection, uint256 tokenId)
        external
        view
        returns (bool hasMoreThanOneLevelOfNesting_);

    function isAssetEquipped(
        address parentAddress,
        uint256 parentId,
        address parentAssetCatalog,
        address childAddress,
        uint256 childId,
        uint64 childAssetId,
        uint64 slotPartId
    ) external view returns (bool isEquipped);

    function isTokenRejectedOrAbandoned(address collection, uint256 tokenId)
        external
        view
        returns (bool isRejectedOrAbandoned);

    function splitSlotAndFixedParts(
        uint64[] memory allPartIds,
        address catalogAddress
    )
        external
        view
        returns (uint64[] memory slotPartIds, uint64[] memory fixedPartIds);

    function validateChildOf(
        address parentAddress,
        address childAddress,
        uint256 parentId,
        uint256 childId
    ) external view returns (bool validChild);

    function validateChildrenOf(
        address parentAddress,
        address[] memory childAddresses,
        uint256 parentId,
        uint256[] memory childIds
    ) external view returns (bool isValid, bool[] memory validityOfChildren);
}

interface RMRKEquipRenderUtils {
    struct FixedPart {
        uint64 partId;
        uint8 z;
        string metadataURI;
    }

    struct EquippedSlotPart {
        uint64 partId;
        uint64 childAssetId;
        uint8 z;
        address childAddress;
        uint256 childId;
        string childAssetMetadata;
        string partMetadata;
    }

    struct EquippableData {
        uint64 slotPartId;
        uint64 childAssetId;
        uint64 parentAssetId;
        uint64 priority;
        address parentCatalogAddress;
        bool isEquipped;
        string partMetadata;
        string childAssetMetadata;
        string parentAssetMetadata;
    }

    struct ChildWithTopAssetMetadata {
        address contractAddress;
        uint256 tokenId;
        string metadata;
    }

    struct ExtendedEquippableActiveAsset {
        uint64 id;
        uint64 equippableGroupId;
        uint64 priority;
        address catalogAddress;
        string metadata;
        uint64[] partIds;
    }

    struct ExtendedPendingAsset {
        uint64 id;
        uint64 equippableGroupId;
        uint128 acceptRejectIndex;
        uint64 replacesAssetWithId;
        address catalogAddress;
        string metadata;
        uint64[] partIds;
    }
}

interface IERC6220 {
    struct Equipment {
        uint64 assetId;
        uint64 childAssetId;
        uint256 childId;
        address childEquippableAddress;
    }
}

interface RMRKMultiAssetRenderUtils {
    struct ExtendedActiveAsset {
        uint64 id;
        uint64 priority;
        string metadata;
    }

    struct PendingAsset {
        uint64 id;
        uint128 acceptRejectIndex;
        uint64 replacesAssetWithId;
        string metadata;
    }
}

interface RMRKRenderUtils {
    struct ExtendedNft {
        string tokenMetadataUri;
        address directOwner;
        address rootOwner;
        uint256 activeAssetCount;
        uint256 pendingAssetCount;
        uint64[] priorities;
        uint256 maxSupply;
        uint256 totalSupply;
        address issuer;
        string name;
        string symbol;
        uint256 activeChildrenNumber;
        uint256 pendingChildrenNumber;
        bool isSoulbound;
        bool hasMultiAssetInterface;
        bool hasNestingInterface;
        bool hasEquippableInterface;
    }
}


================================================
FILE: contracts/nft/ITokenAttributesRepository.sol
================================================
// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity ^0.8.20;

/**
 * @title ITokenAttributesRepository
 * @notice Dynamic on-chain storage of token attributes in a public-good repository (ERC7508)
 * @dev Interface for managing token attributes across NFT collections
 * @custom:katana 0xC3f5961F6Bf6A60A6d2F9f45Ec477E1E46144827
 * @custom:bokuto 0xC3f5961F6Bf6A60A6d2F9f45Ec477E1E46144827
 * @custom:tags nft,erc721,rmrk,attributes,repository
 */
interface ITokenAttributesRepository {
    error CollaboratorArraysNotEqualLength();
    error CollectionNotRegistered();
    error ExpiredDeadline();
    error InvalidSignature();
    error LengthsMismatch();
    error NotCollectionCollaborator();
    error NotCollectionOwner();
    error NotCollectionOwnerOrCollaborator();
    error NotSpecificAddress();
    error NotTokenOwner();
    error OwnableNotImplemented();
    event AccessControlRegistration(
        address indexed collection,
        address indexed owner,
        address indexed registeringAddress,
        bool useOwnable
    );
    event AccessControlUpdate(
        address indexed collection,
        string key,
        uint8 accessType,
        address specificAddress
    );
    event AddressAttributeUpdated(
        address indexed collection,
        uint256 indexed tokenId,
        string key,
        address value
    );
    event BoolAttributeUpdated(
        address indexed collection,
        uint256 indexed tokenId,
        string key,
        bool value
    );
    event BytesAttributeUpdated(
        address indexed collection,
        uint256 indexed tokenId,
        string key,
        bytes value
    );
    event CollaboratorUpdate(
        address indexed collection,
        address indexed collaborator,
        bool isCollaborator
    );
    event IntAttributeUpdated(
        address indexed collection,
        uint256 indexed tokenId,
        string key,
        int256 value
    );
    event MetadataURIUpdated(
        address indexed collection,
        string attributesMetadataURI
    );
    event StringAttributeUpdated(
        address indexed collection,
        uint256 indexed tokenId,
        string key,
        string value
    );
    event UintAttributeUpdated(
        address indexed collection,
        uint256 indexed tokenId,
        string key,
        uint256 value
    );

    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function SET_ADDRESS_ATTRIBUTE_TYPEHASH() external view returns (bytes32);

    function SET_BOOL_ATTRIBUTE_TYPEHASH() external view returns (bytes32);

    function SET_BYTES_ATTRIBUTE_TYPEHASH() external view returns (bytes32);

    function SET_INT_ATTRIBUTE_TYPEHASH() external view returns (bytes32);

    function SET_STRING_ATTRIBUTE_TYPEHASH() external view returns (bytes32);

    function SET_UINT_ATTRIBUTE_TYPEHASH() external view returns (bytes32);

    function getAddressAttribute(
        address collection,
        uint256 tokenId,
        string memory key
    ) external view returns (address attribute);

    function getAddressAttributes(
        address[] memory collections,
        uint256[] memory tokenIds,
        string[] memory attributeKeys
    ) external view returns (address[] memory attributes);

    function getAttributes(
        address collection,
        uint256 tokenId,
        string[] memory addressKeys,
        string[] memory boolKeys,
        string[] memory bytesKeys,
        string[] memory intKeys,
        string[] memory stringKeys,
        string[] memory uintKeys
    )
        external
        view
        returns (
            address[] memory addressAttributes,
            bool[] memory boolAttributes,
            bytes[] memory bytesAttributes,
            int256[] memory intAttributes,
            string[] memory stringAttributes,
            uint256[] memory uintAttributes
        );

    function getAttributesMetadataURIForCollection(address collection)
        external
        view
        returns (string memory attributesMetadataURI);

    function getBoolAttribute(
        address collection,
        uint256 tokenId,
        string memory key
    ) external view returns (bool attribute);

    function getBoolAttributes(
        address[] memory collections,
        uint256[] memory tokenIds,
        string[] memory attributeKeys
    ) external view returns (bool[] memory attributes);

    function getBytesAttribute(
        address collection,
        uint256 tokenId,
        string memory key
    ) external view returns (bytes memory attribute);

    function getBytesAttributes(
        address[] memory collections,
        uint256[] memory tokenIds,
        string[] memory attributeKeys
    ) external view returns (bytes[] memory attributes);

    function getIntAttribute(
        address collection,
        uint256 tokenId,
        string memory key
    ) external view returns (int256 attribute);

    function getIntAttributes(
        address[] memory collections,
        uint256[] memory tokenIds,
        string[] memory attributeKeys
    ) external view returns (int256[] memory attributes);

    function getStringAttribute(
        address collection,
        uint256 tokenId,
        string memory key
    ) external view returns (string memory attribute);

    function getStringAttributes(
        address[] memory collections,
        uint256[] memory tokenIds,
        string[] memory attributeKeys
    ) external view returns (string[] memory attributes);

    function getUintAttribute(
        address collection,
        uint256 tokenId,
        string memory key
    ) external view returns (uint256 attribute);

    function getUintAttributes(
        address[] memory collections,
        uint256[] memory tokenIds,
        string[] memory attributeKeys
    ) external view returns (uint256[] memory attributes);

    function isCollaborator(address collaborator, address collection)
        external
        view
        returns (bool isCollaborator_);

    function isSpecificAddress(
        address specificAddress,
        address collection,
        string memory key
    ) external view returns (bool isSpecificAddress_);

    function manageAccessControl(
        address collection,
        string memory key,
        uint8 accessType,
        address specificAddress
    ) external;

    function manageCollaborators(
        address collection,
        address[] memory collaboratorAddresses,
        bool[] memory collaboratorAddressAccess
    ) external;

    function prepareMessageToPresignAddressAttribute(
        address collection,
        uint256 tokenId,
        string memory key,
        address value,
        uint256 deadline
    ) external view returns (bytes32 message);

    function prepareMessageToPresignBoolAttribute(
        address collection,
        uint256 tokenId,
        string memory key,
        bool value,
        uint256 deadline
    ) external view returns (bytes32 message);

    function prepareMessageToPresignBytesAttribute(
        address collection,
        uint256 tokenId,
        string memory key,
        bytes memory value,
        uint256 deadline
    ) external view returns (bytes32 message);

    function prepareMessageToPresignIntAttribute(
        address collection,
        uint256 tokenId,
        string memory key,
        int256 value,
        uint256 deadline
    ) external view returns (bytes32 message);

    function prepareMessageToPresignStringAttribute(
        address collection,
        uint256 tokenId,
        string memory key,
        string memory value,
        uint256 deadline
    ) external view returns (bytes32 message);

    function prepareMessageToPresignUintAttribute(
        address collection,
        uint256 tokenId,
        string memory key,
        uint256 value,
        uint256 deadline
    ) external view returns (bytes32 message);

    function presignedSetAddressAttribute(
        address setter,
        address collection,
        uint256 tokenId,
        string memory key,
        address value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    function presignedSetBoolAttribute(
        address setter,
        address collection,
        uint256 tokenId,
        string memory key,
        bool value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    function presignedSetBytesAttribute(
        address setter,
        address collection,
        uint256 tokenId,
        string memory key,
        bytes memory value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    function presignedSetIntAttribute(
        address setter,
        address collection,
        uint256 tokenId,
        string memory key,
        int256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    function presignedSetStringAttribute(
        address setter,
        address collection,
        uint256 tokenId,
        string memory key,
        string memory value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    function presignedSetUintAttribute(
        address setter,
        address collection,
        uint256 tokenId,
        string memory key,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    function registerAccessControl(
        address collection,
        address owner,
        bool useOwnable
    ) external;

    function setAddressAttribute(
        address collection,
        uint256 tokenId,
        string memory key,
        address value
    ) external;

    function setAddressAttributes(
        address[] memory collections,
        uint256[] memory tokenIds,
        IERC7508.AddressAttribute[] memory attributes
    ) external;

    function setAttributes(
        address collection,
        uint256 tokenId,
        IERC7508.AddressAttribute[] memory addressAttributes,
        IERC7508.BoolAttribute[] memory boolAttributes,
        IERC7508.BytesAttribute[] memory bytesAttributes,
        IERC7508.IntAttribute[] memory intAttributes,
        IERC7508.StringAttribute[] memory stringAttributes,
        IERC7508.UintAttribute[] memory uintAttributes
    ) external;

    function setAttributesMetadataURIForCollection(
        address collection,
        string memory attributesMetadataURI
    ) external;

    function setBoolAttribute(
        address collection,
        uint256 tokenId,
        string memory key,
        bool value
    ) external;

    function setBoolAttributes(
        address[] memory collections,
        uint256[] memory tokenIds,
        IERC7508.BoolAttribute[] memory attributes
    ) external;

    function setBytesAttribute(
        address collection,
        uint256 tokenId,
        string memory key,
        bytes memory value
    ) external;

    function setBytesAttributes(
        address[] memory collections,
        uint256[] memory tokenIds,
        IERC7508.BytesAttribute[] memory attributes
    ) external;

    function setIntAttribute(
        address collection,
        uint256 tokenId,
        string memory key,
        int256 value
    ) external;

    function setIntAttributes(
        address[] memory collections,
        uint256[] memory tokenIds,
        IERC7508.IntAttribute[] memory attributes
    ) external;

    function setStringAttribute(
        address collection,
        uint256 tokenId,
        string memory key,
        string memory value
    ) external;

    function setStringAttributes(
        address[] memory collections,
        uint256[] memory tokenIds,
        IERC7508.StringAttribute[] memory attributes
    ) external;

    function setUintAttribute(
        address collection,
        uint256 tokenId,
        string memory key,
        uint256 value
    ) external;

    function setUintAttributes(
        address[] memory collections,
        uint256[] memory tokenIds,
        IERC7508.UintAttribute[] memory attributes
    ) external;

    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

interface IERC7508 {
    struct AddressAttribute {
        string key;
        address value;
    }

    struct BoolAttribute {
        string key;
        bool value;
    }

    struct BytesAttribute {
        string key;
        bytes value;
    }

    struct IntAttribute {
        string key;
        int256 value;
    }

    struct StringAttribute {
        string key;
        string value;
    }

    struct UintAttribute {
        string key;
        uint256 value;
    }
}



================================================
FILE: contracts/opensea/IConduit.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IConduit
 * @notice Interface for OpenSea's Conduit contracts that enable transferring approved tokens
 * @dev Conduits are deployed by the ConduitController and can transfer ERC20/721/1155 tokens
 * @custom:address Contract addresses are generated dynamically based on the conduit key
 * @custom:tags opensea,nft,marketplace,conduit
 */
interface IConduit {
    /**
     * @notice Item type identifiers for ERC20, ERC721, and ERC1155
     */
    enum ItemType {
        ERC20,
        ERC721,
        ERC1155,
        NATIVE
    }
    
    /**
     * @notice An item that can be transferred
     */
    struct TransferItem {
        ItemType itemType;     // The type of item
        address token;         // The token contract
        address from;          // The originator of the transfer
        address to;            // The recipient of the transfer
        uint256 identifier;    // The tokenId (for ERC721 and ERC1155)
        uint256 amount;        // The amount to transfer (for ERC20 and ERC1155)
    }
    
    /**
     * @notice Execute multiple transfers in a single call
     * @dev Only callable by an open channel on the conduit
     * @param transferItems Array of TransferItem structs containing transfer data
     */
    function execute(TransferItem[] calldata transferItems) external;
    
    /**
     * @notice Execute a batch ERC1155 token transfer (safeTransferFrom)
     * @dev Only callable by an open channel on the conduit
     * @param token The ERC1155 token contract address
     * @param from The address to transfer tokens from
     * @param to The address to transfer tokens to
     * @param ids Array of token IDs to transfer
     * @param amounts Array of amounts to transfer for each token ID
     */
    function executeBatch1155(
        address token,
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts
    ) external;
    
    /**
     * @notice Update a channel's status
     * @dev Only callable by the associated conduit controller
     * @param channel The channel to update
     * @param isOpen The new status of the channel (open or closed)
     */
    function updateChannel(address channel, bool isOpen) external;
} 


================================================
FILE: contracts/opensea/IConduitController.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IConduitController
 * @notice Interface for OpenSea's Conduit Controller system that enables deploying and managing conduits
 * @dev Conduits allow registered callers (channels) to transfer approved ERC20/721/1155 tokens on their behalf
 * @custom:katana 0x00000000F9490004C11Cef243f5400493c00Ad63
 * @custom:bokuto 0x00000000F9490004C11Cef243f5400493c00Ad63
 * @custom:tags opensea,nft,marketplace,conduit,controller
 */
interface IConduitController {
    /**
     * @notice Properties of a conduit
     */
    struct ConduitProperties {
        address owner;       // Current owner of the conduit
        address potentialOwner;  // Potential owner that can accept ownership
        bytes32 conduitKey;  // The conduit key used to deploy the conduit
        uint256 totalChannels;   // The total number of open channels for the conduit
        mapping(address => bool) channels;  // Mapping of channels to their status
        address[] channelsList;  // Array of open channels
    }

    /**
     * @notice Deploy a new conduit using a supplied conduit key and assigning an initial owner for the deployed conduit
     * @dev The first twenty bytes of the supplied conduit key must match the caller
     * @param conduitKey The conduit key used to deploy the conduit
     * @param initialOwner The initial owner to set for the new conduit
     * @return conduit The address of the newly deployed conduit
     */
    function createConduit(
        bytes32 conduitKey,
        address initialOwner
    ) external returns (address conduit);

    /**
     * @notice Open or close a channel on a given conduit
     * @dev Only the owner of the conduit may call this function
     * @param conduit The conduit for which to open or close the channel
     * @param channel The channel to open or close on the conduit
     * @param isOpen A boolean indicating whether to open or close the channel
     */
    function updateChannel(
        address conduit,
        address channel,
        bool isOpen
    ) external;

    /**
     * @notice Initiate conduit ownership transfer
     * @dev Only the owner of the conduit may call this function
     * @param conduit The conduit for which to initiate ownership transfer
     * @param newPotentialOwner The new potential owner of the conduit
     */
    function transferOwnership(
        address conduit,
        address newPotentialOwner
    ) external;

    /**
     * @notice Clear the currently set potential owner from a conduit
     * @dev Only the owner of the conduit may call this function
     * @param conduit The conduit for which to cancel ownership transfer
     */
    function cancelOwnershipTransfer(address conduit) external;

    /**
     * @notice Accept ownership of a supplied conduit
     * @dev Only accounts that the current owner has set as the new potential owner may call this function
     * @param conduit The conduit for which to accept ownership
     */
    function acceptOwnership(address conduit) external;

    /**
     * @notice Retrieve the current owner of a deployed conduit
     * @param conduit The conduit for which to retrieve the associated owner
     * @return owner The owner of the supplied conduit
     */
    function ownerOf(address conduit) external view returns (address owner);

    /**
     * @notice Retrieve the conduit key for a deployed conduit via reverse lookup
     * @param conduit The conduit for which to retrieve the associated conduit key
     * @return conduitKey The conduit key used to deploy the supplied conduit
     */
    function getKey(address conduit) external view returns (bytes32 conduitKey);

    /**
     * @notice Derive the conduit associated with a given conduit key and determine whether that conduit exists
     * @param conduitKey The conduit key used to derive the conduit
     * @return conduit The derived address of the conduit
     * @return exists A boolean indicating whether the derived conduit has been deployed or not
     */
    function getConduit(bytes32 conduitKey) external view returns (
        address conduit,
        bool exists
    );

    /**
     * @notice Retrieve the potential owner, if any, for a given conduit
     * @param conduit The conduit for which to retrieve the potential owner
     * @return potentialOwner The potential owner, if any, for the conduit
     */
    function getPotentialOwner(address conduit) external view returns (address potentialOwner);

    /**
     * @notice Retrieve the status (either open or closed) of a given channel on a conduit
     * @param conduit The conduit for which to retrieve the channel status
     * @param channel The channel for which to retrieve the status
     * @return isOpen The status of the channel on the given conduit
     */
    function getChannelStatus(
        address conduit,
        address channel
    ) external view returns (bool isOpen);

    /**
     * @notice Retrieve the total number of open channels for a given conduit
     * @param conduit The conduit for which to retrieve the total channel count
     * @return totalChannels The total number of open channels for the conduit
     */
    function getTotalChannels(address conduit) external view returns (uint256 totalChannels);

    /**
     * @notice Retrieve an open channel at a specific index for a given conduit
     * @dev The index of a channel can change as a result of other channels being closed on the conduit
     * @param conduit The conduit for which to retrieve the open channel
     * @param channelIndex The index of the channel in question
     * @return channel The open channel, if any, at the specified channel index
     */
    function getChannel(
        address conduit,
        uint256 channelIndex
    ) external view returns (address channel);

    /**
     * @notice Retrieve all open channels for a given conduit
     * @dev This function may revert with an out-of-gas error for conduits with many channels
     * @param conduit The conduit for which to retrieve open channels
     * @return channels An array of open channels on the given conduit
     */
    function getChannels(address conduit) external view returns (address[] memory channels);

    /**
     * @notice Retrieve the conduit creation code and runtime code hashes
     * @return creationCodeHash The hash of the creation code
     * @return runtimeCodeHash The hash of the runtime code
     */
    function getConduitCodeHashes() external view returns (
        bytes32 creationCodeHash,
        bytes32 runtimeCodeHash
    );
} 


================================================
FILE: contracts/opensea/ISeaport.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title ISeaport
 * @notice Interface for OpenSea's Seaport 1.6 marketplace protocol
 * @dev This interface contains the main functions for interacting with the marketplace
 * @custom:katana 0x0000000000000068F116a894984e2DB1123eB395
 * @custom:bokuto 0x0000000000000068F116a894984e2DB1123eB395
 * @custom:tags opensea,nft,marketplace,seaport
 */
interface ISeaport {
    /**
     * @notice Types of items supported by Seaport
     */
    enum ItemType {
        NATIVE,                    // Native token (e.g., ETH)
        ERC20,                     // ERC20 token
        ERC721,                    // ERC721 token
        ERC1155,                   // ERC1155 token
        ERC721_WITH_CRITERIA,      // ERC721 with criteria (multiple possible tokens)
        ERC1155_WITH_CRITERIA      // ERC1155 with criteria (multiple possible tokens)
    }

    /**
     * @notice Types of orders in Seaport
     */
    enum OrderType {
        FULL_OPEN,                // No restrictions
        PARTIAL_OPEN,             // Partial fills allowed
        FULL_RESTRICTED,          // Restricted to zone
        PARTIAL_RESTRICTED        // Partial fills allowed, restricted to zone
    }

    /**
     * @notice Contains spent items for offer or consideration
     */
    struct SpentItem {
        ItemType itemType;         // The type of item (ERC20/721/1155/Native)
        address token;             // The token address
        uint256 identifier;        // The token identifier (or criteria)
        uint256 amount;            // The amount of the token to transfer
    }

    /**
     * @notice Contains received items for consideration
     */
    struct ReceivedItem {
        ItemType itemType;         // The type of item (ERC20/721/1155/Native)
        address token;             // The token address
        uint256 identifier;        // The token identifier (or criteria)
        uint256 amount;            // The amount of the token to transfer
        address payable recipient; // The recipient of the item
    }
    
    /**
     * @notice Additional recipients for basic orders
     */
    struct AdditionalRecipient {
        uint256 amount;
        address payable recipient;
    }

    /**
     * @notice Basic order parameters for a single order
     */
    struct OrderParameters {
        address offerer;           // The order's offerer
        address zone;              // The zone of the order (e.g., for restricted orders)
        SpentItem[] offer;         // The offer items
        ReceivedItem[] consideration; // The consideration items
        OrderType orderType;       // The type of order
        uint256 startTime;         // The order start time
        uint256 endTime;           // The order end time
        bytes32 zoneHash;          // The hash for the zone
        uint256 salt;              // Random value for uniqueness
        bytes32 conduitKey;        // The conduit key if using a conduit
        uint256 totalOriginalConsiderationItems; // The total number of original consideration items
    }
    
    /**
     * @notice Order with parameters and signature
     */
    struct Order {
        OrderParameters parameters;
        bytes signature;
    }
    
    /**
     * @notice Components needed for order creation
     */
    struct OrderComponents {
        address offerer;
        address zone;
        SpentItem[] offer;
        ReceivedItem[] consideration;
        OrderType orderType;
        uint256 startTime;
        uint256 endTime;
        bytes32 zoneHash;
        uint256 salt;
        bytes32 conduitKey;
        uint256 counter;
    }

    /**
     * @notice Parameters for fulfilling a basic order
     */
    struct BasicOrderParameters {
        address considerationToken;
        uint256 considerationIdentifier;
        uint256 considerationAmount;
        address payable offerer;
        address zone;
        address offerToken;
        uint256 offerIdentifier;
        uint256 offerAmount;
        uint8 basicOrderType;
        uint256 startTime;
        uint256 endTime;
        bytes32 zoneHash;
        uint256 salt;
        bytes32 offererConduitKey;
        bytes32 fulfillerConduitKey;
        uint256 totalOriginalAdditionalRecipients;
        AdditionalRecipient[] additionalRecipients;
        bytes signature;
    }

    /**
     * @notice Advanced order parameters with numerator/denominator for partial fills
     */
    struct AdvancedOrder {
        OrderParameters parameters; // The order parameters
        uint120 numerator;         // The numerator for partial fills
        uint120 denominator;       // The denominator for partial fills
        bytes signature;           // The signature of the order
        bytes extraData;           // Extra data supplied with order
    }

    /**
     * @notice For resolving criteria-based orders
     */
    struct CriteriaResolver {
        uint256 orderIndex;        // The index of the order
        uint256 side;              // 0 for offer, 1 for consideration
        uint256 index;             // The index of the item in the offer/consideration
        uint256 identifier;        // The actual token identifier
        bytes32[] criteriaProof;   // Merkle proof for criteria-based items
    }

    /**
     * @notice Component for fulfillment
     */
    struct FulfillmentComponent {
        uint256 orderIndex;        // The index of the order
        uint256 itemIndex;         // The index of the item in the order
    }

    /**
     * @notice Order fulfillment data
     */
    struct Fulfillment {
        FulfillmentComponent[] offerComponents;      // Components for the offer items
        FulfillmentComponent[] considerationComponents; // Components for the consideration items
    }

    /**
     * @notice Execution data for fulfillment
     */
    struct Execution {
        ReceivedItem item;         // The received item
        address offerer;           // The offerer of the item
        bytes32 conduitKey;        // The conduit key
    }

    // Events
    event OrderFulfilled(
        bytes32 orderHash,
        address indexed offerer,
        address indexed zone,
        address fulfiller,
        SpentItem[] offer,
        ReceivedItem[] consideration
    );

    event OrderCancelled(
        bytes32 orderHash,
        address indexed offerer,
        address indexed zone
    );

    event OrdersMatched(bytes32[] orderHashes);

    event CounterIncremented(
        address indexed offerer, 
        uint256 newCounter
    );

    /**
     * @notice Fulfill an order offering an ERC721 token
     * @param parameters The parameters for fulfilling a basic order
     * @return fulfilled Boolean indicating whether the order was fulfilled
     */
    function fulfillBasicOrder(
        BasicOrderParameters calldata parameters
    ) external payable returns (bool fulfilled);

    /**
     * @notice Fulfill a single order
     * @param order The order to fulfill
     * @param fulfillerConduitKey The conduitKey for the fulfiller
     * @return fulfilled Boolean indicating whether the order was fulfilled
     */
    function fulfillOrder(
        Order calldata order,
        bytes32 fulfillerConduitKey
    ) external payable returns (bool fulfilled);

    /**
     * @notice Fulfill an advanced order with criteria resolution
     * @param advancedOrder The advanced order to fulfill
     * @param criteriaResolvers Array of criteria resolvers
     * @param fulfillerConduitKey The conduitKey for the fulfiller
     * @param recipient The intended recipient for all received items
     * @return fulfilled Boolean indicating whether the order was fulfilled
     */
    function fulfillAdvancedOrder(
        AdvancedOrder calldata advancedOrder,
        CriteriaResolver[] calldata criteriaResolvers,
        bytes32 fulfillerConduitKey,
        address recipient
    ) external payable returns (bool fulfilled);

    /**
     * @notice Fulfill multiple available orders
     * @param orders The orders to fulfill
     * @param offerFulfillments Array of offer fulfillment components
     * @param considerationFulfillments Array of consideration fulfillment components
     * @param fulfillerConduitKey The conduitKey for the fulfiller
     * @param maximumFulfilled The maximum number of orders to fulfill
     * @return availableOrders Boolean array indicating which orders were fulfillable
     * @return executions The executions performed
     */
    function fulfillAvailableOrders(
        Order[] calldata orders,
        FulfillmentComponent[][] calldata offerFulfillments,
        FulfillmentComponent[][] calldata considerationFulfillments,
        bytes32 fulfillerConduitKey,
        uint256 maximumFulfilled
    ) external payable returns (bool[] memory availableOrders, Execution[] memory executions);

    /**
     * @notice Fulfill multiple available advanced orders
     * @param advancedOrders The advanced orders to fulfill
     * @param criteriaResolvers Array of criteria resolvers
     * @param offerFulfillments Array of offer fulfillment components
     * @param considerationFulfillments Array of consideration fulfillment components
     * @param fulfillerConduitKey The conduitKey for the fulfiller
     * @param recipient The intended recipient for all received items
     * @param maximumFulfilled The maximum number of orders to fulfill
     * @return availableOrders Boolean array indicating which orders were fulfillable
     * @return executions The executions performed
     */
    function fulfillAvailableAdvancedOrders(
        AdvancedOrder[] calldata advancedOrders,
        CriteriaResolver[] calldata criteriaResolvers,
        FulfillmentComponent[][] calldata offerFulfillments,
        FulfillmentComponent[][] calldata considerationFulfillments,
        bytes32 fulfillerConduitKey,
        address recipient,
        uint256 maximumFulfilled
    ) external payable returns (bool[] memory availableOrders, Execution[] memory executions);

    /**
     * @notice Match orders together (e.g., for bartering)
     * @param orders The orders to match
     * @param fulfillments The fulfillments to execute
     * @return executions The executions performed
     */
    function matchOrders(
        Order[] calldata orders,
        Fulfillment[] calldata fulfillments
    ) external payable returns (Execution[] memory executions);

    /**
     * @notice Match advanced orders with criteria resolution
     * @param advancedOrders The advanced orders to match
     * @param criteriaResolvers Array of criteria resolvers
     * @param fulfillments The fulfillments to execute
     * @param recipient The intended recipient for all unspent offer items
     * @return executions The executions performed
     */
    function matchAdvancedOrders(
        AdvancedOrder[] calldata advancedOrders,
        CriteriaResolver[] calldata criteriaResolvers,
        Fulfillment[] calldata fulfillments,
        address recipient
    ) external payable returns (Execution[] memory executions);

    /**
     * @notice Cancel multiple orders
     * @param orders The order parameters to cancel
     * @return cancelled Boolean indicating whether the orders were cancelled
     */
    function cancel(
        OrderComponents[] calldata orders
    ) external returns (bool cancelled);

    /**
     * @notice Validate an order, marking it as valid if the signature is valid
     * @param orders The orders to validate
     * @return validated Boolean indicating whether the orders were validated
     */
    function validate(
        Order[] calldata orders
    ) external returns (bool validated);

    /**
     * @notice Increment the counter for the caller, invalidating all orders with the previous counter
     * @return newCounter The new counter
     */
    function incrementCounter() external returns (uint256 newCounter);

    /**
     * @notice Get the current counter for a given offerer
     * @param offerer The offerer to get the counter for
     * @return counter The current counter
     */
    function getCounter(address offerer) external view returns (uint256 counter);

    /**
     * @notice Get information about an order
     * @param orderHash The order hash to query
     * @return isValidated Whether the order has been validated
     * @return isCancelled Whether the order has been cancelled
     * @return totalFilled The amount of the order that has been filled
     * @return totalSize The total size of the order
     */
    function getOrderStatus(bytes32 orderHash) external view returns (
        bool isValidated,
        bool isCancelled,
        uint256 totalFilled,
        uint256 totalSize
    );

    /**
     * @notice Get the order hash for a given order parameters
     * @param order The order parameters
     * @return orderHash The order hash
     */
    function getOrderHash(OrderParameters calldata order) external view returns (bytes32 orderHash);

    /**
     * @notice Get the domain separator used for signatures
     * @return domainSeparator The domain separator
     */
    function getDomainSeparator() external view returns (bytes32 domainSeparator);
    
    /**
     * @notice Retrieve configuration information for this contract
     * @return version The contract version
     * @return domainSeparator The domain separator for this contract
     * @return conduitController The conduit Controller set for this contract
     */
    function information() external view returns (
        string memory version,
        bytes32 domainSeparator,
        address conduitController
    );
    
    /**
     * @notice Retrieve the name of this contract
     * @return contractName The name of this contract
     */
    function name() external view returns (string memory contractName);
} 


================================================
FILE: contracts/oracles/chainlink/IAggregatorV3Interface.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IAggregatorV3Interface
 * @notice Interface for Chainlink price feed aggregators
 * @dev From Chainlink's AggregatorV3Interface
 * @custom:tags oracle,chainlink,price-feed,standard
 */
interface IAggregatorV3Interface {
    /**
     * @notice Get the decimals for this aggregator's answer
     * @return The number of decimals
     */
    function decimals() external view returns (uint8);

    /**
     * @notice Get the description of this aggregator
     * @return The description string
     */
    function description() external view returns (string memory);

    /**
     * @notice Get the version of this aggregator
     * @return The version number
     */
    function version() external view returns (uint256);

    /**
     * @notice Get data about a specific round
     * @param _roundId The round ID to retrieve
     * @return roundId The round ID
     * @return answer The price answer
     * @return startedAt The timestamp when the round started
     * @return updatedAt The timestamp when the round was updated
     * @return answeredInRound The round in which the answer was computed
     */
    function getRoundData(uint80 _roundId)
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );

    /**
     * @notice Get data about the latest round
     * @return roundId The round ID
     * @return answer The price answer
     * @return startedAt The timestamp when the round started
     * @return updatedAt The timestamp when the round was updated
     * @return answeredInRound The round in which the answer was computed
     */
    function latestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );
} 


================================================
FILE: contracts/oracles/chainlink/IAUSDUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEACAggregatorProxy.sol";

/**
 * @title IAUSDUSDOracle
 * @notice Interface for AUSD/USD Chainlink price oracle on Katana
 * @dev Extends the EAC Aggregator Proxy interface for price feeds
 * @custom:katana 0x3A49D4e23868222785f148BA2bd0bAEc80d36a2A
 * @custom:tags oracle,chainlink,price-feed,ausd,usd
 */
interface IAUSDUSDOracle is IEACAggregatorProxy {

}


================================================
FILE: contracts/oracles/chainlink/IBTCUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEACAggregatorProxy.sol";

/**
 * @title IBTCUSDOracle
 * @notice Interface for BTC/USD Chainlink price oracle on Katana
 * @dev Extends the EAC Aggregator Proxy interface for price feeds
 * @custom:katana 0x41DdB7F8F5e1b2bD28193B84C1C36Be698dEd162
 * @custom:tags oracle,chainlink,price-feed,btc,usd
 */
interface IBTCUSDOracle is IEACAggregatorProxy {

}


================================================
FILE: contracts/oracles/chainlink/IEACAggregatorProxy.sol
================================================
// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity ^0.8.20;

/**
 * @title IEACAggregatorProxy
 * @notice Base interface for Chainlink EAC Aggregator Proxy contracts
 * @dev Extended interface for Chainlink price feed proxies
 * @custom:tags oracle,chainlink,price-feed,proxy
 */
interface IEACAggregatorProxy {
    event AnswerUpdated(
        int256 indexed current,
        uint256 indexed roundId,
        uint256 updatedAt
    );
    event NewRound(
        uint256 indexed roundId,
        address indexed startedBy,
        uint256 startedAt
    );
    event OwnershipTransferRequested(address indexed from, address indexed to);
    event OwnershipTransferred(address indexed from, address indexed to);

    function acceptOwnership() external;

    function accessController() external view returns (address);

    function aggregator() external view returns (address);

    function confirmAggregator(address _aggregator) external;

    function decimals() external view returns (uint8);

    function description() external view returns (string memory);

    function getAnswer(uint256 _roundId) external view returns (int256);

    function getRoundData(uint80 _roundId)
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );

    function getTimestamp(uint256 _roundId) external view returns (uint256);

    function latestAnswer() external view returns (int256);

    function latestRound() external view returns (uint256);

    function latestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );

    function latestTimestamp() external view returns (uint256);

    function owner() external view returns (address);

    function phaseAggregators(uint16) external view returns (address);

    function phaseId() external view returns (uint16);

    function proposeAggregator(address _aggregator) external;

    function proposedAggregator() external view returns (address);

    function proposedGetRoundData(uint80 _roundId)
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );

    function proposedLatestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );

    function setController(address _accessController) external;

    function transferOwnership(address _to) external;

    function version() external view returns (uint256);
}


================================================
FILE: contracts/oracles/chainlink/IETHUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEACAggregatorProxy.sol";

/**
 * @title IETHUSDOracle
 * @notice Interface for ETH/USD Chainlink price oracle on Katana
 * @dev Extends the EAC Aggregator Proxy interface for price feeds
 * @custom:katana 0x7BdBDB772f4a073BadD676A567C6ED82049a8eEE
 * @custom:tags oracle,chainlink,price-feed,eth,usd
 */
interface IETHUSDOracle is IEACAggregatorProxy {

}


================================================
FILE: contracts/oracles/chainlink/IJitoSOLSOLOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEACAggregatorProxy.sol";

/**
 * @title IJitoSOLSOLOracle
 * @notice Interface for jitoSOL/SOL Chainlink price oracle on Katana
 * @dev Extends the EAC Aggregator Proxy interface for price feeds
 * @custom:katana 0x1C0a310cf42F357087Be122e69ee402D19A265dC
 * @custom:tags oracle,chainlink,price-feed,jitosol,sol
 */
interface IJitoSOLSOLOracle is IEACAggregatorProxy {

}


================================================
FILE: contracts/oracles/chainlink/IJitoSOLUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEACAggregatorProxy.sol";

/**
 * @title IJitoSOLUSDOracle
 * @notice Interface for jitoSOL/USD Chainlink price oracle on Katana
 * @dev Extends the EAC Aggregator Proxy interface for price feeds
 * @custom:katana 0x36E03469335b7F2eF51aAeB914b76c038645679A
 * @custom:tags oracle,chainlink,price-feed,jitosol,usd
 */
interface IJitoSOLUSDOracle is IEACAggregatorProxy {

}


================================================
FILE: contracts/oracles/chainlink/ILBTCBTCOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEACAggregatorProxy.sol";

/**
 * @title ILBTCBTCOracle
 * @notice Interface for LBTC/BTC Chainlink price oracle on Katana
 * @dev Extends the EAC Aggregator Proxy interface for price feeds
 * @custom:katana 0x6830BfE63F8804B4972D92826b9088d2fb6AFe5b
 * @custom:tags oracle,chainlink,price-feed,lbtc,btc
 */
interface ILBTCBTCOracle is IEACAggregatorProxy {

}


================================================
FILE: contracts/oracles/chainlink/ILBTCUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEACAggregatorProxy.sol";

/**
 * @title ILBTCUSDOracle
 * @notice Interface for LBTC/USD Chainlink price oracle on Katana
 * @dev Extends the EAC Aggregator Proxy interface for price feeds
 * @custom:katana 0x5C2c6A77310C7750fCc5c3f13a3f9C3b18a68d3e
 * @custom:tags oracle,chainlink,price-feed,lbtc,usd
 */
interface ILBTCUSDOracle is IEACAggregatorProxy {

}


================================================
FILE: contracts/oracles/chainlink/ILINKUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEACAggregatorProxy.sol";

/**
 * @title ILINKUSDOracle
 * @notice Interface for LINK/USD Chainlink price oracle on Katana
 * @dev Extends the EAC Aggregator Proxy interface for price feeds
 * @custom:katana 0x06bD6464e94Bee9393Ae15B5Dd5eCDFAa4F299C1
 * @custom:tags oracle,chainlink,price-feed,link,usd
 */
interface ILINKUSDOracle is IEACAggregatorProxy {

}


================================================
FILE: contracts/oracles/chainlink/IMORPHOUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEACAggregatorProxy.sol";

/**
 * @title IMORPHOUSDOracle
 * @notice Interface for MORPHO/USD Chainlink price oracle on Katana
 * @dev Extends the EAC Aggregator Proxy interface for price feeds
 * @custom:katana 0xdFd824A5Dcad8667142d58FE4aF115d5d052f26c
 * @custom:tags oracle,chainlink,price-feed,morpho,usd
 */
interface IMORPHOUSDOracle is IEACAggregatorProxy {

}


================================================
FILE: contracts/oracles/chainlink/IPOLUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEACAggregatorProxy.sol";

/**
 * @title IPOLUSDOracle
 * @notice Interface for POL/USD Chainlink price oracle on Katana
 * @dev Extends the EAC Aggregator Proxy interface for price feeds
 * @custom:katana 0xF6630799b5387e0E9ACe92a5E82673021781B440
 * @custom:tags oracle,chainlink,price-feed,pol,usd
 */
interface IPOLUSDOracle is IEACAggregatorProxy {

}


================================================
FILE: contracts/oracles/chainlink/ISOLUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEACAggregatorProxy.sol";

/**
 * @title ISOLUSDOracle
 * @notice Interface for SOL/USD Chainlink price oracle on Katana
 * @dev Extends the EAC Aggregator Proxy interface for price feeds
 * @custom:katana 0x709c4dc298322916eaE59bfdc2e3d750B55C864B
 * @custom:tags oracle,chainlink,price-feed,sol,usd
 */
interface ISOLUSDOracle is IEACAggregatorProxy {

}


================================================
FILE: contracts/oracles/chainlink/ISUSHIUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEACAggregatorProxy.sol";

/**
 * @title ISUSHIUSDOracle
 * @notice Interface for SUSHI/USD Chainlink price oracle on Katana
 * @dev Extends the EAC Aggregator Proxy interface for price feeds
 * @custom:katana 0xA30C356781E5e1b455b274cdDe524FB7BF3809da
 * @custom:tags oracle,chainlink,price-feed,sushi,usd
 */
interface ISUSHIUSDOracle is IEACAggregatorProxy {

}


================================================
FILE: contracts/oracles/chainlink/IUSDCUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEACAggregatorProxy.sol";

/**
 * @title IUSDCUSDOracle
 * @notice Interface for USDC/USD Chainlink price oracle on Katana
 * @dev Extends the EAC Aggregator Proxy interface for price feeds
 * @custom:katana 0xbe5CE90e16B9d9d988D64b0E1f6ed46EbAfb9606
 * @custom:tags oracle,chainlink,price-feed,usdc,usd
 */
interface IUSDCUSDOracle is IEACAggregatorProxy {

}


================================================
FILE: contracts/oracles/chainlink/IUSDSUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEACAggregatorProxy.sol";

/**
 * @title IUSDSUSDOracle
 * @notice Interface for USDS/USD Chainlink price oracle on Katana
 * @dev Extends the EAC Aggregator Proxy interface for price feeds
 * @custom:katana 0x44cdCd6F81cEe5BAC68B21845Fc82846ee09A369
 * @custom:tags oracle,chainlink,price-feed,usds,usd
 */
interface IUSDSUSDOracle is IEACAggregatorProxy {

}


================================================
FILE: contracts/oracles/chainlink/IUSDTUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEACAggregatorProxy.sol";

/**
 * @title IUSDTUSDOracle
 * @notice Interface for USDT/USD Chainlink price oracle on Katana
 * @dev Extends the EAC Aggregator Proxy interface for price feeds
 * @custom:katana 0xF03E1566Fc6B0eBFA3dD3aA197759C4c6617ec78
 * @custom:tags oracle,chainlink,price-feed,usdt,usd
 */
interface IUSDTUSDOracle is IEACAggregatorProxy {

}


================================================
FILE: contracts/oracles/chainlink/IWBTCBTCOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEACAggregatorProxy.sol";

/**
 * @title IWBTCBTCOracle
 * @notice Interface for WBTC/BTC Chainlink price oracle on Katana
 * @dev Extends the EAC Aggregator Proxy interface for price feeds
 * @custom:katana 0xAd2937e7D25c237856B03319265465C0291b1895
 * @custom:tags oracle,chainlink,price-feed,wbtc,btc
 */
interface IWBTCBTCOracle is IEACAggregatorProxy {

}


================================================
FILE: contracts/oracles/chainlink/IWBTCUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEACAggregatorProxy.sol";

/**
 * @title IWBTCUSDOracle
 * @notice Interface for WBTC/USD Chainlink price oracle on Katana
 * @dev Extends the EAC Aggregator Proxy interface for price feeds
 * @custom:katana 0x0D03E26E0B5D09E24E5a45696D0FcA12E9648FBB
 * @custom:tags oracle,chainlink,price-feed,wbtc,usd
 */
interface IWBTCUSDOracle is IEACAggregatorProxy {

}


================================================
FILE: contracts/oracles/chainlink/IweETHETHOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEACAggregatorProxy.sol";

/**
 * @title IweETHETHOracle
 * @notice Interface for weETH/ETH Chainlink price oracle on Katana
 * @dev Extends the EAC Aggregator Proxy interface for price feeds
 * @custom:katana 0x3Eae75C0a2f9b1038C7c9993C1Da36281E838811
 * @custom:tags oracle,chainlink,price-feed,weeth,eth
 */
interface IweETHETHOracle is IEACAggregatorProxy {

}


================================================
FILE: contracts/oracles/chainlink/IwstETHETHOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEACAggregatorProxy.sol";

/**
 * @title IwstETHETHOracle
 * @notice Interface for wstETH/ETH Chainlink price oracle on Katana
 * @dev Extends the EAC Aggregator Proxy interface for price feeds
 * @custom:katana 0xCB568C33EA2B0B81852655d722E3a52d9D44e7De
 * @custom:tags oracle,chainlink,price-feed,wsteth,eth
 */
interface IwstETHETHOracle is IEACAggregatorProxy {

}


================================================
FILE: contracts/oracles/chainlink/IYFIUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEACAggregatorProxy.sol";

/**
 * @title IYFIUSDOracle
 * @notice Interface for YFI/USD Chainlink price oracle on Katana
 * @dev Extends the EAC Aggregator Proxy interface for price feeds
 * @custom:katana 0xfcDcCF5C2BEAB72FDb910481beaE807F5453686B
 * @custom:tags oracle,chainlink,price-feed,yfi,usd
 */
interface IYFIUSDOracle is IEACAggregatorProxy {

}


================================================
FILE: contracts/oracles/chainlink/IyUSDUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IEACAggregatorProxy.sol";

/**
 * @title IyUSDUSDOracle
 * @notice Interface for yUSD/USD Chainlink price oracle on Katana
 * @dev Extends the EAC Aggregator Proxy interface for price feeds
 * @custom:katana 0xe61b585418B92917771c89D4d3957707cfFE6154
 * @custom:tags oracle,chainlink,price-feed,yusd,usd
 */
interface IyUSDUSDOracle is IEACAggregatorProxy {

}


================================================
FILE: contracts/oracles/redstone/IADAUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IRedstoneAggregator.sol";

/**
 * @title IADAUSDOracle
 * @notice Interface for ADA/USD RedStone price oracle on Katana
 * @dev Extends the RedStone Aggregator interface for price feeds
 * @custom:katana 0xf1454949C6dEdfb500ae63Aa6c784Aa1Dde08A6c
 * @custom:tags oracle,redstone,price-feed,ada,usd
 */
interface IADAUSDOracle is IRedstoneAggregator {

}


================================================
FILE: contracts/oracles/redstone/IAUSDUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IRedstoneAggregator.sol";

/**
 * @title IAUSDUSDOracle
 * @notice Interface for AUSD/USD RedStone price oracle on Katana
 * @dev Extends the RedStone Aggregator interface for price feeds
 * @custom:katana 0x53bB139e962ee0AC6477F40D0352e8dAF0480b70
 * @custom:tags oracle,redstone,price-feed,ausd,usd
 */
interface IAUSDUSDOracle is IRedstoneAggregator {

}


================================================
FILE: contracts/oracles/redstone/IBTCUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IRedstoneAggregator.sol";

/**
 * @title IBTCUSDOracle
 * @notice Interface for BTC/USD RedStone price oracle on Katana
 * @dev Extends the RedStone Aggregator interface for price feeds
 * @custom:katana 0xb67047eDF6204F4C81333248dA71F8387050790C
 * @custom:tags oracle,redstone,price-feed,btc,usd
 */
interface IBTCUSDOracle is IRedstoneAggregator {

}


================================================
FILE: contracts/oracles/redstone/IETHUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IRedstoneAggregator.sol";

/**
 * @title IETHUSDOracle
 * @notice Interface for ETH/USD RedStone price oracle on Katana
 * @dev Extends the RedStone Aggregator interface for price feeds
 * @custom:katana 0xE94c9f9A1893f23be38A5C0394E46Ac05e8a5f8C
 * @custom:tags oracle,redstone,price-feed,eth,usd
 */
interface IETHUSDOracle is IRedstoneAggregator {

}


================================================
FILE: contracts/oracles/redstone/ILBTCBTCOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IRedstoneAggregator.sol";

/**
 * @title ILBTCBTCOracle
 * @notice Interface for LBTC/BTC RedStone price oracle on Katana
 * @dev Extends the RedStone Aggregator interface for price feeds
 * @custom:katana 0xb9D0073aCb296719C26a8BF156e4b599174fe1d5
 * @custom:tags oracle,redstone,price-feed,lbtc,btc
 */
interface ILBTCBTCOracle is IRedstoneAggregator {

}


================================================
FILE: contracts/oracles/redstone/IRedstoneAggregator.sol
================================================
// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity ^0.8.20;

/**
 * @title IRedstoneAggregator
 * @notice Base interface for RedStone price oracle aggregators
 * @dev Interface for RedStone price feed contracts
 * @custom:tags oracle,redstone,price-feed,aggregator
 */
interface IRedstoneAggregator {
    error GetRoundDataCanBeOnlyCalledWithLatestRound(uint80 requestedRoundId);
    error UnsafeUintToIntConversion(uint256 value);
    event Initialized(uint8 version);

    function decimals() external pure returns (uint8);

    function description() external view returns (string memory);

    function getDataFeedId() external view returns (bytes32);

    function getPriceFeedAdapter() external view returns (address);

    function getRoundData(uint80 requestedRoundId)
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );

    function initialize() external;

    function latestAnswer() external view returns (int256);

    function latestRound() external pure returns (uint80);

    function latestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );

    function version() external pure returns (uint256);
}



================================================
FILE: contracts/oracles/redstone/ISUIUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IRedstoneAggregator.sol";

/**
 * @title ISUIUSDOracle
 * @notice Interface for SUI/USD RedStone price oracle on Katana
 * @dev Extends the RedStone Aggregator interface for price feeds
 * @custom:katana 0x98ECE0D516f891a35278E3186772fb1545b274eB
 * @custom:tags oracle,redstone,price-feed,sui,usd
 */
interface ISUIUSDOracle is IRedstoneAggregator {

}


================================================
FILE: contracts/oracles/redstone/IWBTCUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IRedstoneAggregator.sol";

/**
 * @title IWBTCUSDOracle
 * @notice Interface for WBTC/USD RedStone price oracle on Katana
 * @dev Extends the RedStone Aggregator interface for price feeds
 * @custom:katana 0xE5E307A3aEDf4e8eF60E1bfCc9ccD477dFad93ce
 * @custom:tags oracle,redstone,price-feed,wbtc,usd
 */
interface IWBTCUSDOracle is IRedstoneAggregator {

}


================================================
FILE: contracts/oracles/redstone/IweETHETHOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IRedstoneAggregator.sol";

/**
 * @title IweETHETHOracle
 * @notice Interface for weETH/ETH RedStone price oracle on Katana
 * @dev Extends the RedStone Aggregator interface for price feeds
 * @custom:katana 0xe8D9FbC10e00ecc9f0694617075fDAF657a76FB2
 * @custom:tags oracle,redstone,price-feed,weeth,eth
 */
interface IweETHETHOracle is IRedstoneAggregator {

}


================================================
FILE: contracts/oracles/redstone/IweETHUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IRedstoneAggregator.sol";

/**
 * @title IweETHUSDOracle
 * @notice Interface for weETH/USD RedStone price oracle on Katana
 * @dev Extends the RedStone Aggregator interface for price feeds
 * @custom:katana 0xDd87FD0FD6F68AcB6897d05fCf31F3AB1165a49F
 * @custom:tags oracle,redstone,price-feed,weeth,usd
 */
interface IweETHUSDOracle is IRedstoneAggregator {

}


================================================
FILE: contracts/oracles/redstone/IwstETHstETHOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IRedstoneAggregator.sol";

/**
 * @title IwstETHstETHOracle
 * @notice Interface for wstETH/stETH RedStone price oracle on Katana
 * @dev Extends the RedStone Aggregator interface for price feeds
 * @custom:katana 0x31a36CdF4465ba61ce78F5CDbA26FDF8ec361803
 * @custom:tags oracle,redstone,price-feed,wsteth,steth
 */
interface IwstETHstETHOracle is IRedstoneAggregator {

}


================================================
FILE: contracts/oracles/redstone/IwstETHUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IRedstoneAggregator.sol";

/**
 * @title IwstETHUSDOracle
 * @notice Interface for wstETH/USD RedStone price oracle on Katana
 * @dev Extends the RedStone Aggregator interface for price feeds
 * @custom:katana 0xE23eCA12D7D2ED3829499556F6dCE06642AFd990
 * @custom:tags oracle,redstone,price-feed,wsteth,usd
 */
interface IwstETHUSDOracle is IRedstoneAggregator {

}


================================================
FILE: contracts/oracles/redstone/IXRPUSDOracle.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IRedstoneAggregator.sol";

/**
 * @title IXRPUSDOracle
 * @notice Interface for XRP/USD RedStone price oracle on Katana
 * @dev Extends the RedStone Aggregator interface for price feeds
 * @custom:katana 0xb4fe9028A4D4D8B3d00e52341F2BB0798860532C
 * @custom:tags oracle,redstone,price-feed,xrp,usd
 */
interface IXRPUSDOracle is IRedstoneAggregator {

}


================================================
FILE: contracts/sushi/IBladePoolRegister.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

/**
 * @title IBladePoolRegister
 * @notice Interface for Sushi's Blade Pool Register
 * @dev Blade is Sushi's RFQ (Request for Quote) trading protocol that provides better pricing through off-chain liquidity aggregation and on-chain settlement.
 * @custom:katana 0xe56a524F7F35d39E5d5C34428De497da29D4B88b
 * @custom:tags sushi,swap,dex,defi,rfq
 */
interface IBladePoolRegister {
    error OwnableInvalidOwner(address owner);
    error OwnableUnauthorizedAccount(address account);
    event BladeLPTransferCreated(
        address indexed oldExchange,
        address indexed newExchange,
        address indexed lpTransferAddress
    );
    event BladePermitRouterCreated(
        address indexed permitRouterAddress,
        address indexed exchangeAddress
    );
    event BladeVerifiedExchangeCreated(
        address indexed exchangeAddress,
        address[] tokens,
        address[] oracles
    );
    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    function bladeVerifiedImplementation() external view returns (address);

    function createBladePermitRouter(
        address bladeExchange,
        address permitRouterAddress
    ) external returns (address);

    function createBladeVerifiedExchange(
        address theSigner,
        address theWrapper,
        address[] memory tokens,
        address[] memory oracles,
        uint256[] memory minTimeTolerances,
        address initialOwner,
        address exchangeAddress
    ) external returns (address);

    function createLPTransfer(
        address oldExchange,
        address newExchange,
        address lpTransferAddress
    ) external returns (address);

    function isRegistered(address) external view returns (bool);

    function lpTransferImplementation() external view returns (address);

    function owner() external view returns (address);

    function permitRouterImplementation() external view returns (address);

    function renounceOwnership() external;

    function setLPTransferImplementation(address newImpl) external;

    function setPermitRouterImplementation(address newImpl) external;

    function setVerifiedImplementation(address newImpl) external;

    function transferOwnership(address newOwner) external;
}


================================================
FILE: contracts/sushi/IRedSnwapper.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

/**
 * @title IRedSnwapper
 * @notice Interface for Sushi'sRedSnwapper
 * @dev RedSnwapper is a facade for the execution router contracts (RouteProcessor), and handles single & multi token swaps.
 * @custom:katana 0xAC4c6e212A361c968F1725b4d055b47E63F80b75
 * @custom:tags sushi,swap,dex,defi
 */
interface IRedSnwapper {
    error MinimalOutputBalanceViolation(address tokenOut, uint256 amountOut);

    function safeExecutor() external view returns (address);

    function snwap(
        address tokenIn,
        uint256 amountIn,
        address recipient,
        address tokenOut,
        uint256 amountOutMin,
        address executor,
        bytes memory executorData
    ) external payable returns (uint256 amountOut);

    function snwapMultiple(
        InputToken[] memory inputTokens,
        OutputToken[] memory outputTokens,
        Executor[] memory executors
    ) external payable returns (uint256[] memory amountOut);
}

struct InputToken {
    address token;
    uint256 amountIn;
    address transferTo;
}

struct OutputToken {
    address token;
    address recipient;
    uint256 amountOutMin;
}

struct Executor {
    address executor;
    uint256 value;
    bytes data;
}


================================================
FILE: contracts/sushi/IRouteProcessor8.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IRouteProcessor8
 * @notice Interface for Sushi's RouteProcessor8
 * @dev Processes the route generated off-chain. Includes an option to take a portion of any surplus.
 * @custom:katana 0x2905d7e4D048d29954F81b02171DD313F457a4a4
 * @custom:tags sushi,swap,dex,defi
 */
interface IRouteProcessor8 {
    /// @notice Emitted after a route is processed
    /// @param from The tx initiator
    /// @param to Recipient of the output tokens
    /// @param tokenIn Input token
    /// @param tokenOut Output token
    /// @param amountIn Total input amount routed
    /// @param amountOut Actual output amount received
    /// @param slippage Slippage captured during execution (if any)
    /// @param referralCode Referral code of the tx creator
    event Route(
        address indexed from,
        address to,
        address indexed tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 amountOut,
        int256 slippage,
        uint32 indexed referralCode
    );

    /// @notice Process an off-chain generated route
    /// @return amountOut Actual amount of tokenOut received
    function processRoute(
        address tokenIn,
        uint256 amountIn,
        address tokenOut,
        uint256 amountOutQuote,
        address to,
        bytes calldata route,
        bool takeSurplus,
        uint32 referralCode
    ) external payable returns (uint256 amountOut);

    /// @notice Transfer a specified amount of input value to `transferValueTo` then process the route
    /// @return amountOut Actual amount of tokenOut received
    function processRouteWithTransferValueInput(
        address payable transferValueTo,
        uint256 amountValueTransfer,
        address tokenIn,
        uint256 amountIn,
        address tokenOut,
        uint256 amountOutQuote,
        address to,
        bytes calldata route,
        bool takeSurplus,
        uint32 referralCode
    ) external payable returns (uint256 amountOut);

    /// @notice Process the route and send `amountValueTransfer - fee` of output to `transferValueTo`
    /// @return amountOut Actual amount of tokenOut received
    function processRouteWithTransferValueOutput(
        address payable transferValueTo,
        uint256 amountValueTransfer,
        address tokenIn,
        uint256 amountIn,
        address tokenOut,
        uint256 amountOutQuote,
        address to,
        bytes calldata route,
        bool takeSurplus,
        uint32 referralCode
    ) external payable returns (uint256 amountOut);

    /// @notice Transfer a specified value to `transferValueTo` then process the route
    /// @dev Note the exact method name casing: transferValueAndprocessRoute (lowercase 'p' in process)
    /// @return amountOut Actual amount of tokenOut received
    function transferValueAndprocessRoute(
        address transferValueTo,
        uint256 amountValueTransfer,
        address tokenIn,
        uint256 amountIn,
        address tokenOut,
        uint256 amountOutQuote,
        address to,
        bytes calldata route,
        bool takeSurplus,
        uint32 referralCode
    ) external payable returns (uint256 amountOut);
}



================================================
FILE: contracts/sushi/ISushiTickLens.sol
================================================
// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity ^0.8.4;

/**
 * @title ISushiTickLens
 * @notice Interface for Sushi's Tick Lens which provides functions for fetching chunks of tick data for a pool
 * @dev This avoids the waterfall of fetching the tick bitmap, parsing the bitmap to know which ticks to fetch, and then sending additional multicalls to fetch the tick data
 * @custom:katana 0x35dc3e13469e980c37b6f288bbb9822b1f9bd435
 * @custom:tags sushi,swap,dex,defi,v3
 */
interface ISushiTickLens {
    function getPopulatedTicksInWord(address pool, int16 tickBitmapIndex)
        external
        view
        returns (ITickLens.PopulatedTick[] memory populatedTicks);
}

interface ITickLens {
    struct PopulatedTick {
        int24 tick;
        int128 liquidityNet;
        uint128 liquidityGross;
    }
}

// THIS FILE WAS AUTOGENERATED FROM THE FOLLOWING ABI JSON:
/*
[{"inputs":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"int16","name":"tickBitmapIndex","type":"int16"}],"name":"getPopulatedTicksInWord","outputs":[{"components":[{"internalType":"int24","name":"tick","type":"int24"},{"internalType":"int128","name":"liquidityNet","type":"int128"},{"internalType":"uint128","name":"liquidityGross","type":"uint128"}],"internalType":"struct ITickLens.PopulatedTick[]","name":"populatedTicks","type":"tuple[]"}],"stateMutability":"view","type":"function"}]
*/


================================================
FILE: contracts/sushi/ISushiV2Factory.sol
================================================
// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity ^0.8.4;

/**
 * @title ISushiV2Factory
 * @notice Interface for Sushi's V2 Factory
 * @dev Factory for creating SushiSwap V2 pools
 * @custom:katana 0x72d111b4d6f31b38919ae39779f570b747d6acd9
 * @custom:tags sushi,swap,dex,defi,v2
 */
interface ISushiV2Factory {
    event PairCreated(
        address indexed token0,
        address indexed token1,
        address pair,
        uint256
    );

    function allPairs(uint256) external view returns (address);

    function allPairsLength() external view returns (uint256);

    function createPair(address tokenA, address tokenB)
        external
        returns (address pair);

    function feeTo() external view returns (address);

    function feeToSetter() external view returns (address);

    function getPair(address, address) external view returns (address);

    function migrator() external view returns (address);

    function pairCodeHash() external pure returns (bytes32);

    function setFeeTo(address _feeTo) external;

    function setFeeToSetter(address _feeToSetter) external;

    function setMigrator(address _migrator) external;
}


================================================
FILE: contracts/sushi/ISushiV3Factory.sol
================================================
// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.7.0 <0.9.0;

/**
 * @title ISushiV3Factory
 * @notice Interface for SushiSwap V3 Factory contract
 * @dev Factory for creating SushiSwap V3 pools
 * @custom:katana 0x203e8740894c8955cB8950759876d7E7E45E04c1
 * @custom:tags sushi,defi,amm,factory,v3
 */
interface SushiV3Factory {
    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);
    event OwnerChanged(address indexed oldOwner, address indexed newOwner);
    event PoolCreated(
        address indexed token0,
        address indexed token1,
        uint24 indexed fee,
        int24 tickSpacing,
        address pool
    );

    function createPool(
        address tokenA,
        address tokenB,
        uint24 fee
    ) external returns (address pool);

    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;

    function feeAmountTickSpacing(uint24) external view returns (int24);

    function getPool(
        address,
        address,
        uint24
    ) external view returns (address);

    function owner() external view returns (address);

    function parameters()
        external
        view
        returns (
            address factory,
            address token0,
            address token1,
            uint24 fee,
            int24 tickSpacing
        );

    function setOwner(address _owner) external;
}

// THIS FILE WAS AUTOGENERATED FROM THE FOLLOWING ABI JSON:
/*
[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint24","name":"fee","type":"uint24"},{"indexed":true,"internalType":"int24","name":"tickSpacing","type":"int24"}],"name":"FeeAmountEnabled","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"oldOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnerChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"token0","type":"address"},{"indexed":true,"internalType":"address","name":"token1","type":"address"},{"indexed":true,"internalType":"uint24","name":"fee","type":"uint24"},{"indexed":false,"internalType":"int24","name":"tickSpacing","type":"int24"},{"indexed":false,"internalType":"address","name":"pool","type":"address"}],"name":"PoolCreated","type":"event"},{"inputs":[{"internalType":"address","name":"tokenA","type":"address"},{"internalType":"address","name":"tokenB","type":"address"},{"internalType":"uint24","name":"fee","type":"uint24"}],"name":"createPool","outputs":[{"internalType":"address","name":"pool","type":"address"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"int24","name":"tickSpacing","type":"int24"}],"name":"enableFeeAmount","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint24","name":"","type":"uint24"}],"name":"feeAmountTickSpacing","outputs":[{"internalType":"int24","name":"","type":"int24"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"},{"internalType":"uint24","name":"","type":"uint24"}],"name":"getPool","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"parameters","outputs":[{"internalType":"address","name":"factory","type":"address"},{"internalType":"address","name":"token0","type":"address"},{"internalType":"address","name":"token1","type":"address"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"int24","name":"tickSpacing","type":"int24"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_owner","type":"address"}],"name":"setOwner","outputs":[],"stateMutability":"nonpayable","type":"function"}]
*/


================================================
FILE: contracts/sushi/ISushiV3PositionManager.sol
================================================
// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity >=0.7.0 <0.9.0;
pragma experimental ABIEncoderV2;

/// @custom:katana 0x2659c6085d26144117d904c46b48b6d180393d27
/// @custom:tags sushi,swap,dex,defi,v3
interface SushiV3PositionManager {
    event Approval(
        address indexed owner,
        address indexed approved,
        uint256 indexed tokenId
    );
    event ApprovalForAll(
        address indexed owner,
        address indexed operator,
        bool approved
    );
    event Collect(
        uint256 indexed tokenId,
        address recipient,
        uint256 amount0,
        uint256 amount1
    );
    event DecreaseLiquidity(
        uint256 indexed tokenId,
        uint128 liquidity,
        uint256 amount0,
        uint256 amount1
    );
    event IncreaseLiquidity(
        uint256 indexed tokenId,
        uint128 liquidity,
        uint256 amount0,
        uint256 amount1
    );
    event Transfer(
        address indexed from,
        address indexed to,
        uint256 indexed tokenId
    );

    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PERMIT_TYPEHASH() external view returns (bytes32);

    function WETH9() external view returns (address);

    function approve(address to, uint256 tokenId) external;

    function balanceOf(address owner) external view returns (uint256);

    function baseURI() external pure returns (string memory);

    function burn(uint256 tokenId) external payable;

    function collect(INonfungiblePositionManager.CollectParams memory params)
        external
        payable
        returns (uint256 amount0, uint256 amount1);

    function createAndInitializePoolIfNecessary(
        address token0,
        address token1,
        uint24 fee,
        uint160 sqrtPriceX96
    ) external payable returns (address pool);

    function decreaseLiquidity(
        INonfungiblePositionManager.DecreaseLiquidityParams memory params
    ) external payable returns (uint256 amount0, uint256 amount1);

    function factory() external view returns (address);

    function getApproved(uint256 tokenId) external view returns (address);

    function increaseLiquidity(
        INonfungiblePositionManager.IncreaseLiquidityParams memory params
    )
        external
        payable
        returns (
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    function isApprovedForAll(address owner, address operator)
        external
        view
        returns (bool);

    function mint(INonfungiblePositionManager.MintParams memory params)
        external
        payable
        returns (
            uint256 tokenId,
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    function multicall(bytes[] memory data)
        external
        payable
        returns (bytes[] memory results);

    function name() external view returns (string memory);

    function ownerOf(uint256 tokenId) external view returns (address);

    function permit(
        address spender,
        uint256 tokenId,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external payable;

    function positions(uint256 tokenId)
        external
        view
        returns (
            uint96 nonce,
            address operator,
            address token0,
            address token1,
            uint24 fee,
            int24 tickLower,
            int24 tickUpper,
            uint128 liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );

    function refundETH() external payable;

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) external;

    function selfPermit(
        address token,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external payable;

    function selfPermitAllowed(
        address token,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external payable;

    function selfPermitAllowedIfNecessary(
        address token,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external payable;

    function selfPermitIfNecessary(
        address token,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external payable;

    function setApprovalForAll(address operator, bool approved) external;

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

    function sweepToken(
        address token,
        uint256 amountMinimum,
        address recipient
    ) external payable;

    function symbol() external view returns (string memory);

    function tokenByIndex(uint256 index) external view returns (uint256);

    function tokenOfOwnerByIndex(address owner, uint256 index)
        external
        view
        returns (uint256);

    function tokenURI(uint256 tokenId) external view returns (string memory);

    function totalSupply() external view returns (uint256);

    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    function uniswapV3MintCallback(
        uint256 amount0Owed,
        uint256 amount1Owed,
        bytes memory data
    ) external;

    function unwrapWETH9(uint256 amountMinimum, address recipient)
        external
        payable;

    receive() external payable;
}

interface INonfungiblePositionManager {
    struct CollectParams {
        uint256 tokenId;
        address recipient;
        uint128 amount0Max;
        uint128 amount1Max;
    }

    struct DecreaseLiquidityParams {
        uint256 tokenId;
        uint128 liquidity;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    struct IncreaseLiquidityParams {
        uint256 tokenId;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    struct MintParams {
        address token0;
        address token1;
        uint24 fee;
        int24 tickLower;
        int24 tickUpper;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        address recipient;
        uint256 deadline;
    }
}

// THIS FILE WAS AUTOGENERATED FROM THE FOLLOWING ABI JSON:
/*
[{"inputs":[{"internalType":"address","name":"_factory","type":"address"},{"internalType":"address","name":"_WETH9","type":"address"},{"internalType":"address","name":"_tokenDescriptor_","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"approved","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"address","name":"recipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount0","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount1","type":"uint256"}],"name":"Collect","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"uint128","name":"liquidity","type":"uint128"},{"indexed":false,"internalType":"uint256","name":"amount0","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount1","type":"uint256"}],"name":"DecreaseLiquidity","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"uint128","name":"liquidity","type":"uint128"},{"indexed":false,"internalType":"uint256","name":"amount0","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount1","type":"uint256"}],"name":"IncreaseLiquidity","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[],"name":"DOMAIN_SEPARATOR","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"PERMIT_TYPEHASH","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"WETH9","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"approve","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"baseURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint128","name":"amount0Max","type":"uint128"},{"internalType":"uint128","name":"amount1Max","type":"uint128"}],"internalType":"struct INonfungiblePositionManager.CollectParams","name":"params","type":"tuple"}],"name":"collect","outputs":[{"internalType":"uint256","name":"amount0","type":"uint256"},{"internalType":"uint256","name":"amount1","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"token0","type":"address"},{"internalType":"address","name":"token1","type":"address"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"uint160","name":"sqrtPriceX96","type":"uint160"}],"name":"createAndInitializePoolIfNecessary","outputs":[{"internalType":"address","name":"pool","type":"address"}],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint128","name":"liquidity","type":"uint128"},{"internalType":"uint256","name":"amount0Min","type":"uint256"},{"internalType":"uint256","name":"amount1Min","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"internalType":"struct INonfungiblePositionManager.DecreaseLiquidityParams","name":"params","type":"tuple"}],"name":"decreaseLiquidity","outputs":[{"internalType":"uint256","name":"amount0","type":"uint256"},{"internalType":"uint256","name":"amount1","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"factory","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"getApproved","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"amount0Desired","type":"uint256"},{"internalType":"uint256","name":"amount1Desired","type":"uint256"},{"internalType":"uint256","name":"amount0Min","type":"uint256"},{"internalType":"uint256","name":"amount1Min","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"internalType":"struct INonfungiblePositionManager.IncreaseLiquidityParams","name":"params","type":"tuple"}],"name":"increaseLiquidity","outputs":[{"internalType":"uint128","name":"liquidity","type":"uint128"},{"internalType":"uint256","name":"amount0","type":"uint256"},{"internalType":"uint256","name":"amount1","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"token0","type":"address"},{"internalType":"address","name":"token1","type":"address"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"int24","name":"tickLower","type":"int24"},{"internalType":"int24","name":"tickUpper","type":"int24"},{"internalType":"uint256","name":"amount0Desired","type":"uint256"},{"internalType":"uint256","name":"amount1Desired","type":"uint256"},{"internalType":"uint256","name":"amount0Min","type":"uint256"},{"internalType":"uint256","name":"amount1Min","type":"uint256"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"internalType":"struct INonfungiblePositionManager.MintParams","name":"params","type":"tuple"}],"name":"mint","outputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint128","name":"liquidity","type":"uint128"},{"internalType":"uint256","name":"amount0","type":"uint256"},{"internalType":"uint256","name":"amount1","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"data","type":"bytes[]"}],"name":"multicall","outputs":[{"internalType":"bytes[]","name":"results","type":"bytes[]"}],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"ownerOf","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"permit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"positions","outputs":[{"internalType":"uint96","name":"nonce","type":"uint96"},{"internalType":"address","name":"operator","type":"address"},{"internalType":"address","name":"token0","type":"address"},{"internalType":"address","name":"token1","type":"address"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"int24","name":"tickLower","type":"int24"},{"internalType":"int24","name":"tickUpper","type":"int24"},{"internalType":"uint128","name":"liquidity","type":"uint128"},{"internalType":"uint256","name":"feeGrowthInside0LastX128","type":"uint256"},{"internalType":"uint256","name":"feeGrowthInside1LastX128","type":"uint256"},{"internalType":"uint128","name":"tokensOwed0","type":"uint128"},{"internalType":"uint128","name":"tokensOwed1","type":"uint128"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"refundETH","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"selfPermit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"uint256","name":"expiry","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"selfPermitAllowed","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"uint256","name":"expiry","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"selfPermitAllowedIfNecessary","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"selfPermitIfNecessary","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"amountMinimum","type":"uint256"},{"internalType":"address","name":"recipient","type":"address"}],"name":"sweepToken","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"index","type":"uint256"}],"name":"tokenByIndex","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"tokenOfOwnerByIndex","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"tokenURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"transferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount0Owed","type":"uint256"},{"internalType":"uint256","name":"amount1Owed","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"uniswapV3MintCallback","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountMinimum","type":"uint256"},{"internalType":"address","name":"recipient","type":"address"}],"name":"unwrapWETH9","outputs":[],"stateMutability":"payable","type":"function"},{"stateMutability":"payable","type":"receive"}]
*/


================================================
FILE: contracts/sushi/IUniswapV2Router02.sol
================================================
// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity ^0.8.4;

/**
 * @title IUniswapV2Router02
 * @notice Interface for Sushi's V2 Router
 * @dev Router for SushiSwap V2
 * @custom:katana 0x69cc349932ae18ed406eeb917d79b9b3033fb68e
 * @custom:tags sushi,swap,dex,defi,v2
 */
interface UniswapV2Router02 {
    function WETH() external view returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    )
        external
        returns (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        );

    function addLiquidityETH(
        address token,
        uint256 amountTokenDesired,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    )
        external
        payable
        returns (
            uint256 amountToken,
            uint256 amountETH,
            uint256 liquidity
        );

    function factory() external view returns (address);

    function getAmountIn(
        uint256 amountOut,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountIn);

    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountOut);

    function getAmountsIn(uint256 amountOut, address[] memory path)
        external
        view
        returns (uint256[] memory amounts);

    function getAmountsOut(uint256 amountIn, address[] memory path)
        external
        view
        returns (uint256[] memory amounts);

    function quote(
        uint256 amountA,
        uint256 reserveA,
        uint256 reserveB
    ) external pure returns (uint256 amountB);

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETH(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountToken, uint256 amountETH);

    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountETH);

    function removeLiquidityETHWithPermit(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountToken, uint256 amountETH);

    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountETH);

    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountA, uint256 amountB);

    function swapETHForExactTokens(
        uint256 amountOut,
        address[] memory path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function swapExactETHForTokens(
        uint256 amountOutMin,
        address[] memory path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint256 amountOutMin,
        address[] memory path,
        address to,
        uint256 deadline
    ) external payable;

    function swapExactTokensForETH(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] memory path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] memory path,
        address to,
        uint256 deadline
    ) external;

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] memory path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] memory path,
        address to,
        uint256 deadline
    ) external;

    function swapTokensForExactETH(
        uint256 amountOut,
        uint256 amountInMax,
        address[] memory path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapTokensForExactTokens(
        uint256 amountOut,
        uint256 amountInMax,
        address[] memory path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    receive() external payable;
}


================================================
FILE: contracts/tokens/IAUSD.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @title IAUSD
 * @notice Interface for Agora USD (AUSD), the stablecoin on Katana
 * @dev AUSD implements the standard ERC-20 interface
 * @custom:katana 0x00000000eFE302BEAA2b3e6e1b18d08D69a9012a
 * @custom:katana ethereum:0x00000000eFE302BEAA2b3e6e1b18d08D69a9012a
 * @custom:tags erc20,token,stablecoin,ausd
 */
interface IAUSD is IERC20 {
    // AUSD fully implements the ERC-20 standard
    // This interface exists to document the token address and potential future extensions
} 


================================================
FILE: contracts/tokens/IBTCK.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @title IBTCK
 * @notice Interface for Bitcoin on Katana (BTCK) on Katana
 * @dev BTCK implements the standard ERC-20 interface
 * @custom:katana 0xB0F70C0bD6FD87dbEb7C10dC692a2a6106817072
 * @custom:tags erc20,token,bitcoin,btck
 */
interface IBTCK is IERC20 {
    // BTCK fully implements the ERC-20 standard
    // This interface exists to document the token address and potential future extensions
}


================================================
FILE: contracts/tokens/IbvUSD.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @title IbvUSD
 * @notice Interface for BitVault USD (bvUSD) on Katana
 * @dev bvUSD implements the standard ERC-20 interface
 * @custom:katana 0x876aac7648D79f87245E73316eB2D100e75F3Df1
 * @custom:tags erc20,token,stablecoin,bvusd
 */
interface IbvUSD is IERC20 {
    // bvUSD fully implements the ERC-20 standard
    // This interface exists to document the token address and potential future extensions
}


================================================
FILE: contracts/tokens/IJitoSOL.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @title IJitoSOL
 * @notice Interface for Jito Staked SOL (JitoSOL) on Katana
 * @dev JitoSOL implements the standard ERC-20 interface
 * @custom:katana 0x6C16E26013f2431e8B2e1Ba7067ECCcad0Db6C52
 * @custom:tags erc20,token,staking,jitosol,solana
 */
interface IJitoSOL is IERC20 {
    // JitoSOL fully implements the ERC-20 standard
    // This interface exists to document the token address and potential future extensions
}


================================================
FILE: contracts/tokens/IKAT.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

import "../IERC20.sol";

/**
 * @title IKAT
 * @notice Interface for KAT, the native token on Katana
 * @dev KAT implements the standard ERC-20 interface
 * @custom:katana 0x7F1f4b4b29f5058fA32CC7a97141b8D7e5ABDC2d
 * @custom:tags erc20,token,governance,katana,native
 */
interface IKAT is IERC20 {
    // KAT fully implements the ERC-20 standard
    // This interface exists to document the token address and potential future extensions
} 


================================================
FILE: contracts/tokens/ILBTC.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @title ILBTC
 * @notice Interface for Lombard Staked BTC (LBTC) on Katana
 * @dev LBTC implements the standard ERC-20 interface
 * @custom:katana 0xecAc9C5F704e954931349Da37F60E39f515c11c1
 * @custom:katana ethereum:0x8236a87084f8b84306f72007f36f2618a5634494
 * @custom:tags erc20,token,bitcoin,lbtc,liquid
 */
interface ILBTC is IERC20 {
    // LBTC fully implements the ERC-20 standard
    // This interface exists to document the token address and potential future extensions
}


================================================
FILE: contracts/tokens/IMORPHO.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @title IMORPHO
 * @notice Interface for Bridge-wrapped MORPHO (MORPHO) on Katana
 * @dev MORPHO implements the standard ERC-20 interface
 * @custom:katana 0x1e5eFCA3D0dB2c6d5C67a4491845c43253eB9e4e
 * @custom:katana ethereum:0x58d97b57bb95320f9a05dc918aef65434969c2b2
 * @custom:tags erc20,token,governance,morpho
 */
interface IMORPHO is IERC20 {
    // MORPHO fully implements the ERC-20 standard
    // This interface exists to document the token address and potential future extensions
}


================================================
FILE: contracts/tokens/IPOL.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @title IPOL
 * @notice Interface for Bridge-wrapped POL (POL) on Katana
 * @dev POL implements the standard ERC-20 interface
 * @custom:katana 0xb24e3035d1FCBC0E43CF3143C3Fd92E53df2009b
 * @custom:katana ethereum:0x455e53CBB86018Ac2B8092FdCd39d8444aFFC3F6
 * @custom:tags erc20,token,governance,polygon,pol
 */
interface IPOL is IERC20 {
    // POL fully implements the ERC-20 standard
    // This interface exists to document the token address and potential future extensions
}


================================================
FILE: contracts/tokens/IPROVE.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @title IPROVE
 * @notice Interface for Bridge-wrapped Succinct (PROVE) on Katana
 * @dev PROVE implements the standard ERC-20 interface
 * @custom:katana 0xb244Add9FE6cB17558221e4Dfea960e680CCD29b
 * @custom:katana ethereum:0x6bef15d938d4e72056ac92ea4bdd0d76b1c4ad29
 * @custom:tags erc20,token,polygon,succinct,prove
 */
interface IPROVE is IERC20 {
    // PROVE fully implements the ERC-20 standard
    // This interface exists to document the token address and potential future extensions
}


================================================
FILE: contracts/tokens/ISUSHI.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @title ISUSHI
 * @notice Interface for Bridge-wrapped SUSHI (SUSHI) on Katana
 * @dev SUSHI implements the standard ERC-20 interface
 * @custom:katana 0x17BFF452dae47e07CeA877Ff0E1aba17eB62b0aB
 * @custom:katana ethereum:0x6b3595068778dd592e39a122f4f5a5cf09c90fe2
 * @custom:tags erc20,token,governance,sushi,defi
 */
interface ISUSHI is IERC20 {
    // SUSHI fully implements the ERC-20 standard
    // This interface exists to document the token address and potential future extensions
}


================================================
FILE: contracts/tokens/IuBTC.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @title IuBTC
 * @notice Interface for Universal BTC (uBTC), the Universal wrapped BTC on Katana
 * @dev uBTC implements the standard ERC-20 interface
 * @custom:tags erc20,token,wrapped,btc,ubtc
 */
interface IuBTC is IERC20 {
    // This interface exists to document the token address and potential future extensions
} 


================================================
FILE: contracts/tokens/IuSOL.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @title IuSOL
 * @notice Interface for Universal SOL (uSOL), the Universal wrapped SOL on Katana
 * @dev uSOL implements the standard ERC-20 interface
 * @custom:tags erc20,token,wrapped,sol,usol
 */
interface IuSOL is IERC20 {
    // This interface exists to document the token address and potential future extensions
} 


================================================
FILE: contracts/tokens/IuSUI.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @title IuSUI
 * @notice Interface for SUI (Universal) (uSUI) on Katana
 * @dev uSUI implements the standard ERC-20 interface
 * @custom:katana 0xb0505e5a99abd03d94a1169e638B78EDfEd26ea4
 * @custom:tags erc20,token,wrapped,sui,usui
 */
interface IuSUI is IERC20 {
    // uSUI fully implements the ERC-20 standard
    // This interface exists to document the token address and potential future extensions
}


================================================
FILE: contracts/tokens/IuXRP.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @title IuXRP
 * @notice Interface for Universal XRP (uXRP), the Universal wrapped XRP on Katana
 * @dev uXRP implements the standard ERC-20 interface
 * @custom:tags erc20,token,wrapped,xrp,uxrp
 */
interface IuXRP is IERC20 {
    // This interface exists to document the token address and potential future extensions
} 


================================================
FILE: contracts/tokens/IweETH.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @title IweETH
 * @notice Interface for Bridge-wrapped weETH (weETH) on Katana
 * @dev weETH implements the standard ERC-20 interface
 * @custom:katana 0x9893989433e7a383Cb313953e4c2365107dc19a7
 * @custom:katana ethereum:0xcd5fe23c85820f7b72d0926fc9b05b43e359b7ee
 * @custom:tags erc20,token,staking,weeth,etherfi
 */
interface IweETH is IERC20 {
    // weETH fully implements the ERC-20 standard
    // This interface exists to document the token address and potential future extensions
}


================================================
FILE: contracts/tokens/IwstETH.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @title IwstETH
 * @notice Interface for Bridge-wrapped wstETH (wstETH) on Katana
 * @dev wstETH implements the standard ERC-20 interface
 * @custom:katana 0x7Fb4D0f51544F24F385a421Db6e7D4fC71Ad8e5C
 * @custom:katana ethereum:0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0
 * @custom:tags erc20,token,staking,wsteth,lido
 */
interface IwstETH is IERC20 {
    // wstETH fully implements the ERC-20 standard
    // This interface exists to document the token address and potential future extensions
}


================================================
FILE: contracts/tokens/IYFI.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @title IYFI
 * @notice Interface for Bridge-wrapped Yearn Finance (YFI) on Katana
 * @dev YFI implements the standard ERC-20 interface
 * @custom:katana 0x476eaCd417cD65421bD34fca054377658BB5E02b
 * @custom:katana ethereum:0x0bc529c00c6401aef6d220be8c6ea1667f6ad93e
 * @custom:tags erc20,token,governance,yearn,yfi
 */
interface IYFI is IERC20 {
    // YFI fully implements the ERC-20 standard
    // This interface exists to document the token address and potential future extensions
}


================================================
FILE: contracts/utils/BokutoAddresses.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title BokutoAddresses
 * @notice Library for accessing Bokuto network contract addresses
 * @dev Auto-generated from contract doccomments. Do not edit manually.
 */
library BokutoAddresses {
    /**
     * @notice Chain ID for Bokuto network
     */
    uint256 internal constant CHAIN_ID = 737373;

    /**
     * @notice Returns the address of IBatchDistributor
     * @return The IBatchDistributor contract address
     */
    function getBatchDistributorAddress() internal pure returns (address) {
        return 0x2A6fd05d3C6A373FBb073dea12bCee7C174AE606;
    }

    /**
     * @notice Returns the address of IBulkWriter
     * @return The IBulkWriter contract address
     */
    function getBulkWriterAddress() internal pure returns (address) {
        return 0xA681A7BE7A87bDA505c1a947b172b8A1988E329A;
    }

    /**
     * @notice Returns the address of IbvbEth
     * @return The IbvbEth contract address
     */
    function getIbvbEthAddress() internal pure returns (address) {
        return 0x84b3493fA9B125A8EFf1CCc1328Bd84D0B4a2Dbf;
    }

    /**
     * @notice Returns the address of IbvbUSDC
     * @return The IbvbUSDC contract address
     */
    function getIbvbUSDCAddress() internal pure returns (address) {
        return 0xc2a4C310F2512A17Ac0047cf871aCAed3E62bB4B;
    }

    /**
     * @notice Returns the address of IbvbUSDS
     * @return The IbvbUSDS contract address
     */
    function getIbvbUSDSAddress() internal pure returns (address) {
        return 0x801f719178d9b85D4948ed146C50596273885a75;
    }

    /**
     * @notice Returns the address of IbvbUSDT
     * @return The IbvbUSDT contract address
     */
    function getIbvbUSDTAddress() internal pure returns (address) {
        return 0xf6801557e17131Da48Fd03B2c34172872F936345;
    }

    /**
     * @notice Returns the address of IbvbWBTC
     * @return The IbvbWBTC contract address
     */
    function getIbvbWBTCAddress() internal pure returns (address) {
        return 0xe8255B44634b478aB10a649c6C207A654473dbed;
    }

    /**
     * @notice Returns the address of ICatalogFactory
     * @return The ICatalogFactory contract address
     */
    function getCatalogFactoryAddress() internal pure returns (address) {
        return 0xC0137140B2D2a146d20dBbb0153e5Ac1048f30E3;
    }

    /**
     * @notice Returns the address of ICatalogUtils
     * @return The ICatalogUtils contract address
     */
    function getCatalogUtilsAddress() internal pure returns (address) {
        return 0xB1e10B768E9d56A51f1C80d70414989ECAf87fd0;
    }

    /**
     * @notice Returns the address of IConduitController
     * @return The IConduitController contract address
     */
    function getConduitControllerAddress() internal pure returns (address) {
        return 0x00000000F9490004C11Cef243f5400493c00Ad63;
    }

    /**
     * @notice Returns the address of IRenderUtils
     * @return The IRenderUtils contract address
     */
    function getRenderUtilsAddress() internal pure returns (address) {
        return 0xcd891c3de90dcdF99549E9B6402BFAa695DEc69B;
    }

    /**
     * @notice Returns the address of ISeaport
     * @return The ISeaport contract address
     */
    function getSeaportAddress() internal pure returns (address) {
        return 0x0000000000000068F116a894984e2DB1123eB395;
    }

    /**
     * @notice Returns the address of ITokenAttributesRepository
     * @return The ITokenAttributesRepository contract address
     */
    function getTokenAttributesRepositoryAddress() internal pure returns (address) {
        return 0xC3f5961F6Bf6A60A6d2F9f45Ec477E1E46144827;
    }

    /**
     * @notice Returns the address of IUSDCNativeConverter
     * @return The IUSDCNativeConverter contract address
     */
    function getUSDCNativeConverterAddress() internal pure returns (address) {
        return 0xF1b01AAB6B790bb15610Dc18c6908b32765B5a06;
    }

    /**
     * @notice Returns the address of IUSDSNativeConverter
     * @return The IUSDSNativeConverter contract address
     */
    function getUSDSNativeConverterAddress() internal pure returns (address) {
        return 0xC4BaBEE541c2FA1EA55ce9aF9EB3B5C76B0CE5c7;
    }

    /**
     * @notice Returns the address of IUSDTNativeConverter
     * @return The IUSDTNativeConverter contract address
     */
    function getUSDTNativeConverterAddress() internal pure returns (address) {
        return 0x1bd455C30ad8E2b8dF40df44A2eF923d67B33Feb;
    }

    /**
     * @notice Returns the address of IWBTCNativeConverter
     * @return The IWBTCNativeConverter contract address
     */
    function getWBTCNativeConverterAddress() internal pure returns (address) {
        return 0x7A8ed27F4C30512326878652d20fC85727401854;
    }

    /**
     * @notice Returns the address of IWETHNativeConverter
     * @return The IWETHNativeConverter contract address
     */
    function getWETHNativeConverterAddress() internal pure returns (address) {
        return 0x409834270b6F2591DD6c1e9f351E4194B112dA44;
    }

    /**
     * @notice Returns the address of Multicall
     * @return The Multicall contract address
     */
    function getMulticallAddress() internal pure returns (address) {
        return 0x1a593e35B50A6BD65f23aa022C910FF0Cef58ACd;
    }

    /**
     * @notice Returns the address of Multicall2
     * @return The Multicall2 contract address
     */
    function getMulticall2Address() internal pure returns (address) {
        return 0xafc9dD4B1416f61c86A5540423D29abdFf665dbB;
    }

}


================================================
FILE: contracts/utils/BokutoOriginAddresses.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title BokutoOriginAddresses
 * @notice Library for accessing origin chain contract addresses when operating in Bokuto context
 * @dev Auto-generated from contract doccomments. Do not edit manually.
 *      These are contracts deployed on origin chains (Ethereum/Sepolia) that are accessed
 *      from the Bokuto context for cross-chain operations like Vault Bridge.
 */
library BokutoOriginAddresses {
    /**
     * @notice Returns the origin chain address of IMigrationManager
     * @dev This contract is deployed on sepolia and accessed from Bokuto context
     * @return The IMigrationManager contract address on sepolia
     */
    function getMigrationManagerAddress() internal pure returns (address) {
        return 0x16B46094cb1eE593181Ba2d997E77E88D7E9Ab8F;
    }

    /**
     * @notice Returns the origin chain address of IvbETH
     * @dev This contract is deployed on sepolia and accessed from Bokuto context
     * @return The IvbETH contract address on sepolia
     */
    function getIvbETHAddress() internal pure returns (address) {
        return 0x188FFFc2562C67aCdB9a0CD0B819021DDfC82A6B;
    }

    /**
     * @notice Returns the origin chain address of IvbUSDC
     * @dev This contract is deployed on sepolia and accessed from Bokuto context
     * @return The IvbUSDC contract address on sepolia
     */
    function getIvbUSDCAddress() internal pure returns (address) {
        return 0xb62Ba0719527701309339a175dDe3CBF1770dd38;
    }

    /**
     * @notice Returns the origin chain address of IvbUSDS
     * @dev This contract is deployed on sepolia and accessed from Bokuto context
     * @return The IvbUSDS contract address on sepolia
     */
    function getIvbUSDSAddress() internal pure returns (address) {
        return 0x406F1A8D91956d8D340821Cf6744Aa74c666836C;
    }

    /**
     * @notice Returns the origin chain address of IvbUSDT
     * @dev This contract is deployed on sepolia and accessed from Bokuto context
     * @return The IvbUSDT contract address on sepolia
     */
    function getIvbUSDTAddress() internal pure returns (address) {
        return 0xdd9aCdD3D2AeC1C823C51f8389597C6be9779B28;
    }

    /**
     * @notice Returns the origin chain address of IvbWBTC
     * @dev This contract is deployed on sepolia and accessed from Bokuto context
     * @return The IvbWBTC contract address on sepolia
     */
    function getIvbWBTCAddress() internal pure returns (address) {
        return 0x2CE29070ee5e65C4191d5Efca8E85be181F34B6d;
    }

}


================================================
FILE: contracts/utils/KatanaAddresses.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title KatanaAddresses
 * @notice Library for accessing Katana network contract addresses
 * @dev Auto-generated from contract doccomments. Do not edit manually.
 */
library KatanaAddresses {
    /**
     * @notice Chain ID for Katana network
     */
    uint256 internal constant CHAIN_ID = 747474;

    /**
     * @notice Returns the address of IADAUSDOracle
     * @return The IADAUSDOracle contract address
     */
    function getADAUSDOracleAddress() internal pure returns (address) {
        return 0xf1454949C6dEdfb500ae63Aa6c784Aa1Dde08A6c;
    }

    /**
     * @notice Returns the address of IAUSD
     * @return The IAUSD contract address
     */
    function getAUSDAddress() internal pure returns (address) {
        return 0x00000000eFE302BEAA2b3e6e1b18d08D69a9012a;
    }

    /**
     * @notice Returns the address of IAUSDUSDOracle
     * @return The IAUSDUSDOracle contract address
     */
    function getAUSDUSDOracleAddress() internal pure returns (address) {
        return 0x53bB139e962ee0AC6477F40D0352e8dAF0480b70;
    }

    /**
     * @notice Returns the address of IAUSDUSDOracle_oracles_chainlink_IAUSDUSDOracle
     * @return The IAUSDUSDOracle_oracles_chainlink_IAUSDUSDOracle contract address
     */
    function getAUSDUSDOracle_oracles_chainlink_IAUSDUSDOracleAddress() internal pure returns (address) {
        return 0x3A49D4e23868222785f148BA2bd0bAEc80d36a2A;
    }

    /**
     * @notice Returns the address of IBatchDistributor
     * @return The IBatchDistributor contract address
     */
    function getBatchDistributorAddress() internal pure returns (address) {
        return 0x66C0499B1Df146dbaf4B1DEa1df436ba26DAfF21;
    }

    /**
     * @notice Returns the address of IBladePoolRegister
     * @return The IBladePoolRegister contract address
     */
    function getBladePoolRegisterAddress() internal pure returns (address) {
        return 0xe56a524F7F35d39E5d5C34428De497da29D4B88b;
    }

    /**
     * @notice Returns the address of IBridgeExtension
     * @return The IBridgeExtension contract address
     */
    function getBridgeExtensionAddress() internal pure returns (address) {
        return 0x64B20Eb25AEd030FD510EF93B9135278B152f6a6;
    }

    /**
     * @notice Returns the address of IBTCK
     * @return The IBTCK contract address
     */
    function getBTCKAddress() internal pure returns (address) {
        return 0xB0F70C0bD6FD87dbEb7C10dC692a2a6106817072;
    }

    /**
     * @notice Returns the address of IBTCUSDOracle
     * @return The IBTCUSDOracle contract address
     */
    function getBTCUSDOracleAddress() internal pure returns (address) {
        return 0xb67047eDF6204F4C81333248dA71F8387050790C;
    }

    /**
     * @notice Returns the address of IBTCUSDOracle_oracles_chainlink_IBTCUSDOracle
     * @return The IBTCUSDOracle_oracles_chainlink_IBTCUSDOracle contract address
     */
    function getBTCUSDOracle_oracles_chainlink_IBTCUSDOracleAddress() internal pure returns (address) {
        return 0x41DdB7F8F5e1b2bD28193B84C1C36Be698dEd162;
    }

    /**
     * @notice Returns the address of IBulkWriter
     * @return The IBulkWriter contract address
     */
    function getBulkWriterAddress() internal pure returns (address) {
        return 0xcd891c3de90dcdF99549E9B6402BFAa695DEc69B;
    }

    /**
     * @notice Returns the address of IbvbEth
     * @return The IbvbEth contract address
     */
    function getIbvbEthAddress() internal pure returns (address) {
        return 0xEE7D8BCFb72bC1880D0Cf19822eB0A2e6577aB62;
    }

    /**
     * @notice Returns the address of IbvbUSDC
     * @return The IbvbUSDC contract address
     */
    function getIbvbUSDCAddress() internal pure returns (address) {
        return 0x203A662b0BD271A6ed5a60EdFbd04bFce608FD36;
    }

    /**
     * @notice Returns the address of IbvbUSDS
     * @return The IbvbUSDS contract address
     */
    function getIbvbUSDSAddress() internal pure returns (address) {
        return 0x62D6A123E8D19d06d68cf0d2294F9A3A0362c6b3;
    }

    /**
     * @notice Returns the address of IbvbUSDT
     * @return The IbvbUSDT contract address
     */
    function getIbvbUSDTAddress() internal pure returns (address) {
        return 0x2DCa96907fde857dd3D816880A0df407eeB2D2F2;
    }

    /**
     * @notice Returns the address of IbvbWBTC
     * @return The IbvbWBTC contract address
     */
    function getIbvbWBTCAddress() internal pure returns (address) {
        return 0x0913DA6Da4b42f538B445599b46Bb4622342Cf52;
    }

    /**
     * @notice Returns the address of IbvUSD
     * @return The IbvUSD contract address
     */
    function getIbvUSDAddress() internal pure returns (address) {
        return 0x876aac7648D79f87245E73316eB2D100e75F3Df1;
    }

    /**
     * @notice Returns the address of ICatalogFactory
     * @return The ICatalogFactory contract address
     */
    function getCatalogFactoryAddress() internal pure returns (address) {
        return 0xC0137140B2D2a146d20dBbb0153e5Ac1048f30E3;
    }

    /**
     * @notice Returns the address of ICatalogUtils
     * @return The ICatalogUtils contract address
     */
    function getCatalogUtilsAddress() internal pure returns (address) {
        return 0xB1e10B768E9d56A51f1C80d70414989ECAf87fd0;
    }

    /**
     * @notice Returns the address of IConduitController
     * @return The IConduitController contract address
     */
    function getConduitControllerAddress() internal pure returns (address) {
        return 0x00000000F9490004C11Cef243f5400493c00Ad63;
    }

    /**
     * @notice Returns the address of IETHUSDOracle
     * @return The IETHUSDOracle contract address
     */
    function getETHUSDOracleAddress() internal pure returns (address) {
        return 0xE94c9f9A1893f23be38A5C0394E46Ac05e8a5f8C;
    }

    /**
     * @notice Returns the address of IETHUSDOracle_oracles_chainlink_IETHUSDOracle
     * @return The IETHUSDOracle_oracles_chainlink_IETHUSDOracle contract address
     */
    function getETHUSDOracle_oracles_chainlink_IETHUSDOracleAddress() internal pure returns (address) {
        return 0x7BdBDB772f4a073BadD676A567C6ED82049a8eEE;
    }

    /**
     * @notice Returns the address of IJitoSOL
     * @return The IJitoSOL contract address
     */
    function getJitoSOLAddress() internal pure returns (address) {
        return 0x6C16E26013f2431e8B2e1Ba7067ECCcad0Db6C52;
    }

    /**
     * @notice Returns the address of IJitoSOLSOLOracle
     * @return The IJitoSOLSOLOracle contract address
     */
    function getJitoSOLSOLOracleAddress() internal pure returns (address) {
        return 0x1C0a310cf42F357087Be122e69ee402D19A265dC;
    }

    /**
     * @notice Returns the address of IJitoSOLUSDOracle
     * @return The IJitoSOLUSDOracle contract address
     */
    function getJitoSOLUSDOracleAddress() internal pure returns (address) {
        return 0x36E03469335b7F2eF51aAeB914b76c038645679A;
    }

    /**
     * @notice Returns the address of IKAT
     * @return The IKAT contract address
     */
    function getKATAddress() internal pure returns (address) {
        return 0x7F1f4b4b29f5058fA32CC7a97141b8D7e5ABDC2d;
    }

    /**
     * @notice Returns the address of ILBTC
     * @return The ILBTC contract address
     */
    function getLBTCAddress() internal pure returns (address) {
        return 0xecAc9C5F704e954931349Da37F60E39f515c11c1;
    }

    /**
     * @notice Returns the address of ILBTCBTCOracle
     * @return The ILBTCBTCOracle contract address
     */
    function getLBTCBTCOracleAddress() internal pure returns (address) {
        return 0xb9D0073aCb296719C26a8BF156e4b599174fe1d5;
    }

    /**
     * @notice Returns the address of ILBTCBTCOracle_oracles_chainlink_ILBTCBTCOracle
     * @return The ILBTCBTCOracle_oracles_chainlink_ILBTCBTCOracle contract address
     */
    function getLBTCBTCOracle_oracles_chainlink_ILBTCBTCOracleAddress() internal pure returns (address) {
        return 0x6830BfE63F8804B4972D92826b9088d2fb6AFe5b;
    }

    /**
     * @notice Returns the address of ILBTCUSDOracle
     * @return The ILBTCUSDOracle contract address
     */
    function getLBTCUSDOracleAddress() internal pure returns (address) {
        return 0x5C2c6A77310C7750fCc5c3f13a3f9C3b18a68d3e;
    }

    /**
     * @notice Returns the address of ILINKUSDOracle
     * @return The ILINKUSDOracle contract address
     */
    function getLINKUSDOracleAddress() internal pure returns (address) {
        return 0x06bD6464e94Bee9393Ae15B5Dd5eCDFAa4F299C1;
    }

    /**
     * @notice Returns the address of IMORPHO
     * @return The IMORPHO contract address
     */
    function getMORPHOAddress() internal pure returns (address) {
        return 0x1e5eFCA3D0dB2c6d5C67a4491845c43253eB9e4e;
    }

    /**
     * @notice Returns the address of IMORPHOUSDOracle
     * @return The IMORPHOUSDOracle contract address
     */
    function getMORPHOUSDOracleAddress() internal pure returns (address) {
        return 0xdFd824A5Dcad8667142d58FE4aF115d5d052f26c;
    }

    /**
     * @notice Returns the address of IPOL
     * @return The IPOL contract address
     */
    function getPOLAddress() internal pure returns (address) {
        return 0xb24e3035d1FCBC0E43CF3143C3Fd92E53df2009b;
    }

    /**
     * @notice Returns the address of IPOLUSDOracle
     * @return The IPOLUSDOracle contract address
     */
    function getPOLUSDOracleAddress() internal pure returns (address) {
        return 0xF6630799b5387e0E9ACe92a5E82673021781B440;
    }

    /**
     * @notice Returns the address of IPROVE
     * @return The IPROVE contract address
     */
    function getPROVEAddress() internal pure returns (address) {
        return 0xb244Add9FE6cB17558221e4Dfea960e680CCD29b;
    }

    /**
     * @notice Returns the address of IRedSnwapper
     * @return The IRedSnwapper contract address
     */
    function getRedSnwapperAddress() internal pure returns (address) {
        return 0xAC4c6e212A361c968F1725b4d055b47E63F80b75;
    }

    /**
     * @notice Returns the address of IRenderUtils
     * @return The IRenderUtils contract address
     */
    function getRenderUtilsAddress() internal pure returns (address) {
        return 0xA681A7BE7A87bDA505c1a947b172b8A1988E329A;
    }

    /**
     * @notice Returns the address of IRouteProcessor8
     * @return The IRouteProcessor8 contract address
     */
    function getRouteProcessor8Address() internal pure returns (address) {
        return 0x2905d7e4D048d29954F81b02171DD313F457a4a4;
    }

    /**
     * @notice Returns the address of ISeaport
     * @return The ISeaport contract address
     */
    function getSeaportAddress() internal pure returns (address) {
        return 0x0000000000000068F116a894984e2DB1123eB395;
    }

    /**
     * @notice Returns the address of ISOLUSDOracle
     * @return The ISOLUSDOracle contract address
     */
    function getSOLUSDOracleAddress() internal pure returns (address) {
        return 0x709c4dc298322916eaE59bfdc2e3d750B55C864B;
    }

    /**
     * @notice Returns the address of ISUIUSDOracle
     * @return The ISUIUSDOracle contract address
     */
    function getSUIUSDOracleAddress() internal pure returns (address) {
        return 0x98ECE0D516f891a35278E3186772fb1545b274eB;
    }

    /**
     * @notice Returns the address of ISUSHI
     * @return The ISUSHI contract address
     */
    function getSUSHIAddress() internal pure returns (address) {
        return 0x17BFF452dae47e07CeA877Ff0E1aba17eB62b0aB;
    }

    /**
     * @notice Returns the address of ISushiTickLens
     * @return The ISushiTickLens contract address
     */
    function getSushiTickLensAddress() internal pure returns (address) {
        return 0x35DC3E13469E980c37b6F288BBb9822B1f9bD435;
    }

    /**
     * @notice Returns the address of ISUSHIUSDOracle
     * @return The ISUSHIUSDOracle contract address
     */
    function getSUSHIUSDOracleAddress() internal pure returns (address) {
        return 0xA30C356781E5e1b455b274cdDe524FB7BF3809da;
    }

    /**
     * @notice Returns the address of ISushiV2Factory
     * @return The ISushiV2Factory contract address
     */
    function getSushiV2FactoryAddress() internal pure returns (address) {
        return 0x72D111b4d6f31B38919ae39779f570b747d6Acd9;
    }

    /**
     * @notice Returns the address of ITokenAttributesRepository
     * @return The ITokenAttributesRepository contract address
     */
    function getTokenAttributesRepositoryAddress() internal pure returns (address) {
        return 0xC3f5961F6Bf6A60A6d2F9f45Ec477E1E46144827;
    }

    /**
     * @notice Returns the address of IUSDCNativeConverter
     * @return The IUSDCNativeConverter contract address
     */
    function getUSDCNativeConverterAddress() internal pure returns (address) {
        return 0x97a3500083348A147F419b8a65717909762c389f;
    }

    /**
     * @notice Returns the address of IUSDCUSDOracle
     * @return The IUSDCUSDOracle contract address
     */
    function getUSDCUSDOracleAddress() internal pure returns (address) {
        return 0xbe5CE90e16B9d9d988D64b0E1f6ed46EbAfb9606;
    }

    /**
     * @notice Returns the address of IUSDSNativeConverter
     * @return The IUSDSNativeConverter contract address
     */
    function getUSDSNativeConverterAddress() internal pure returns (address) {
        return 0x639f13D5f30B47c792b6851238c05D0b623C77DE;
    }

    /**
     * @notice Returns the address of IUSDSUSDOracle
     * @return The IUSDSUSDOracle contract address
     */
    function getUSDSUSDOracleAddress() internal pure returns (address) {
        return 0x44cdCd6F81cEe5BAC68B21845Fc82846ee09A369;
    }

    /**
     * @notice Returns the address of IUSDTNativeConverter
     * @return The IUSDTNativeConverter contract address
     */
    function getUSDTNativeConverterAddress() internal pure returns (address) {
        return 0x053FA9b934b83E1E0ffc7e98a41aAdc3640bB462;
    }

    /**
     * @notice Returns the address of IUSDTUSDOracle
     * @return The IUSDTUSDOracle contract address
     */
    function getUSDTUSDOracleAddress() internal pure returns (address) {
        return 0xF03E1566Fc6B0eBFA3dD3aA197759C4c6617ec78;
    }

    /**
     * @notice Returns the address of IuSUI
     * @return The IuSUI contract address
     */
    function getIuSUIAddress() internal pure returns (address) {
        return 0xb0505e5a99abd03d94a1169e638B78EDfEd26ea4;
    }

    /**
     * @notice Returns the address of IWBTCBTCOracle
     * @return The IWBTCBTCOracle contract address
     */
    function getWBTCBTCOracleAddress() internal pure returns (address) {
        return 0xAd2937e7D25c237856B03319265465C0291b1895;
    }

    /**
     * @notice Returns the address of IWBTCNativeConverter
     * @return The IWBTCNativeConverter contract address
     */
    function getWBTCNativeConverterAddress() internal pure returns (address) {
        return 0xb00aa68b87256E2F22058fB2Ba3246EEc54A44fc;
    }

    /**
     * @notice Returns the address of IWBTCUSDOracle
     * @return The IWBTCUSDOracle contract address
     */
    function getWBTCUSDOracleAddress() internal pure returns (address) {
        return 0xE5E307A3aEDf4e8eF60E1bfCc9ccD477dFad93ce;
    }

    /**
     * @notice Returns the address of IWBTCUSDOracle_oracles_chainlink_IWBTCUSDOracle
     * @return The IWBTCUSDOracle_oracles_chainlink_IWBTCUSDOracle contract address
     */
    function getWBTCUSDOracle_oracles_chainlink_IWBTCUSDOracleAddress() internal pure returns (address) {
        return 0x0D03E26E0B5D09E24E5a45696D0FcA12E9648FBB;
    }

    /**
     * @notice Returns the address of IweETH
     * @return The IweETH contract address
     */
    function getIweETHAddress() internal pure returns (address) {
        return 0x9893989433e7a383Cb313953e4c2365107dc19a7;
    }

    /**
     * @notice Returns the address of IweETHETHOracle
     * @return The IweETHETHOracle contract address
     */
    function getIweETHETHOracleAddress() internal pure returns (address) {
        return 0xe8D9FbC10e00ecc9f0694617075fDAF657a76FB2;
    }

    /**
     * @notice Returns the address of IweETHETHOracle_oracles_chainlink_IweETHETHOracle
     * @return The IweETHETHOracle_oracles_chainlink_IweETHETHOracle contract address
     */
    function getIweETHETHOracle_oracles_chainlink_IweETHETHOracleAddress() internal pure returns (address) {
        return 0x3Eae75C0a2f9b1038C7c9993C1Da36281E838811;
    }

    /**
     * @notice Returns the address of IweETHUSDOracle
     * @return The IweETHUSDOracle contract address
     */
    function getIweETHUSDOracleAddress() internal pure returns (address) {
        return 0xDd87FD0FD6F68AcB6897d05fCf31F3AB1165a49F;
    }

    /**
     * @notice Returns the address of IWETHNativeConverter
     * @return The IWETHNativeConverter contract address
     */
    function getWETHNativeConverterAddress() internal pure returns (address) {
        return 0xa6B0DB1293144Ebe9478B6a84F75dd651E45914a;
    }

    /**
     * @notice Returns the address of IwstETH
     * @return The IwstETH contract address
     */
    function getIwstETHAddress() internal pure returns (address) {
        return 0x7Fb4D0f51544F24F385a421Db6e7D4fC71Ad8e5C;
    }

    /**
     * @notice Returns the address of IwstETHETHOracle
     * @return The IwstETHETHOracle contract address
     */
    function getIwstETHETHOracleAddress() internal pure returns (address) {
        return 0xCB568C33EA2B0B81852655d722E3a52d9D44e7De;
    }

    /**
     * @notice Returns the address of IwstETHstETHOracle
     * @return The IwstETHstETHOracle contract address
     */
    function getIwstETHstETHOracleAddress() internal pure returns (address) {
        return 0x31a36CdF4465ba61ce78F5CDbA26FDF8ec361803;
    }

    /**
     * @notice Returns the address of IwstETHUSDOracle
     * @return The IwstETHUSDOracle contract address
     */
    function getIwstETHUSDOracleAddress() internal pure returns (address) {
        return 0xE23eCA12D7D2ED3829499556F6dCE06642AFd990;
    }

    /**
     * @notice Returns the address of IXRPUSDOracle
     * @return The IXRPUSDOracle contract address
     */
    function getXRPUSDOracleAddress() internal pure returns (address) {
        return 0xb4fe9028A4D4D8B3d00e52341F2BB0798860532C;
    }

    /**
     * @notice Returns the address of IYFI
     * @return The IYFI contract address
     */
    function getYFIAddress() internal pure returns (address) {
        return 0x476eaCd417cD65421bD34fca054377658BB5E02b;
    }

    /**
     * @notice Returns the address of IYFIUSDOracle
     * @return The IYFIUSDOracle contract address
     */
    function getYFIUSDOracleAddress() internal pure returns (address) {
        return 0xfcDcCF5C2BEAB72FDb910481beaE807F5453686B;
    }

    /**
     * @notice Returns the address of IyUSDUSDOracle
     * @return The IyUSDUSDOracle contract address
     */
    function getIyUSDUSDOracleAddress() internal pure returns (address) {
        return 0xe61b585418B92917771c89D4d3957707cfFE6154;
    }

    /**
     * @notice Returns the address of IYvAUSD
     * @return The IYvAUSD contract address
     */
    function getYvAUSDAddress() internal pure returns (address) {
        return 0x93Fec6639717b6215A48E5a72a162C50DCC40d68;
    }

    /**
     * @notice Returns the address of Multicall
     * @return The Multicall contract address
     */
    function getMulticallAddress() internal pure returns (address) {
        return 0x1F4c1E0afBeb5b5B86d7722549274434b29884F6;
    }

    /**
     * @notice Returns the address of Multicall2
     * @return The Multicall2 contract address
     */
    function getMulticall2Address() internal pure returns (address) {
        return 0xe9128E672bc08E12deb1C2048E9f91e6D6E08e74;
    }

    /**
     * @notice Returns the address of SushiV3Factory
     * @return The SushiV3Factory contract address
     */
    function getSushiV3FactoryAddress() internal pure returns (address) {
        return 0x203e8740894c8955cB8950759876d7E7E45E04c1;
    }

    /**
     * @notice Returns the address of SushiV3PositionManager
     * @return The SushiV3PositionManager contract address
     */
    function getSushiV3PositionManagerAddress() internal pure returns (address) {
        return 0x2659C6085D26144117D904C46B48B6d180393d27;
    }

    /**
     * @notice Returns the address of UniswapV2Router02
     * @return The UniswapV2Router02 contract address
     */
    function getUniswapV2Router02Address() internal pure returns (address) {
        return 0x69cC349932ae18ED406eeB917d79b9b3033fB68E;
    }

}


================================================
FILE: contracts/utils/KatanaOriginAddresses.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title KatanaOriginAddresses
 * @notice Library for accessing origin chain contract addresses when operating in Katana context
 * @dev Auto-generated from contract doccomments. Do not edit manually.
 *      These are contracts deployed on origin chains (Ethereum/Sepolia) that are accessed
 *      from the Katana context for cross-chain operations like Vault Bridge.
 */
library KatanaOriginAddresses {
    /**
     * @notice Returns the origin chain address of IAUSD
     * @dev This contract is deployed on ethereum and accessed from Katana context
     * @return The IAUSD contract address on ethereum
     */
    function getAUSDAddress() internal pure returns (address) {
        return 0x00000000eFE302BEAA2b3e6e1b18d08D69a9012a;
    }

    /**
     * @notice Returns the origin chain address of ILBTC
     * @dev This contract is deployed on ethereum and accessed from Katana context
     * @return The ILBTC contract address on ethereum
     */
    function getLBTCAddress() internal pure returns (address) {
        return 0x8236a87084f8b84306f72007f36f2618a5634494;
    }

    /**
     * @notice Returns the origin chain address of IMigrationManager
     * @dev This contract is deployed on ethereum and accessed from Katana context
     * @return The IMigrationManager contract address on ethereum
     */
    function getMigrationManagerAddress() internal pure returns (address) {
        return 0x417d01B64Ea30C4E163873f3a1f77b727c689e02;
    }

    /**
     * @notice Returns the origin chain address of IMORPHO
     * @dev This contract is deployed on ethereum and accessed from Katana context
     * @return The IMORPHO contract address on ethereum
     */
    function getMORPHOAddress() internal pure returns (address) {
        return 0x58d97b57bb95320f9a05dc918aef65434969c2b2;
    }

    /**
     * @notice Returns the origin chain address of IPOL
     * @dev This contract is deployed on ethereum and accessed from Katana context
     * @return The IPOL contract address on ethereum
     */
    function getPOLAddress() internal pure returns (address) {
        return 0x455e53CBB86018Ac2B8092FdCd39d8444aFFC3F6;
    }

    /**
     * @notice Returns the origin chain address of IPROVE
     * @dev This contract is deployed on ethereum and accessed from Katana context
     * @return The IPROVE contract address on ethereum
     */
    function getPROVEAddress() internal pure returns (address) {
        return 0x6bef15d938d4e72056ac92ea4bdd0d76b1c4ad29;
    }

    /**
     * @notice Returns the origin chain address of ISUSHI
     * @dev This contract is deployed on ethereum and accessed from Katana context
     * @return The ISUSHI contract address on ethereum
     */
    function getSUSHIAddress() internal pure returns (address) {
        return 0x6b3595068778dd592e39a122f4f5a5cf09c90fe2;
    }

    /**
     * @notice Returns the origin chain address of IvbETH
     * @dev This contract is deployed on ethereum and accessed from Katana context
     * @return The IvbETH contract address on ethereum
     */
    function getIvbETHAddress() internal pure returns (address) {
        return 0x2DC70fb75b88d2eB4715bc06E1595E6D97c34DFF;
    }

    /**
     * @notice Returns the origin chain address of IvbUSDC
     * @dev This contract is deployed on ethereum and accessed from Katana context
     * @return The IvbUSDC contract address on ethereum
     */
    function getIvbUSDCAddress() internal pure returns (address) {
        return 0x53E82ABbb12638F09d9e624578ccB666217a765e;
    }

    /**
     * @notice Returns the origin chain address of IvbUSDS
     * @dev This contract is deployed on ethereum and accessed from Katana context
     * @return The IvbUSDS contract address on ethereum
     */
    function getIvbUSDSAddress() internal pure returns (address) {
        return 0x3DD459dE96F9C28e3a343b831cbDC2B93c8C4855;
    }

    /**
     * @notice Returns the origin chain address of IvbUSDT
     * @dev This contract is deployed on ethereum and accessed from Katana context
     * @return The IvbUSDT contract address on ethereum
     */
    function getIvbUSDTAddress() internal pure returns (address) {
        return 0x6d4f9f9f8f0155509ecd6Ac6c544fF27999845CC;
    }

    /**
     * @notice Returns the origin chain address of IvbWBTC
     * @dev This contract is deployed on ethereum and accessed from Katana context
     * @return The IvbWBTC contract address on ethereum
     */
    function getIvbWBTCAddress() internal pure returns (address) {
        return 0x2C24B57e2CCd1f273045Af6A5f632504C432374F;
    }

    /**
     * @notice Returns the origin chain address of IweETH
     * @dev This contract is deployed on ethereum and accessed from Katana context
     * @return The IweETH contract address on ethereum
     */
    function getIweETHAddress() internal pure returns (address) {
        return 0xcd5fe23c85820f7b72d0926fc9b05b43e359b7ee;
    }

    /**
     * @notice Returns the origin chain address of IwstETH
     * @dev This contract is deployed on ethereum and accessed from Katana context
     * @return The IwstETH contract address on ethereum
     */
    function getIwstETHAddress() internal pure returns (address) {
        return 0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0;
    }

    /**
     * @notice Returns the origin chain address of IYFI
     * @dev This contract is deployed on ethereum and accessed from Katana context
     * @return The IYFI contract address on ethereum
     */
    function getYFIAddress() internal pure returns (address) {
        return 0x0bc529c00c6401aef6d220be8c6ea1667f6ad93e;
    }

}


================================================
FILE: contracts/utils/TataraAddresses.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title TataraAddresses
 * @notice Library for accessing Tatara network contract addresses
 * @dev Auto-generated from contract doccomments. Do not edit manually.
 */
library TataraAddresses {
    /**
     * @notice Chain ID for Tatara network
     */
    uint256 internal constant CHAIN_ID = 129399;

    /**
     * @notice Returns the address of IAgoraFaucet
     * @return The IAgoraFaucet contract address
     */
    function getAgoraFaucetAddress() internal pure returns (address) {
        return 0xd236c18D274E54FAccC3dd9DDA4b27965a73ee6C;
    }

    /**
     * @notice Returns the address of IAUSD
     * @return The IAUSD contract address
     */
    function getAUSDAddress() internal pure returns (address) {
        return 0xa9012a055bd4e0eDfF8Ce09f960291C09D5322dC;
    }

    /**
     * @notice Returns the address of IBatchDistributor
     * @return The IBatchDistributor contract address
     */
    function getBatchDistributorAddress() internal pure returns (address) {
        return 0x36C38895A20c835F9A6A294821D669995eB2265E;
    }

    /**
     * @notice Returns the address of IBridgeL2SovereignChain
     * @return The IBridgeL2SovereignChain contract address
     */
    function getBridgeL2SovereignChainAddress() internal pure returns (address) {
        return 0x528e26b25a34a4A5d0dbDa1d57D318153d2ED582;
    }

    /**
     * @notice Returns the address of IBundler3
     * @return The IBundler3 contract address
     */
    function getBundler3Address() internal pure returns (address) {
        return 0xD0bDf3E62F6750Bd83A50b4001743898Af287009;
    }

    /**
     * @notice Returns the address of IbvbEth
     * @return The IbvbEth contract address
     */
    function getIbvbEthAddress() internal pure returns (address) {
        return 0x17B8Ee96E3bcB3b04b3e8334de4524520C51caB4;
    }

    /**
     * @notice Returns the address of IbvbUSDC
     * @return The IbvbUSDC contract address
     */
    function getIbvbUSDCAddress() internal pure returns (address) {
        return 0x102E14ffF48170F2e5b6d0e30259fCD4eE5E28aE;
    }

    /**
     * @notice Returns the address of IbvbUSDS
     * @return The IbvbUSDS contract address
     */
    function getIbvbUSDSAddress() internal pure returns (address) {
        return 0xD416d04845d299bCC0e5105414C99fFc88f0C97d;
    }

    /**
     * @notice Returns the address of IbvbUSDT
     * @return The IbvbUSDT contract address
     */
    function getIbvbUSDTAddress() internal pure returns (address) {
        return 0xDe51Ef59663e79B494E1236551187399D3359C92;
    }

    /**
     * @notice Returns the address of IbvbWBTC
     * @return The IbvbWBTC contract address
     */
    function getIbvbWBTCAddress() internal pure returns (address) {
        return 0x1538aDF273f6f13CcdcdBa41A5ce4b2DC2177D1C;
    }

    /**
     * @notice Returns the address of IConduitController
     * @return The IConduitController contract address
     */
    function getConduitControllerAddress() internal pure returns (address) {
        return 0x00000000F9490004C11Cef243f5400493c00Ad63;
    }

    /**
     * @notice Returns the address of ICreate2Deployer
     * @return The ICreate2Deployer contract address
     */
    function getCreate2DeployerAddress() internal pure returns (address) {
        return 0x13b0D85CcB8bf860b6b79AF3029fCA081AE9beF2;
    }

    /**
     * @notice Returns the address of ICreateX
     * @return The ICreateX contract address
     */
    function getCreateXAddress() internal pure returns (address) {
        return 0xba5Ed099633D3B313e4D5F7bdc1305d3c28ba5Ed;
    }

    /**
     * @notice Returns the address of IDeterministicDeploymentProxy
     * @return The IDeterministicDeploymentProxy contract address
     */
    function getDeterministicDeploymentProxyAddress() internal pure returns (address) {
        return 0x4e59b44847b379578588920cA78FbF26c0B4956C;
    }

    /**
     * @notice Returns the address of IEntryPoint
     * @return The IEntryPoint contract address
     */
    function getEntryPointAddress() internal pure returns (address) {
        return 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789;
    }

    /**
     * @notice Returns the address of IEntryPointSimulations
     * @return The IEntryPointSimulations contract address
     */
    function getEntryPointSimulationsAddress() internal pure returns (address) {
        return 0x0000000071727De22E5E9d8BAf0edAc6f37da032;
    }

    /**
     * @notice Returns the address of IGlobalExitRootManagerL2SovereignChain
     * @return The IGlobalExitRootManagerL2SovereignChain contract address
     */
    function getGlobalExitRootManagerL2SovereignChainAddress() internal pure returns (address) {
        return 0xa40D5f56745a118D0906a34E69aeC8C0Db1cB8fA;
    }

    /**
     * @notice Returns the address of IGnosisSafe
     * @return The IGnosisSafe contract address
     */
    function getGnosisSafeAddress() internal pure returns (address) {
        return 0x69f4D1788e39c87893C980c06EdF4b7f686e2938;
    }

    /**
     * @notice Returns the address of IGnosisSafeL2
     * @return The IGnosisSafeL2 contract address
     */
    function getGnosisSafeL2Address() internal pure returns (address) {
        return 0xfb1bffC9d739B8D520DaF37dF666da4C687191EA;
    }

    /**
     * @notice Returns the address of IMetaMorphoFactory
     * @return The IMetaMorphoFactory contract address
     */
    function getMetaMorphoFactoryAddress() internal pure returns (address) {
        return 0x505619071bdCDeA154f164b323B6C42Fc14257f7;
    }

    /**
     * @notice Returns the address of IMorphoAdaptiveIRM
     * @return The IMorphoAdaptiveIRM contract address
     */
    function getMorphoAdaptiveIRMAddress() internal pure returns (address) {
        return 0x9eB6d0D85FCc07Bf34D69913031ade9E16BD5dB0;
    }

    /**
     * @notice Returns the address of IMorphoBlue
     * @return The IMorphoBlue contract address
     */
    function getMorphoBlueAddress() internal pure returns (address) {
        return 0xC263190b99ceb7e2b7409059D24CB573e3bB9021;
    }

    /**
     * @notice Returns the address of IMorphoChainlinkOracleV2Factory
     * @return The IMorphoChainlinkOracleV2Factory contract address
     */
    function getMorphoChainlinkOracleV2FactoryAddress() internal pure returns (address) {
        return 0xe795DD345aD7E1bC9e8F6B4437a21704d731F9E0;
    }

    /**
     * @notice Returns the address of IMulticall3
     * @return The IMulticall3 contract address
     */
    function getMulticall3Address() internal pure returns (address) {
        return 0xcA11bde05977b3631167028862bE2a173976CA11;
    }

    /**
     * @notice Returns the address of IMultiSend
     * @return The IMultiSend contract address
     */
    function getMultiSendAddress() internal pure returns (address) {
        return 0x998739BFdAAdde7C933B942a68053933098f9EDa;
    }

    /**
     * @notice Returns the address of IMultiSendCallOnly
     * @return The IMultiSendCallOnly contract address
     */
    function getMultiSendCallOnlyAddress() internal pure returns (address) {
        return 0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B;
    }

    /**
     * @notice Returns the address of IPermit2
     * @return The IPermit2 contract address
     */
    function getPermit2Address() internal pure returns (address) {
        return 0x000000000022D473030F116dDEE9F6B43aC78BA3;
    }

    /**
     * @notice Returns the address of IPolygonZkEVMDeployer
     * @return The IPolygonZkEVMDeployer contract address
     */
    function getPolygonZkEVMDeployerAddress() internal pure returns (address) {
        return 0x36810012486fc134D0679c07f85fe5ba5A087D8C;
    }

    /**
     * @notice Returns the address of IPolygonZkEVMTimelock
     * @return The IPolygonZkEVMTimelock contract address
     */
    function getPolygonZkEVMTimelockAddress() internal pure returns (address) {
        return 0xdbC6981a11fc2B000c635bFA7C47676b25C87D39;
    }

    /**
     * @notice Returns the address of IProxyAdmin
     * @return The IProxyAdmin contract address
     */
    function getProxyAdminAddress() internal pure returns (address) {
        return 0x85cEB41028B1a5ED2b88E395145344837308b251;
    }

    /**
     * @notice Returns the address of IPublicAllocator
     * @return The IPublicAllocator contract address
     */
    function getPublicAllocatorAddress() internal pure returns (address) {
        return 0x8FfD3815919081bDb60CD8079C68444331B65042;
    }

    /**
     * @notice Returns the address of IRedSnwapper
     * @return The IRedSnwapper contract address
     */
    function getRedSnwapperAddress() internal pure returns (address) {
        return 0xAC4c6e212A361c968F1725b4d055b47E63F80b75;
    }

    /**
     * @notice Returns the address of IRIP7212
     * @return The IRIP7212 contract address
     */
    function getRIP7212Address() internal pure returns (address) {
        return 0x0000000000000000000000000000000000000100;
    }

    /**
     * @notice Returns the address of ISeaport
     * @return The ISeaport contract address
     */
    function getSeaportAddress() internal pure returns (address) {
        return 0x0000000000FFe8B47B3e2130213B802212439497;
    }

    /**
     * @notice Returns the address of ISenderCreator
     * @return The ISenderCreator contract address
     */
    function getSenderCreatorAddress() internal pure returns (address) {
        return 0xEFC2c1444eBCC4Db75e7613d20C6a62fF67A167C;
    }

    /**
     * @notice Returns the address of ISenderCreator_AAv0_6_0_ISenderCreator
     * @return The ISenderCreator_AAv0_6_0_ISenderCreator contract address
     */
    function getSenderCreator_AAv0_6_0_ISenderCreatorAddress() internal pure returns (address) {
        return 0x7fc98430eAEdbb6070B35B39D798725049088348;
    }

    /**
     * @notice Returns the address of ISushiRouter
     * @return The ISushiRouter contract address
     */
    function getSushiRouterAddress() internal pure returns (address) {
        return 0xAC4c6e212A361c968F1725b4d055b47E63F80b75;
    }

    /**
     * @notice Returns the address of ISushiTickLens
     * @return The ISushiTickLens contract address
     */
    function getSushiTickLensAddress() internal pure returns (address) {
        return 0xb46e319390de313b8cc95ea5aa30c7bbfd79da94;
    }

    /**
     * @notice Returns the address of ISushiV2Factory
     * @return The ISushiV2Factory contract address
     */
    function getSushiV2FactoryAddress() internal pure returns (address) {
        return 0xb45e53277a7e0f1d35f2a77160e91e25507f1763;
    }

    /**
     * @notice Returns the address of IuBTC
     * @return The IuBTC contract address
     */
    function getIuBTCAddress() internal pure returns (address) {
        return 0xB295FDad3aD8521E9Bc20CAeBB36A4258038574e;
    }

    /**
     * @notice Returns the address of IUSDCNativeConverter
     * @return The IUSDCNativeConverter contract address
     */
    function getUSDCNativeConverterAddress() internal pure returns (address) {
        return 0x28FDCaF075242719b16D342866c9dd84cC459533;
    }

    /**
     * @notice Returns the address of IUSDSNativeConverter
     * @return The IUSDSNativeConverter contract address
     */
    function getUSDSNativeConverterAddress() internal pure returns (address) {
        return 0x56342E6093381E2Bd732FFd6141b22136efB98Bf;
    }

    /**
     * @notice Returns the address of IUSDTNativeConverter
     * @return The IUSDTNativeConverter contract address
     */
    function getUSDTNativeConverterAddress() internal pure returns (address) {
        return 0x8f3a47e64d3AD1fBdC5C23adD53183CcCD05D8a4;
    }

    /**
     * @notice Returns the address of IuSOL
     * @return The IuSOL contract address
     */
    function getIuSOLAddress() internal pure returns (address) {
        return 0x79b2417686870EFf463E37a1cA0fDA1c7e2442cE;
    }

    /**
     * @notice Returns the address of IuXRP
     * @return The IuXRP contract address
     */
    function getIuXRPAddress() internal pure returns (address) {
        return 0x26435983DF976A02C55aC28e6F67C6477bBd95E7;
    }

    /**
     * @notice Returns the address of IWBTCNativeConverter
     * @return The IWBTCNativeConverter contract address
     */
    function getWBTCNativeConverterAddress() internal pure returns (address) {
        return 0x3Ef265DD0b4B86fC51b08D5B03699E57d52C9B27;
    }

    /**
     * @notice Returns the address of IWETHNativeConverter
     * @return The IWETHNativeConverter contract address
     */
    function getWETHNativeConverterAddress() internal pure returns (address) {
        return 0x3aFbD158CF7B1E6BE4dAC88bC173FA65EBDf2EcD;
    }

    /**
     * @notice Returns the address of IYvAUSD
     * @return The IYvAUSD contract address
     */
    function getYvAUSDAddress() internal pure returns (address) {
        return 0xAe4b2FCf45566893Ee5009BA36792D5078e4AD60;
    }

    /**
     * @notice Returns the address of IYvWETH
     * @return The IYvWETH contract address
     */
    function getYvWETHAddress() internal pure returns (address) {
        return 0xccC0Fc2E34428120f985b460b487eB79E3C6FA57;
    }

    /**
     * @notice Returns the address of Multicall
     * @return The Multicall contract address
     */
    function getMulticallAddress() internal pure returns (address) {
        return 0x4e1d97344FFa4B55A2C6335574982aa9cB627C4F;
    }

    /**
     * @notice Returns the address of Multicall2
     * @return The Multicall2 contract address
     */
    function getMulticall2Address() internal pure returns (address) {
        return 0xfC0F3dADD7aE3708f352610aa71dF7C93087a676;
    }

    /**
     * @notice Returns the address of MyInterface
     * @return The MyInterface contract address
     */
    function getMyInterfaceAddress() internal pure returns (address) {
        return 0x0000000071727De22E5E9d8BAf0edAc6f37da032;
    }

    /**
     * @notice Returns the address of SushiV3Factory
     * @return The SushiV3Factory contract address
     */
    function getSushiV3FactoryAddress() internal pure returns (address) {
        return 0x9B3336186a38E1b6c21955d112dbb0343Ee061eE;
    }

    /**
     * @notice Returns the address of SushiV3PositionManager
     * @return The SushiV3PositionManager contract address
     */
    function getSushiV3PositionManagerAddress() internal pure returns (address) {
        return 0x1400feFD6F9b897970f00Df6237Ff2B8b27Dc82C;
    }

    /**
     * @notice Returns the address of UniswapV2Router02
     * @return The UniswapV2Router02 contract address
     */
    function getUniswapV2Router02Address() internal pure returns (address) {
        return 0x57bffa72db682f7eb6c132dae03ff36bbeb0c459;
    }

}


================================================
FILE: contracts/utils/TataraOriginAddresses.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title TataraOriginAddresses
 * @notice Library for accessing origin chain contract addresses when operating in Tatara context
 * @dev Auto-generated from contract doccomments. Do not edit manually.
 *      These are contracts deployed on origin chains (Ethereum/Sepolia) that are accessed
 *      from the Tatara context for cross-chain operations like Vault Bridge.
 */
library TataraOriginAddresses {
    /**
     * @notice Returns the origin chain address of IvbETH
     * @dev This contract is deployed on sepolia and accessed from Tatara context
     * @return The IvbETH contract address on sepolia
     */
    function getIvbETHAddress() internal pure returns (address) {
        return 0x4CcD4CbDE5Ec758cCBf75f0be280647Ff359c17a;
    }

    /**
     * @notice Returns the origin chain address of IvbUSDC
     * @dev This contract is deployed on sepolia and accessed from Tatara context
     * @return The IvbUSDC contract address on sepolia
     */
    function getIvbUSDCAddress() internal pure returns (address) {
        return 0x4C8414eBFE5A55eA5859aF373371EE3233fFF7CD;
    }

    /**
     * @notice Returns the origin chain address of IvbUSDS
     * @dev This contract is deployed on sepolia and accessed from Tatara context
     * @return The IvbUSDS contract address on sepolia
     */
    function getIvbUSDSAddress() internal pure returns (address) {
        return 0x56b89A124376CB0481c93C3d94f821F262Dc0D7A;
    }

    /**
     * @notice Returns the origin chain address of IvbUSDT
     * @dev This contract is deployed on sepolia and accessed from Tatara context
     * @return The IvbUSDT contract address on sepolia
     */
    function getIvbUSDTAddress() internal pure returns (address) {
        return 0xb3f50565f611D645e0DDB44eB09c4588B1601514;
    }

    /**
     * @notice Returns the origin chain address of IvbWBTC
     * @dev This contract is deployed on sepolia and accessed from Tatara context
     * @return The IvbWBTC contract address on sepolia
     */
    function getIvbWBTCAddress() internal pure returns (address) {
        return 0xa278D086289f71a30D237feccBAF3698E43Bc5D6;
    }

}


================================================
FILE: contracts/vb/IBridgedVaultBridgeEth.sol
================================================
// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity ^0.8.20;

/**
 * @title IBridgedVaultBridgeEth
 * @notice Interface for Bridged Vault Bridge ETH token
 * @dev Bridged version of VaultBridge ETH on destination chains
 * @custom:tags vaultbridge,token,eth,bridge,yield
 */
interface IBridgedVaultBridgeEth {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error AssetsTooLarge(uint256 availableAssets, uint256 requestedAssets);
    error ECDSAInvalidSignature();
    error ECDSAInvalidSignatureLength(uint256 length);
    error ECDSAInvalidSignatureS(bytes32 s);
    error ERC20InsufficientAllowance(
        address spender,
        uint256 allowance,
        uint256 needed
    );
    error ERC20InsufficientBalance(
        address sender,
        uint256 balance,
        uint256 needed
    );
    error ERC20InvalidApprover(address approver);
    error ERC20InvalidReceiver(address receiver);
    error ERC20InvalidSender(address sender);
    error ERC20InvalidSpender(address spender);
    error ERC2612ExpiredSignature(uint256 deadline);
    error ERC2612InvalidSigner(address signer, address owner);
    error EnforcedPause();
    error ExpectedPause();
    error FunctionNotSupportedOnThisNetwork();
    error InvalidAccountNonce(address account, uint256 currentNonce);
    error InvalidInitialization();
    error InvalidLxLyBridge();
    error InvalidName();
    error InvalidNativeConverter();
    error InvalidOriginalUnderlyingTokenDecimals();
    error InvalidOwner();
    error InvalidSymbol();
    error NotInitializing();
    error ReentrancyGuardReentrantCall();
    error Unauthorized();
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
    event Deposit(address indexed from, uint256 value);
    event EIP712DomainChanged();
    event Initialized(uint64 version);
    event Paused(address account);
    event RoleAdminChanged(
        bytes32 indexed role,
        bytes32 indexed previousAdminRole,
        bytes32 indexed newAdminRole
    );
    event RoleGranted(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );
    event RoleRevoked(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Unpaused(address account);
    event Withdrawal(address indexed to, uint256 value);

    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);

    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PAUSER_ROLE() external view returns (bytes32);

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function balanceOf(address account) external view returns (uint256);

    function bridgeBackingToLayerX(uint256 amount) external;

    function burn(address account, uint256 value) external;

    function decimals() external view returns (uint8);

    function deposit() external payable;

    function eip712Domain()
        external
        view
        returns (
            bytes1 fields,
            string memory name,
            string memory version,
            uint256 chainId,
            address verifyingContract,
            bytes32 salt,
            uint256[] memory extensions
        );

    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    function grantRole(bytes32 role, address account) external;

    function hasRole(bytes32 role, address account)
        external
        view
        returns (bool);

    function lxlyBridge() external view returns (address);

    function mint(address account, uint256 value) external;

    function name() external view returns (string memory);

    function nativeConverter() external view returns (address);

    function nonces(address owner) external view returns (uint256);

    function pause() external;

    function paused() external view returns (bool);

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    function reinitialize(
        address owner_,
        string memory name_,
        string memory symbol_,
        uint8 originalUnderlyingTokenDecimals_,
        address lxlyBridge_,
        address nativeConverter_
    ) external;

    function renounceRole(bytes32 role, address callerConfirmation) external;

    function revokeRole(bytes32 role, address account) external;

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

    function symbol() external view returns (string memory);

    function totalSupply() external view returns (uint256);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);

    function unpause() external;

    function version() external pure returns (string memory);

    function withdraw(uint256 value) external;

    receive() external payable;
}

// THIS FILE WAS AUTOGENERATED FROM THE FOLLOWING ABI JSON:
/*
[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"AccessControlBadConfirmation","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32","name":"neededRole","type":"bytes32"}],"name":"AccessControlUnauthorizedAccount","type":"error"},{"inputs":[{"internalType":"uint256","name":"availableAssets","type":"uint256"},{"internalType":"uint256","name":"requestedAssets","type":"uint256"}],"name":"AssetsTooLarge","type":"error"},{"inputs":[],"name":"ECDSAInvalidSignature","type":"error"},{"inputs":[{"internalType":"uint256","name":"length","type":"uint256"}],"name":"ECDSAInvalidSignatureLength","type":"error"},{"inputs":[{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"ECDSAInvalidSignatureS","type":"error"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"allowance","type":"uint256"},{"internalType":"uint256","name":"needed","type":"uint256"}],"name":"ERC20InsufficientAllowance","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"balance","type":"uint256"},{"internalType":"uint256","name":"needed","type":"uint256"}],"name":"ERC20InsufficientBalance","type":"error"},{"inputs":[{"internalType":"address","name":"approver","type":"address"}],"name":"ERC20InvalidApprover","type":"error"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"}],"name":"ERC20InvalidReceiver","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"}],"name":"ERC20InvalidSender","type":"error"},{"inputs":[{"internalType":"address","name":"spender","type":"address"}],"name":"ERC20InvalidSpender","type":"error"},{"inputs":[{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"ERC2612ExpiredSignature","type":"error"},{"inputs":[{"internalType":"address","name":"signer","type":"address"},{"internalType":"address","name":"owner","type":"address"}],"name":"ERC2612InvalidSigner","type":"error"},{"inputs":[],"name":"EnforcedPause","type":"error"},{"inputs":[],"name":"ExpectedPause","type":"error"},{"inputs":[],"name":"FunctionNotSupportedOnThisNetwork","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"currentNonce","type":"uint256"}],"name":"InvalidAccountNonce","type":"error"},{"inputs":[],"name":"InvalidInitialization","type":"error"},{"inputs":[],"name":"InvalidLxLyBridge","type":"error"},{"inputs":[],"name":"InvalidName","type":"error"},{"inputs":[],"name":"InvalidNativeConverter","type":"error"},{"inputs":[],"name":"InvalidOriginalUnderlyingTokenDecimals","type":"error"},{"inputs":[],"name":"InvalidOwner","type":"error"},{"inputs":[],"name":"InvalidSymbol","type":"error"},{"inputs":[],"name":"NotInitializing","type":"error"},{"inputs":[],"name":"ReentrancyGuardReentrantCall","type":"error"},{"inputs":[],"name":"Unauthorized","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Deposit","type":"event"},{"anonymous":false,"inputs":[],"name":"EIP712DomainChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint64","name":"version","type":"uint64"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Paused","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Unpaused","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Withdrawal","type":"event"},{"inputs":[],"name":"DEFAULT_ADMIN_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"DOMAIN_SEPARATOR","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"PAUSER_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"bridgeBackingToLayerX","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"eip712Domain","outputs":[{"internalType":"bytes1","name":"fields","type":"bytes1"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"version","type":"string"},{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"address","name":"verifyingContract","type":"address"},{"internalType":"bytes32","name":"salt","type":"bytes32"},{"internalType":"uint256[]","name":"extensions","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"lxlyBridge","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"mint","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nativeConverter","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"nonces","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"permit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner_","type":"address"},{"internalType":"string","name":"name_","type":"string"},{"internalType":"string","name":"symbol_","type":"string"},{"internalType":"uint8","name":"originalUnderlyingTokenDecimals_","type":"uint8"},{"internalType":"address","name":"lxlyBridge_","type":"address"},{"internalType":"address","name":"nativeConverter_","type":"address"}],"name":"reinitialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"callerConfirmation","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"unpause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"version","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"value","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"},{"stateMutability":"payable","type":"receive"}]
*/


================================================
FILE: contracts/vb/IGenericCustomToken.sol
================================================
// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity ^0.8.20;

/**
 * @title IGenericCustomToken
 * @notice Interface for Generic Custom Token contracts
 * @dev Standard interface for bridged custom tokens
 * @custom:tags vaultbridge,token,erc20,custom,bridge
 */
interface IGenericCustomToken {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error ECDSAInvalidSignature();
    error ECDSAInvalidSignatureLength(uint256 length);
    error ECDSAInvalidSignatureS(bytes32 s);
    error ERC20InsufficientAllowance(
        address spender,
        uint256 allowance,
        uint256 needed
    );
    error ERC20InsufficientBalance(
        address sender,
        uint256 balance,
        uint256 needed
    );
    error ERC20InvalidApprover(address approver);
    error ERC20InvalidReceiver(address receiver);
    error ERC20InvalidSender(address sender);
    error ERC20InvalidSpender(address spender);
    error ERC2612ExpiredSignature(uint256 deadline);
    error ERC2612InvalidSigner(address signer, address owner);
    error EnforcedPause();
    error ExpectedPause();
    error InvalidAccountNonce(address account, uint256 currentNonce);
    error InvalidInitialization();
    error InvalidLxLyBridge();
    error InvalidName();
    error InvalidNativeConverter();
    error InvalidOriginalUnderlyingTokenDecimals();
    error InvalidOwner();
    error InvalidSymbol();
    error NotInitializing();
    error ReentrancyGuardReentrantCall();
    error Unauthorized();
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
    event EIP712DomainChanged();
    event Initialized(uint64 version);
    event Paused(address account);
    event RoleAdminChanged(
        bytes32 indexed role,
        bytes32 indexed previousAdminRole,
        bytes32 indexed newAdminRole
    );
    event RoleGranted(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );
    event RoleRevoked(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Unpaused(address account);

    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);

    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PAUSER_ROLE() external view returns (bytes32);

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function balanceOf(address account) external view returns (uint256);

    function burn(address account, uint256 value) external;

    function decimals() external view returns (uint8);

    function eip712Domain()
        external
        view
        returns (
            bytes1 fields,
            string memory name,
            string memory version,
            uint256 chainId,
            address verifyingContract,
            bytes32 salt,
            uint256[] memory extensions
        );

    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    function grantRole(bytes32 role, address account) external;

    function hasRole(bytes32 role, address account)
        external
        view
        returns (bool);

    function lxlyBridge() external view returns (address);

    function mint(address account, uint256 value) external;

    function name() external view returns (string memory);

    function nativeConverter() external view returns (address);

    function nonces(address owner) external view returns (uint256);

    function pause() external;

    function paused() external view returns (bool);

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    function reinitialize(
        address owner_,
        string memory name_,
        string memory symbol_,
        uint8 originalUnderlyingTokenDecimals_,
        address lxlyBridge_,
        address nativeConverter_
    ) external;

    function renounceRole(bytes32 role, address callerConfirmation) external;

    function revokeRole(bytes32 role, address account) external;

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

    function symbol() external view returns (string memory);

    function totalSupply() external view returns (uint256);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);

    function unpause() external;

    function version() external pure returns (string memory);
}

// THIS FILE WAS AUTOGENERATED FROM THE FOLLOWING ABI JSON:
/*
[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"AccessControlBadConfirmation","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32","name":"neededRole","type":"bytes32"}],"name":"AccessControlUnauthorizedAccount","type":"error"},{"inputs":[],"name":"ECDSAInvalidSignature","type":"error"},{"inputs":[{"internalType":"uint256","name":"length","type":"uint256"}],"name":"ECDSAInvalidSignatureLength","type":"error"},{"inputs":[{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"ECDSAInvalidSignatureS","type":"error"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"allowance","type":"uint256"},{"internalType":"uint256","name":"needed","type":"uint256"}],"name":"ERC20InsufficientAllowance","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"balance","type":"uint256"},{"internalType":"uint256","name":"needed","type":"uint256"}],"name":"ERC20InsufficientBalance","type":"error"},{"inputs":[{"internalType":"address","name":"approver","type":"address"}],"name":"ERC20InvalidApprover","type":"error"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"}],"name":"ERC20InvalidReceiver","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"}],"name":"ERC20InvalidSender","type":"error"},{"inputs":[{"internalType":"address","name":"spender","type":"address"}],"name":"ERC20InvalidSpender","type":"error"},{"inputs":[{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"ERC2612ExpiredSignature","type":"error"},{"inputs":[{"internalType":"address","name":"signer","type":"address"},{"internalType":"address","name":"owner","type":"address"}],"name":"ERC2612InvalidSigner","type":"error"},{"inputs":[],"name":"EnforcedPause","type":"error"},{"inputs":[],"name":"ExpectedPause","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"currentNonce","type":"uint256"}],"name":"InvalidAccountNonce","type":"error"},{"inputs":[],"name":"InvalidInitialization","type":"error"},{"inputs":[],"name":"InvalidLxLyBridge","type":"error"},{"inputs":[],"name":"InvalidName","type":"error"},{"inputs":[],"name":"InvalidNativeConverter","type":"error"},{"inputs":[],"name":"InvalidOriginalUnderlyingTokenDecimals","type":"error"},{"inputs":[],"name":"InvalidOwner","type":"error"},{"inputs":[],"name":"InvalidSymbol","type":"error"},{"inputs":[],"name":"NotInitializing","type":"error"},{"inputs":[],"name":"ReentrancyGuardReentrantCall","type":"error"},{"inputs":[],"name":"Unauthorized","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[],"name":"EIP712DomainChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint64","name":"version","type":"uint64"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Paused","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Unpaused","type":"event"},{"inputs":[],"name":"DEFAULT_ADMIN_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"DOMAIN_SEPARATOR","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"PAUSER_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"eip712Domain","outputs":[{"internalType":"bytes1","name":"fields","type":"bytes1"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"version","type":"string"},{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"address","name":"verifyingContract","type":"address"},{"internalType":"bytes32","name":"salt","type":"bytes32"},{"internalType":"uint256[]","name":"extensions","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"lxlyBridge","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"mint","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nativeConverter","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"nonces","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"permit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner_","type":"address"},{"internalType":"string","name":"name_","type":"string"},{"internalType":"string","name":"symbol_","type":"string"},{"internalType":"uint8","name":"originalUnderlyingTokenDecimals_","type":"uint8"},{"internalType":"address","name":"lxlyBridge_","type":"address"},{"internalType":"address","name":"nativeConverter_","type":"address"}],"name":"reinitialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"callerConfirmation","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"unpause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"version","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"}]
*/


================================================
FILE: contracts/vb/IMigrationManager.sol
================================================
// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity ^0.8.20;

/**
 * @title IMigrationManager
 * @notice Interface for the Migration Manager contract. This is deployed on the
   origin chain - for "Katana" this means Ethereum, for "Bokuto" this means
   Sepolia. The address for each context is different, and indicated in custom
   tags.
 * @custom:bokuto sepolia:0x16B46094cb1eE593181Ba2d997E77E88D7E9Ab8F
 * @custom:katana ethereum:0x417d01B64Ea30C4E163873f3a1f77b727c689e02
 * @custom:tags vaultbridge,migration,manager,bridge
 */
interface IMigrationManager {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error CannotWrapGasToken();
    error EnforcedPause();
    error ExpectedPause();
    error InsufficientUnderlyingTokenBalanceAfterWrapping(
        uint256 newBalance,
        uint256 expectedBalance
    );
    error InvalidInitialization();
    error InvalidLayerYLxLyId();
    error InvalidLxLyBridge();
    error InvalidNativeConverter();
    error InvalidOwner();
    error InvalidUnderlyingToken();
    error InvalidVbToken();
    error NonMatchingInputLengths();
    error NotInitializing();
    error ReentrancyGuardReentrantCall();
    error SafeERC20FailedOperation(address token);
    error Unauthorized();
    event Initialized(uint64 version);
    event NativeConverterConfigured(
        uint32 indexed layerYLxlyId,
        address indexed nativeConverter,
        address indexed vbToken
    );
    event Paused(address account);
    event RoleAdminChanged(
        bytes32 indexed role,
        bytes32 indexed previousAdminRole,
        bytes32 indexed newAdminRole
    );
    event RoleGranted(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );
    event RoleRevoked(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );
    event Unpaused(address account);

    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);

    function PAUSER_ROLE() external view returns (bytes32);

    function configureNativeConverters(
        uint32[] memory layerYLxlyIds,
        address[] memory nativeConverters,
        address vbToken
    ) external;

    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    function grantRole(bytes32 role, address account) external;

    function hasRole(bytes32 role, address account)
        external
        view
        returns (bool);

    function initialize(address owner_, address lxlyBridge_) external;

    function lxlyBridge() external view returns (address);

    function nativeConvertersConfiguration(
        uint32 layerYLxlyId,
        address nativeConverter
    ) external view returns (MigrationManager.TokenPair memory tokenPair);

    function onMessageReceived(
        address originAddress,
        uint32 originNetwork,
        bytes memory data
    ) external payable;

    function pause() external;

    function paused() external view returns (bool);

    function renounceRole(bytes32 role, address callerConfirmation) external;

    function revokeRole(bytes32 role, address account) external;

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

    function unpause() external;

    function version() external pure returns (string memory);

    receive() external payable;
}

interface MigrationManager {
    struct TokenPair {
        address vbToken;
        address underlyingToken;
    }
}



================================================
FILE: contracts/vb/INativeConverter.sol
================================================
// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity ^0.8.20;

/**
 * @title INativeConverter
 * @notice Base interface for Native Converter contracts
 * @dev Converts between native and bridged vault tokens
 * @custom:tags vaultbridge,converter,bridge,native
 */
interface INativeConverter {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error AssetsTooLarge(uint256 availableAssets, uint256 requestedAssets);
    error EnforcedPause();
    error ExpectedPause();
    error InvalidAmountInERC20Permit(uint256 amount, uint256 minimumAmount);
    error InvalidAssets();
    error InvalidCustomToken();
    error InvalidDestinationNetworkId();
    error InvalidInitialization();
    error InvalidLayerXLxlyId();
    error InvalidLxLyBridge();
    error InvalidMigrationManager();
    error InvalidNonMigratableBackingPercentage();
    error InvalidOwner();
    error InvalidOwnerInERC20Permit(address owner, address expectedOwner);
    error InvalidPermitData();
    error InvalidReceiver();
    error InvalidSelectorInERC20Permit(bytes4 selector);
    error InvalidShares();
    error InvalidSpenderInERC20Permit(address spender, address expectedSpender);
    error InvalidUnderlyingToken();
    error NonMatchingCustomTokenDecimals(
        uint8 customTokenDecimals,
        uint8 originalUnderlyingTokenDecimals
    );
    error NonMatchingUnderlyingTokenDecimals(
        uint8 underlyingTokenDecimals,
        uint8 originalUnderlyingTokenDecimals
    );
    error NotInitializing();
    error OnlyMigrator();
    error ReentrancyGuardReentrantCall();
    error SafeERC20FailedOperation(address token);
    event Initialized(uint64 version);
    event MigrationStarted(
        uint256 indexed mintedCustomToken,
        uint256 indexed migratedBacking
    );
    event NonMigratableBackingPercentageSet(
        uint256 nonMigratableBackingPercentage
    );
    event Paused(address account);
    event RoleAdminChanged(
        bytes32 indexed role,
        bytes32 indexed previousAdminRole,
        bytes32 indexed newAdminRole
    );
    event RoleGranted(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );
    event RoleRevoked(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );
    event Unpaused(address account);

    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);

    function MIGRATOR_ROLE() external view returns (bytes32);

    function PAUSER_ROLE() external view returns (bytes32);

    function backingOnLayerY() external view returns (uint256);

    function convert(uint256 assets, address receiver)
        external
        returns (uint256 shares);

    function convertWithPermit(
        uint256 assets,
        address receiver,
        bytes memory permitData
    ) external returns (uint256 shares);

    function customToken() external view returns (address);

    function deconvert(uint256 shares, address receiver)
        external
        returns (uint256 assets);

    function deconvertAndBridge(
        uint256 shares,
        address receiver,
        uint32 destinationNetworkId,
        bool forceUpdateGlobalExitRoot
    ) external returns (uint256 assets);

    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    function grantRole(bytes32 role, address account) external;

    function hasRole(bytes32 role, address account)
        external
        view
        returns (bool);

    function initialize(
        address owner_,
        uint8 originalUnderlyingTokenDecimals_,
        address customToken_,
        address underlyingToken_,
        address lxlyBridge_,
        uint32 layerXLxlyId_,
        uint256 nonMigratableBackingPercentage_,
        address migrationManager_
    ) external;

    function layerXLxlyId() external view returns (uint32);

    function lxlyBridge() external view returns (address);

    function lxlyId() external view returns (uint32);

    function maxDeconvert(address owner)
        external
        view
        returns (uint256 maxShares);

    function migratableBacking() external view returns (uint256);

    function migrateBackingToLayerX(uint256 assets) external;

    function migrationManager() external view returns (address);

    function nonMigratableBackingPercentage() external view returns (uint256);

    function pause() external;

    function paused() external view returns (bool);

    function renounceRole(bytes32 role, address callerConfirmation) external;

    function revokeRole(bytes32 role, address account) external;

    function setNonMigratableBackingPercentage(
        uint256 nonMigratableBackingPercentage_
    ) external;

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

    function underlyingToken() external view returns (address);

    function unpause() external;

    function version() external pure returns (string memory);
}


================================================
FILE: contracts/vb/IVaultBridgeToken.sol
================================================
// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity ^0.8.20;

/**
 * @title IVaultBridgeToken
 * @notice Base interface for Vault Bridge Token contracts
 * @dev Core interface for vault bridge token functionality
 * @custom:tags vaultbridge,token,erc20,bridge,yield
 */
interface IVaultBridgeToken {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error AssetsTooLarge(uint256 availableAssets, uint256 requestedAssets);
    error CannotCompleteMigration(
        uint256 requiredAssets,
        uint256 receivedAssets,
        uint256 assetsInMigrationFund
    );
    error CannotRebalanceReserve();
    error ContractNotSupportedOnThisNetwork();
    error ECDSAInvalidSignature();
    error ECDSAInvalidSignatureLength(uint256 length);
    error ECDSAInvalidSignatureS(bytes32 s);
    error ERC20InsufficientAllowance(
        address spender,
        uint256 allowance,
        uint256 needed
    );
    error ERC20InsufficientBalance(
        address sender,
        uint256 balance,
        uint256 needed
    );
    error ERC20InvalidApprover(address approver);
    error ERC20InvalidReceiver(address receiver);
    error ERC20InvalidSender(address sender);
    error ERC20InvalidSpender(address spender);
    error ERC2612ExpiredSignature(uint256 deadline);
    error ERC2612InvalidSigner(address signer, address owner);
    error EnforcedPause();
    error ExcessiveYieldVaultSharesBurned(
        uint256 burnedShares,
        uint256 withdrawnAssets
    );
    error ExpectedPause();
    error IncorrectAmountOfSharesMinted(
        uint256 mintedShares,
        uint256 requiredShares
    );
    error IncorrectAmountOfSharesRedeemed(
        uint256 redeemedShares,
        uint256 requiredShares
    );
    error IncorrectMsgValue(uint256 msgValue, uint256 requestedAssets);
    error InsufficientUnderlyingTokenReceived(
        uint256 receivedAssets,
        uint256 requestedAssets
    );
    error InsufficientYieldVaultSharesMinted(
        uint256 depositedAssets,
        uint256 mintedShares
    );
    error InvalidAccountNonce(address account, uint256 currentNonce);
    error InvalidAmountInERC20Permit(uint256 amount, uint256 minimumAmount);
    error InvalidAssets();
    error InvalidDestinationNetworkId();
    error InvalidInitialization();
    error InvalidInitializer();
    error InvalidLxLyBridge();
    error InvalidMigrationManager();
    error InvalidMinimumReservePercentage();
    error InvalidName();
    error InvalidOriginNetwork();
    error InvalidOwner();
    error InvalidOwnerInERC20Permit(address owner, address expectedOwner);
    error InvalidPermitData();
    error InvalidReceiver();
    error InvalidSelectorInERC20Permit(bytes4 selector);
    error InvalidShares();
    error InvalidSpenderInERC20Permit(address spender, address expectedSpender);
    error InvalidSymbol();
    error InvalidUnderlyingToken();
    error InvalidVaultBridgeTokenPart2();
    error InvalidYieldRecipient();
    error InvalidYieldVault();
    error InvalidYieldVaultMaximumSlippagePercentage();
    error MinimumYieldVaultDepositNotMet(
        uint256 assetsToDeposit,
        uint256 minimumYieldVaultDeposit
    );
    error NoNeedToRebalanceReserve();
    error NoYield();
    error NotInitializing();
    error ReentrancyGuardReentrantCall();
    error SafeERC20FailedOperation(address token);
    error Unauthorized();
    error UnknownError(bytes data);
    error UnknownFunction(bytes4 functionSelector);
    error YieldVaultDepositFailed(
        uint256 assetsToDeposit,
        uint256 depositLimit
    );
    error YieldVaultRedemptionFailed(
        uint256 sharesToRedeem,
        uint256 redemptionLimit
    );
    error YieldVaultWithdrawalFailed(
        uint256 assetsToWithdraw,
        uint256 withdrawalLimit
    );
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
    event Burned(uint256 vbTokenAmount);
    event Deposit(
        address indexed sender,
        address indexed owner,
        uint256 assets,
        uint256 shares
    );
    event DonatedAsYield(address indexed who, uint256 assets);
    event DonatedForCompletingMigration(address indexed who, uint256 assets);
    event EIP712DomainChanged();
    event Initialized(uint64 version);
    event MigrationCompleted(
        uint32 indexed originNetwork,
        uint256 indexed shares,
        uint256 indexed assets,
        uint256 migrationFeesFundUtilization
    );
    event MinimumReservePercentageSet(uint256 minimumReservePercentage);
    event Paused(address account);
    event ReserveRebalanced(
        uint256 oldReservedAssets,
        uint256 newReservedAssets,
        uint256 reservePercentage
    );
    event RoleAdminChanged(
        bytes32 indexed role,
        bytes32 indexed previousAdminRole,
        bytes32 indexed newAdminRole
    );
    event RoleGranted(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );
    event RoleRevoked(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );
    event Transfer(address indexed from, address indexed to, uint256 value);
    event TransferFeeCalculatorSet(address transferFeeCalculator);
    event Unpaused(address account);
    event Withdraw(
        address indexed sender,
        address indexed receiver,
        address indexed owner,
        uint256 assets,
        uint256 shares
    );
    event YieldCollected(address indexed yieldRecipient, uint256 vbTokenAmount);
    event YieldRecipientSet(address indexed yieldRecipient);
    event YieldVaultDrained(uint256 redeemedShares, uint256 receivedAssets);
    event YieldVaultMaximumSlippagePercentageSet(uint256 slippagePercentage);
    event YieldVaultSet(address yieldVault);

    fallback() external payable;

    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);

    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PAUSER_ROLE() external view returns (bytes32);

    function REBALANCER_ROLE() external view returns (bytes32);

    function YIELD_COLLECTOR_ROLE() external view returns (bytes32);

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function asset() external view returns (address assetTokenAddress);

    function backingDifference()
        external
        view
        returns (bool positive, uint256 difference);

    function balanceOf(address account) external view returns (uint256);

    function claimAndRedeem(
        bytes32[32] memory smtProofLocalExitRoot,
        bytes32[32] memory smtProofRollupExitRoot,
        uint256 globalIndex,
        bytes32 mainnetExitRoot,
        bytes32 rollupExitRoot,
        address destinationAddress,
        uint256 amount,
        address receiver,
        bytes memory metadata
    ) external returns (uint256 assets);

    function convertToAssets(uint256 shares)
        external
        pure
        returns (uint256 assets);

    function convertToShares(uint256 assets)
        external
        pure
        returns (uint256 shares);

    function decimals() external view returns (uint8);

    function deposit(uint256 assets, address receiver)
        external
        returns (uint256 shares);

    function depositAndBridge(
        uint256 assets,
        address receiver,
        uint32 destinationNetworkId,
        bool forceUpdateGlobalExitRoot
    ) external returns (uint256 shares);

    function depositGasToken(address receiver)
        external
        payable
        returns (uint256 shares);

    function depositGasTokenAndBridge(
        address destinationAddress,
        uint32 destinationNetworkId,
        bool forceUpdateGlobalExitRoot
    ) external payable returns (uint256 shares);

    function depositWithPermit(
        uint256 assets,
        address receiver,
        bytes memory permitData
    ) external returns (uint256 shares);

    function depositWithPermitAndBridge(
        uint256 assets,
        address receiver,
        uint32 destinationNetworkId,
        bool forceUpdateGlobalExitRoot,
        bytes memory permitData
    ) external returns (uint256 shares);

    function eip712Domain()
        external
        view
        returns (
            bytes1 fields,
            string memory name,
            string memory version,
            uint256 chainId,
            address verifyingContract,
            bytes32 salt,
            uint256[] memory extensions
        );

    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    function grantRole(bytes32 role, address account) external;

    function hasRole(bytes32 role, address account)
        external
        view
        returns (bool);

    function initialize(
        address initializer_,
        VaultBridgeToken.InitializationParameters memory initParams
    ) external;

    function lxlyBridge() external view returns (address);

    function lxlyId() external view returns (uint32);

    function maxDeposit(address) external view returns (uint256 maxAssets);

    function maxMint(address) external view returns (uint256 maxShares);

    function maxRedeem(address owner) external view returns (uint256 maxShares);

    function maxWithdraw(address owner)
        external
        view
        returns (uint256 maxAssets);

    function migrationFeesFund() external view returns (uint256);

    function migrationManager() external view returns (address);

    function minimumReservePercentage() external view returns (uint256);

    function minimumYieldVaultDeposit() external view returns (uint256);

    function mint(uint256 shares, address receiver)
        external
        returns (uint256 assets);

    function mintWithGasToken(uint256 shares, address receiver)
        external
        payable
        returns (uint256 assets);

    function name() external view returns (string memory);

    function nonces(address owner) external view returns (uint256);

    function paused() external view returns (bool);

    function performReversibleYieldVaultDeposit(uint256 assets) external;

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    function previewDeposit(uint256 assets)
        external
        view
        returns (uint256 shares);

    function previewMint(uint256 shares) external view returns (uint256 assets);

    function previewRedeem(uint256 shares)
        external
        view
        returns (uint256 assets);

    function previewWithdraw(uint256 assets)
        external
        view
        returns (uint256 shares);

    function redeem(
        uint256 shares,
        address receiver,
        address owner
    ) external returns (uint256 assets);

    function renounceRole(bytes32 role, address callerConfirmation) external;

    function reservePercentage() external view returns (uint256);

    function reservedAssets() external view returns (uint256);

    function revokeRole(bytes32 role, address account) external;

    function stakedAssets() external view returns (uint256);

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

    function symbol() external view returns (string memory);

    function totalAssets() external view returns (uint256 totalManagedAssets);

    function totalSupply() external view returns (uint256);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);

    function underlyingToken() external view returns (address);

    function version() external pure returns (string memory);

    function withdraw(
        uint256 assets,
        address receiver,
        address owner
    ) external returns (uint256 shares);

    function yield() external view returns (uint256);

    function yieldRecipient() external view returns (address);

    function yieldVault() external view returns (address);

    function yieldVaultMaximumSlippagePercentage()
        external
        view
        returns (uint256);

    receive() external payable;
}

interface VaultBridgeToken {
    struct InitializationParameters {
        address owner;
        string name;
        string symbol;
        address underlyingToken;
        uint256 minimumReservePercentage;
        address yieldVault;
        address yieldRecipient;
        address lxlyBridge;
        uint256 minimumYieldVaultDeposit;
        address migrationManager;
        uint256 yieldVaultMaximumSlippagePercentage;
        address vaultBridgeTokenPart2;
    }
}

// THIS FILE WAS AUTOGENERATED FROM THE FOLLOWING ABI JSON:
/*
[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"AccessControlBadConfirmation","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32","name":"neededRole","type":"bytes32"}],"name":"AccessControlUnauthorizedAccount","type":"error"},{"inputs":[{"internalType":"uint256","name":"availableAssets","type":"uint256"},{"internalType":"uint256","name":"requestedAssets","type":"uint256"}],"name":"AssetsTooLarge","type":"error"},{"inputs":[{"internalType":"uint256","name":"requiredAssets","type":"uint256"},{"internalType":"uint256","name":"receivedAssets","type":"uint256"},{"internalType":"uint256","name":"assetsInMigrationFund","type":"uint256"}],"name":"CannotCompleteMigration","type":"error"},{"inputs":[],"name":"CannotRebalanceReserve","type":"error"},{"inputs":[],"name":"ContractNotSupportedOnThisNetwork","type":"error"},{"inputs":[],"name":"ECDSAInvalidSignature","type":"error"},{"inputs":[{"internalType":"uint256","name":"length","type":"uint256"}],"name":"ECDSAInvalidSignatureLength","type":"error"},{"inputs":[{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"ECDSAInvalidSignatureS","type":"error"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"allowance","type":"uint256"},{"internalType":"uint256","name":"needed","type":"uint256"}],"name":"ERC20InsufficientAllowance","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"balance","type":"uint256"},{"internalType":"uint256","name":"needed","type":"uint256"}],"name":"ERC20InsufficientBalance","type":"error"},{"inputs":[{"internalType":"address","name":"approver","type":"address"}],"name":"ERC20InvalidApprover","type":"error"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"}],"name":"ERC20InvalidReceiver","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"}],"name":"ERC20InvalidSender","type":"error"},{"inputs":[{"internalType":"address","name":"spender","type":"address"}],"name":"ERC20InvalidSpender","type":"error"},{"inputs":[{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"ERC2612ExpiredSignature","type":"error"},{"inputs":[{"internalType":"address","name":"signer","type":"address"},{"internalType":"address","name":"owner","type":"address"}],"name":"ERC2612InvalidSigner","type":"error"},{"inputs":[],"name":"EnforcedPause","type":"error"},{"inputs":[{"internalType":"uint256","name":"burnedShares","type":"uint256"},{"internalType":"uint256","name":"withdrawnAssets","type":"uint256"}],"name":"ExcessiveYieldVaultSharesBurned","type":"error"},{"inputs":[],"name":"ExpectedPause","type":"error"},{"inputs":[{"internalType":"uint256","name":"mintedShares","type":"uint256"},{"internalType":"uint256","name":"requiredShares","type":"uint256"}],"name":"IncorrectAmountOfSharesMinted","type":"error"},{"inputs":[{"internalType":"uint256","name":"redeemedShares","type":"uint256"},{"internalType":"uint256","name":"requiredShares","type":"uint256"}],"name":"IncorrectAmountOfSharesRedeemed","type":"error"},{"inputs":[{"internalType":"uint256","name":"msgValue","type":"uint256"},{"internalType":"uint256","name":"requestedAssets","type":"uint256"}],"name":"IncorrectMsgValue","type":"error"},{"inputs":[{"internalType":"uint256","name":"receivedAssets","type":"uint256"},{"internalType":"uint256","name":"requestedAssets","type":"uint256"}],"name":"InsufficientUnderlyingTokenReceived","type":"error"},{"inputs":[{"internalType":"uint256","name":"depositedAssets","type":"uint256"},{"internalType":"uint256","name":"mintedShares","type":"uint256"}],"name":"InsufficientYieldVaultSharesMinted","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"currentNonce","type":"uint256"}],"name":"InvalidAccountNonce","type":"error"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"minimumAmount","type":"uint256"}],"name":"InvalidAmountInERC20Permit","type":"error"},{"inputs":[],"name":"InvalidAssets","type":"error"},{"inputs":[],"name":"InvalidDestinationNetworkId","type":"error"},{"inputs":[],"name":"InvalidInitialization","type":"error"},{"inputs":[],"name":"InvalidInitializer","type":"error"},{"inputs":[],"name":"InvalidLxLyBridge","type":"error"},{"inputs":[],"name":"InvalidMigrationManager","type":"error"},{"inputs":[],"name":"InvalidMinimumReservePercentage","type":"error"},{"inputs":[],"name":"InvalidName","type":"error"},{"inputs":[],"name":"InvalidOriginNetwork","type":"error"},{"inputs":[],"name":"InvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"expectedOwner","type":"address"}],"name":"InvalidOwnerInERC20Permit","type":"error"},{"inputs":[],"name":"InvalidPermitData","type":"error"},{"inputs":[],"name":"InvalidReceiver","type":"error"},{"inputs":[{"internalType":"bytes4","name":"selector","type":"bytes4"}],"name":"InvalidSelectorInERC20Permit","type":"error"},{"inputs":[],"name":"InvalidShares","type":"error"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"address","name":"expectedSpender","type":"address"}],"name":"InvalidSpenderInERC20Permit","type":"error"},{"inputs":[],"name":"InvalidSymbol","type":"error"},{"inputs":[],"name":"InvalidUnderlyingToken","type":"error"},{"inputs":[],"name":"InvalidVaultBridgeTokenPart2","type":"error"},{"inputs":[],"name":"InvalidYieldRecipient","type":"error"},{"inputs":[],"name":"InvalidYieldVault","type":"error"},{"inputs":[],"name":"InvalidYieldVaultMaximumSlippagePercentage","type":"error"},{"inputs":[{"internalType":"uint256","name":"assetsToDeposit","type":"uint256"},{"internalType":"uint256","name":"minimumYieldVaultDeposit","type":"uint256"}],"name":"MinimumYieldVaultDepositNotMet","type":"error"},{"inputs":[],"name":"NoNeedToRebalanceReserve","type":"error"},{"inputs":[],"name":"NoYield","type":"error"},{"inputs":[],"name":"NotInitializing","type":"error"},{"inputs":[],"name":"ReentrancyGuardReentrantCall","type":"error"},{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"SafeERC20FailedOperation","type":"error"},{"inputs":[],"name":"Unauthorized","type":"error"},{"inputs":[{"internalType":"bytes","name":"data","type":"bytes"}],"name":"UnknownError","type":"error"},{"inputs":[{"internalType":"bytes4","name":"functionSelector","type":"bytes4"}],"name":"UnknownFunction","type":"error"},{"inputs":[{"internalType":"uint256","name":"assetsToDeposit","type":"uint256"},{"internalType":"uint256","name":"depositLimit","type":"uint256"}],"name":"YieldVaultDepositFailed","type":"error"},{"inputs":[{"internalType":"uint256","name":"sharesToRedeem","type":"uint256"},{"internalType":"uint256","name":"redemptionLimit","type":"uint256"}],"name":"YieldVaultRedemptionFailed","type":"error"},{"inputs":[{"internalType":"uint256","name":"assetsToWithdraw","type":"uint256"},{"internalType":"uint256","name":"withdrawalLimit","type":"uint256"}],"name":"YieldVaultWithdrawalFailed","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"vbTokenAmount","type":"uint256"}],"name":"Burned","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":false,"internalType":"uint256","name":"assets","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"shares","type":"uint256"}],"name":"Deposit","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"who","type":"address"},{"indexed":false,"internalType":"uint256","name":"assets","type":"uint256"}],"name":"DonatedAsYield","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"who","type":"address"},{"indexed":false,"internalType":"uint256","name":"assets","type":"uint256"}],"name":"DonatedForCompletingMigration","type":"event"},{"anonymous":false,"inputs":[],"name":"EIP712DomainChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint64","name":"version","type":"uint64"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint32","name":"originNetwork","type":"uint32"},{"indexed":true,"internalType":"uint256","name":"shares","type":"uint256"},{"indexed":true,"internalType":"uint256","name":"assets","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"migrationFeesFundUtilization","type":"uint256"}],"name":"MigrationCompleted","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"minimumReservePercentage","type":"uint256"}],"name":"MinimumReservePercentageSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Paused","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"oldReservedAssets","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"newReservedAssets","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"reservePercentage","type":"uint256"}],"name":"ReserveRebalanced","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"transferFeeCalculator","type":"address"}],"name":"TransferFeeCalculatorSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Unpaused","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":true,"internalType":"address","name":"receiver","type":"address"},{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":false,"internalType":"uint256","name":"assets","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"shares","type":"uint256"}],"name":"Withdraw","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"yieldRecipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"vbTokenAmount","type":"uint256"}],"name":"YieldCollected","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"yieldRecipient","type":"address"}],"name":"YieldRecipientSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"redeemedShares","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"receivedAssets","type":"uint256"}],"name":"YieldVaultDrained","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"slippagePercentage","type":"uint256"}],"name":"YieldVaultMaximumSlippagePercentageSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"yieldVault","type":"address"}],"name":"YieldVaultSet","type":"event"},{"stateMutability":"payable","type":"fallback"},{"inputs":[],"name":"DEFAULT_ADMIN_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"DOMAIN_SEPARATOR","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"PAUSER_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"REBALANCER_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"YIELD_COLLECTOR_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"asset","outputs":[{"internalType":"address","name":"assetTokenAddress","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"backingDifference","outputs":[{"internalType":"bool","name":"positive","type":"bool"},{"internalType":"uint256","name":"difference","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32[32]","name":"smtProofLocalExitRoot","type":"bytes32[32]"},{"internalType":"bytes32[32]","name":"smtProofRollupExitRoot","type":"bytes32[32]"},{"internalType":"uint256","name":"globalIndex","type":"uint256"},{"internalType":"bytes32","name":"mainnetExitRoot","type":"bytes32"},{"internalType":"bytes32","name":"rollupExitRoot","type":"bytes32"},{"internalType":"address","name":"destinationAddress","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"address","name":"receiver","type":"address"},{"internalType":"bytes","name":"metadata","type":"bytes"}],"name":"claimAndRedeem","outputs":[{"internalType":"uint256","name":"assets","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"shares","type":"uint256"}],"name":"convertToAssets","outputs":[{"internalType":"uint256","name":"assets","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"assets","type":"uint256"}],"name":"convertToShares","outputs":[{"internalType":"uint256","name":"shares","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"assets","type":"uint256"},{"internalType":"address","name":"receiver","type":"address"}],"name":"deposit","outputs":[{"internalType":"uint256","name":"shares","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"assets","type":"uint256"},{"internalType":"address","name":"receiver","type":"address"},{"internalType":"uint32","name":"destinationNetworkId","type":"uint32"},{"internalType":"bool","name":"forceUpdateGlobalExitRoot","type":"bool"}],"name":"depositAndBridge","outputs":[{"internalType":"uint256","name":"shares","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"}],"name":"depositGasToken","outputs":[{"internalType":"uint256","name":"shares","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"destinationAddress","type":"address"},{"internalType":"uint32","name":"destinationNetworkId","type":"uint32"},{"internalType":"bool","name":"forceUpdateGlobalExitRoot","type":"bool"}],"name":"depositGasTokenAndBridge","outputs":[{"internalType":"uint256","name":"shares","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"assets","type":"uint256"},{"internalType":"address","name":"receiver","type":"address"},{"internalType":"bytes","name":"permitData","type":"bytes"}],"name":"depositWithPermit","outputs":[{"internalType":"uint256","name":"shares","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"assets","type":"uint256"},{"internalType":"address","name":"receiver","type":"address"},{"internalType":"uint32","name":"destinationNetworkId","type":"uint32"},{"internalType":"bool","name":"forceUpdateGlobalExitRoot","type":"bool"},{"internalType":"bytes","name":"permitData","type":"bytes"}],"name":"depositWithPermitAndBridge","outputs":[{"internalType":"uint256","name":"shares","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"eip712Domain","outputs":[{"internalType":"bytes1","name":"fields","type":"bytes1"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"version","type":"string"},{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"address","name":"verifyingContract","type":"address"},{"internalType":"bytes32","name":"salt","type":"bytes32"},{"internalType":"uint256[]","name":"extensions","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"initializer_","type":"address"},{"components":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"address","name":"underlyingToken","type":"address"},{"internalType":"uint256","name":"minimumReservePercentage","type":"uint256"},{"internalType":"address","name":"yieldVault","type":"address"},{"internalType":"address","name":"yieldRecipient","type":"address"},{"internalType":"address","name":"lxlyBridge","type":"address"},{"internalType":"uint256","name":"minimumYieldVaultDeposit","type":"uint256"},{"internalType":"address","name":"migrationManager","type":"address"},{"internalType":"uint256","name":"yieldVaultMaximumSlippagePercentage","type":"uint256"},{"internalType":"address","name":"vaultBridgeTokenPart2","type":"address"}],"internalType":"struct VaultBridgeToken.InitializationParameters","name":"initParams","type":"tuple"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"lxlyBridge","outputs":[{"internalType":"contract ILxLyBridge","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"lxlyId","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"maxDeposit","outputs":[{"internalType":"uint256","name":"maxAssets","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"maxMint","outputs":[{"internalType":"uint256","name":"maxShares","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"maxRedeem","outputs":[{"internalType":"uint256","name":"maxShares","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"maxWithdraw","outputs":[{"internalType":"uint256","name":"maxAssets","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"migrationFeesFund","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"migrationManager","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"minimumReservePercentage","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"minimumYieldVaultDeposit","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"shares","type":"uint256"},{"internalType":"address","name":"receiver","type":"address"}],"name":"mint","outputs":[{"internalType":"uint256","name":"assets","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"shares","type":"uint256"},{"internalType":"address","name":"receiver","type":"address"}],"name":"mintWithGasToken","outputs":[{"internalType":"uint256","name":"assets","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"nonces","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"assets","type":"uint256"}],"name":"performReversibleYieldVaultDeposit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"permit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"assets","type":"uint256"}],"name":"previewDeposit","outputs":[{"internalType":"uint256","name":"shares","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"shares","type":"uint256"}],"name":"previewMint","outputs":[{"internalType":"uint256","name":"assets","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"shares","type":"uint256"}],"name":"previewRedeem","outputs":[{"internalType":"uint256","name":"assets","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"assets","type":"uint256"}],"name":"previewWithdraw","outputs":[{"internalType":"uint256","name":"shares","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"shares","type":"uint256"},{"internalType":"address","name":"receiver","type":"address"},{"internalType":"address","name":"owner","type":"address"}],"name":"redeem","outputs":[{"internalType":"uint256","name":"assets","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"callerConfirmation","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"reservePercentage","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"reservedAssets","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"stakedAssets","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalAssets","outputs":[{"internalType":"uint256","name":"totalManagedAssets","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"underlyingToken","outputs":[{"internalType":"contract IERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"version","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"assets","type":"uint256"},{"internalType":"address","name":"receiver","type":"address"},{"internalType":"address","name":"owner","type":"address"}],"name":"withdraw","outputs":[{"internalType":"uint256","name":"shares","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"yield","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"yieldRecipient","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"yieldVault","outputs":[{"internalType":"contract IERC4626","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"yieldVaultMaximumSlippagePercentage","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"stateMutability":"payable","type":"receive"}]
*/


================================================
FILE: contracts/vb/converters/IUSDCNativeConverter.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../INativeConverter.sol";

/**
 * @title IUSDCNativeConverter
 * @notice Interface for the USDC Native Converter
 * @dev Converts between USDC and its bridged representation across networks
 * @custom:bokuto 0xF1b01AAB6B790bb15610Dc18c6908b32765B5a06
 * @custom:katana 0x97a3500083348A147F419b8a65717909762c389f
 * @custom:tags vaultbridge,converter,usdc,native
 */
interface IUSDCNativeConverter is INativeConverter {

}


================================================
FILE: contracts/vb/converters/IUSDSNativeConverter.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../INativeConverter.sol";

/**
 * @title IUSDSNativeConverter
 * @notice Interface for the USDS Native Converter
 * @dev Converts between USDS and its bridged representation across networks
 * @custom:bokuto 0xC4BaBEE541c2FA1EA55ce9aF9EB3B5C76B0CE5c7
 * @custom:katana 0x639f13D5f30B47c792b6851238c05D0b623C77DE
 * @custom:tags vaultbridge,converter,usds,native
 */
interface IUSDSNativeConverter is INativeConverter {

}


================================================
FILE: contracts/vb/converters/IUSDTNativeConverter.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../INativeConverter.sol";

/**
 * @title IUSDTNativeConverter
 * @notice Interface for the USDT Native Converter
 * @dev Converts between USDT and its bridged representation across networks
 * @custom:bokuto 0x1bd455C30ad8E2b8dF40df44A2eF923d67B33Feb
 * @custom:katana 0x053FA9b934b83E1E0ffc7e98a41aAdc3640bB462
 * @custom:tags vaultbridge,converter,usdt,native
 */
interface IUSDTNativeConverter is INativeConverter {

}


================================================
FILE: contracts/vb/converters/IWBTCNativeConverter.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../INativeConverter.sol";

/**
 * @title IWBTCNativeConverter
 * @notice Interface for the WBTC Native Converter
 * @dev Converts between WBTC and its bridged representation across networks
 * @custom:bokuto 0x7A8ed27F4C30512326878652d20fC85727401854
 * @custom:katana 0xb00aa68b87256E2F22058fB2Ba3246EEc54A44fc
 * @custom:tags vaultbridge,converter,wbtc,native
 */
interface IWBTCNativeConverter is INativeConverter {

}


================================================
FILE: contracts/vb/converters/IWETHNativeConverter.sol
================================================
// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity ^0.8.20;

/**
 * @title IWETHNativeConverter
 * @notice Interface for the WETH Native Converter
 * @dev Converts between WETH and its bridged representation across networks, with additional gas backing functionality
 * @custom:bokuto 0x409834270b6F2591DD6c1e9f351E4194B112dA44
 * @custom:katana 0xa6B0DB1293144Ebe9478B6a84F75dd651E45914a
 * @custom:tags vaultbridge,converter,weth,native
 */

interface IWETHNativeConverter {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error AssetsTooLarge(uint256 availableAssets, uint256 requestedAssets);
    error EnforcedPause();
    error ExpectedPause();
    error FunctionNotSupportedOnThisNetwork();
    error InvalidAmountInERC20Permit(uint256 amount, uint256 minimumAmount);
    error InvalidAssets();
    error InvalidCustomToken();
    error InvalidDestinationNetworkId();
    error InvalidInitialization();
    error InvalidLayerXLxlyId();
    error InvalidLxLyBridge();
    error InvalidMigrationManager();
    error InvalidNonMigratableBackingPercentage();
    error InvalidNonMigratableGasBackingPercentage();
    error InvalidOwner();
    error InvalidOwnerInERC20Permit(address owner, address expectedOwner);
    error InvalidPermitData();
    error InvalidReceiver();
    error InvalidSelectorInERC20Permit(bytes4 selector);
    error InvalidShares();
    error InvalidSpenderInERC20Permit(address spender, address expectedSpender);
    error InvalidUnderlyingToken();
    error NonMatchingCustomTokenDecimals(
        uint8 customTokenDecimals,
        uint8 originalUnderlyingTokenDecimals
    );
    error NonMatchingUnderlyingTokenDecimals(
        uint8 underlyingTokenDecimals,
        uint8 originalUnderlyingTokenDecimals
    );
    error NotInitializing();
    error OnlyMigrator();
    error ReentrancyGuardReentrantCall();
    error SafeERC20FailedOperation(address token);
    event Initialized(uint64 version);
    event MigrationStarted(
        uint256 indexed mintedCustomToken,
        uint256 indexed migratedBacking
    );
    event NonMigratableBackingPercentageSet(
        uint256 nonMigratableBackingPercentage
    );
    event NonMigratableGasBackingPercentageSet(
        uint256 nonMigratableGasBackingPercentage_
    );
    event Paused(address account);
    event RoleAdminChanged(
        bytes32 indexed role,
        bytes32 indexed previousAdminRole,
        bytes32 indexed newAdminRole
    );
    event RoleGranted(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );
    event RoleRevoked(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );
    event Unpaused(address account);

    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);

    function MIGRATOR_ROLE() external view returns (bytes32);

    function PAUSER_ROLE() external view returns (bytes32);

    function backingOnLayerY() external view returns (uint256);

    function convert(uint256 assets, address receiver)
        external
        returns (uint256 shares);

    function convertWithPermit(
        uint256 assets,
        address receiver,
        bytes memory permitData
    ) external returns (uint256 shares);

    function customToken() external view returns (address);

    function deconvert(uint256 shares, address receiver)
        external
        returns (uint256 assets);

    function deconvertAndBridge(
        uint256 shares,
        address receiver,
        uint32 destinationNetworkId,
        bool forceUpdateGlobalExitRoot
    ) external returns (uint256 assets);

    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    function grantRole(bytes32 role, address account) external;

    function hasRole(bytes32 role, address account)
        external
        view
        returns (bool);

    function initialize(
        address owner_,
        uint8 originalUnderlyingTokenDecimals_,
        address customToken_,
        address underlyingToken_,
        address lxlyBridge_,
        uint32 layerXNetworkId_,
        uint256 nonMigratableBackingPercentage_,
        address migrationManager_,
        uint256 nonMigratableGasBackingPercentage_
    ) external;

    function layerXLxlyId() external view returns (uint32);

    function lxlyBridge() external view returns (address);

    function lxlyId() external view returns (uint32);

    function maxDeconvert(address owner)
        external
        view
        returns (uint256 maxShares);

    function migratableBacking() external view returns (uint256);

    function migratableGasBacking() external view returns (uint256);

    function migrateBackingToLayerX(uint256 assets) external;

    function migrateGasBackingToLayerX(uint256 amount) external;

    function migrationManager() external view returns (address);

    function nonMigratableBackingPercentage() external view returns (uint256);

    function nonMigratableGasBackingPercentage()
        external
        view
        returns (uint256);

    function pause() external;

    function paused() external view returns (bool);

    function renounceRole(bytes32 role, address callerConfirmation) external;

    function revokeRole(bytes32 role, address account) external;

    function setNonMigratableBackingPercentage(
        uint256 nonMigratableBackingPercentage_
    ) external;

    function setNonMigratableGasBackingPercentage(
        uint256 nonMigratableGasBackingPercentage_
    ) external;

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

    function underlyingToken() external view returns (address);

    function unpause() external;

    function version() external pure returns (string memory);

    receive() external payable;
}



================================================
FILE: contracts/vb/tokens/IbvbEth.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IBridgedVaultBridgeEth.sol";

/**
 * @title IbvbEth
 * @notice Interface for the Bridged Vault Bridge ETH token. This is deployed on
   the destination chain - for "Katana" this means Katana, for
   "Bokuto" this means Bokuto respectively. The address for each
   context is different, and indicated in custom tags.
 * @dev Bridged Vault Bridge token that allows bridging ETH across networks with yield exposure
 * @custom:katana 0xEE7D8BCFb72bC1880D0Cf19822eB0A2e6577aB62
 * @custom:bokuto 0x84b3493fA9B125A8EFf1CCc1328Bd84D0B4a2Dbf
 * @custom:tags vaultbridge,token,eth,bridge,destination
 */
interface IbvbEth is IBridgedVaultBridgeEth {

}



================================================
FILE: contracts/vb/tokens/IbvbUSDC.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IGenericCustomToken.sol";

/**
 * @title IbvbUSDC
 * @notice Interface for the Bridged Vault Bridge USDC token. This is deployed on the
 *   destination chain - for "Katana" this means Katana and "Bokuto"
 *   this means these respective testnet. The address for each context is different,
 *   and indicated in custom tags.
 * @dev Bridged representation of vault bridge USDC that can be minted/burned via bridge
 * @custom:katana 0x203A662b0BD271A6ed5a60EdFbd04bFce608FD36
 * @custom:bokuto 0xc2a4C310F2512A17Ac0047cf871aCAed3E62bB4B
 * @custom:tags vaultbridge,token,usdc,bridge,destination
 */
interface IbvbUSDC is IGenericCustomToken {

}


================================================
FILE: contracts/vb/tokens/IbvbUSDS.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IGenericCustomToken.sol";

/**
 * @title IbvbUSDS
 * @notice Interface for the Bridged Vault Bridge USDS token. This is deployed on the
 *   destination chain - for "Katana" this means Katana and "Bokuto"
 *   this means these respective testnets. The address for each context is different,
 *   and indicated in custom tags.
 * @dev Bridged representation of vault bridge USDS that can be minted/burned via bridge
 * @custom:katana 0x62D6A123E8D19d06d68cf0d2294F9A3A0362c6b3
 * @custom:bokuto 0x801f719178d9b85D4948ed146C50596273885a75
 * @custom:tags vaultbridge,token,usds,bridge,destination
 */
interface IbvbUSDS is IGenericCustomToken {

}


================================================
FILE: contracts/vb/tokens/IbvbUSDT.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IGenericCustomToken.sol";

/**
 * @title IbvbUSDT
 * @notice Interface for the Bridged Vault Bridge USDT token. This is deployed on the
 *   destination chain - for "Katana" this means Katana and "Bokuto"
 *   this means these respective testnets. The address for each context is different,
 *   and indicated in custom tags.
 * @dev Bridged representation of vault bridge USDT that can be minted/burned via bridge
 * @custom:katana 0x2DCa96907fde857dd3D816880A0df407eeB2D2F2
 * @custom:bokuto 0xf6801557e17131Da48Fd03B2c34172872F936345
 * @custom:tags vaultbridge,token,usdt,bridge,destination
 */
interface IbvbUSDT is IGenericCustomToken {

}


================================================
FILE: contracts/vb/tokens/IbvbWBTC.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IGenericCustomToken.sol";

/**
 * @title IbvbWBTC
 * @notice Interface for the Bridged Vault Bridge WBTC token. This is deployed on the
 *   destination chain - for "Katana" this means Katana and "Bokuto"
 *   this means these respective testnets. The address for each context is different,
 *   and indicated in custom tags.
 * @dev Bridged representation of vault bridge WBTC that can be minted/burned via bridge
 * @custom:katana 0x0913DA6Da4b42f538B445599b46Bb4622342Cf52
 * @custom:bokuto 0xe8255B44634b478aB10a649c6C207A654473dbed
 * @custom:tags vaultbridge,token,wbtc,bridge,destination
 */
interface IbvbWBTC is IGenericCustomToken {

}


================================================
FILE: contracts/vb/tokens/IvbETH.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IVaultBridgeToken.sol";

/**
 * @title IvbETH
 * @notice Interface for the Vault Bridge ETH token. This is deployed on the
   origin chain - for "Katana" this means Ethereum and "Bokuto"
   this means Sepolia. The address for each context is different, and indicated
   in custom tags.
 * @dev Vault Bridge token that allows bridging ETH across networks with yield exposure
 * @custom:katana ethereum:0x2DC70fb75b88d2eB4715bc06E1595E6D97c34DFF
 * @custom:bokuto sepolia:0x188FFFc2562C67aCdB9a0CD0B819021DDfC82A6B
 * @custom:tags vaultbridge,token,eth,yield,origin
 */
interface IvbETH is IVaultBridgeToken {

}


================================================
FILE: contracts/vb/tokens/IvbUSDC.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IVaultBridgeToken.sol";

/**
 * @title IvbUSDC
 * @notice Interface for the Vault Bridge USDC token. This is deployed on the
   origin chain - for "Katana" this means Ethereum and "Bokuto"
   this means Sepolia. The address for each context is different, and indicated
   in custom tags.
 * @dev Vault Bridge token that allows bridging USDC across networks with yield exposure
 * @custom:katana ethereum:0x53E82ABbb12638F09d9e624578ccB666217a765e
 * @custom:bokuto sepolia:0xb62Ba0719527701309339a175dDe3CBF1770dd38
 * @custom:tags vaultbridge,token,usdc,yield,origin
 */
interface IvbUSDC is IVaultBridgeToken {

}


================================================
FILE: contracts/vb/tokens/IvbUSDS.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IVaultBridgeToken.sol";

/**
 * @title IvbUSDS
 * @notice Interface for the Vault Bridge USDS token. This is deployed on the
   origin chain - for "Katana" this means Ethereum and "Bokuto"
   this means Sepolia. The address for each context is different, and indicated
   in custom tags.
 * @dev Vault Bridge token that allows bridging USDS across networks with yield exposure
 * @custom:katana ethereum:0x3DD459dE96F9C28e3a343b831cbDC2B93c8C4855
 * @custom:bokuto sepolia:0x406F1A8D91956d8D340821Cf6744Aa74c666836C
 * @custom:tags vaultbridge,token,usds,yield,origin
 */
interface IvbUSDS is IVaultBridgeToken {

}


================================================
FILE: contracts/vb/tokens/IvbUSDT.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IVaultBridgeToken.sol";

/**
 * @title IvbUSDT
 * @notice Interface for the Vault Bridge USDT token. This is deployed on the
   origin chain - for "Katana" this means Ethereum and "Bokuto"
   this means Sepolia. The address for each context is different, and indicated
   in custom tags.
 * @dev Vault Bridge token that allows bridging USDT across networks with yield exposure
 * @custom:katana ethereum:0x6d4f9f9f8f0155509ecd6Ac6c544fF27999845CC
 * @custom:bokuto sepolia:0xdd9aCdD3D2AeC1C823C51f8389597C6be9779B28
 * @custom:tags vaultbridge,token,usdt,yield,origin
 */
interface IvbUSDT is IVaultBridgeToken {

}


================================================
FILE: contracts/vb/tokens/IvbWBTC.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IVaultBridgeToken.sol";

/**
 * @title IvbWBTC
 * @notice Interface for the Vault Bridge WBTC token. This is deployed on the
   origin chain - for "Katana" this means Ethereum and "Bokuto"
   this means Sepolia. The address for each context is different, and indicated
   in custom tags.
 * @dev Vault Bridge token that allows bridging WBTC across networks with yield exposure
 * @custom:katana ethereum:0x2C24B57e2CCd1f273045Af6A5f632504C432374F
 * @custom:bokuto sepolia:0x2CE29070ee5e65C4191d5Efca8E85be181F34B6d
 * @custom:tags vaultbridge,token,wbtc,yield,origin
 */
interface IvbWBTC is IVaultBridgeToken {

}


================================================
FILE: contracts/yearn/IYearnVault.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @title IYearnVault
 * @notice Interface for Yearn ERC4626-compatible vaults
 * @dev This interface includes all standard ERC4626 methods plus additional Yearn vault specific functions
 * @custom:tags yearn,defi,vault,erc4626,yield
 */
interface IYearnVault is IERC20 {
    /* ERC4626 Standard Functions */

    /**
     * @notice Returns the address of the underlying token used for the vault
     * @return The address of the underlying asset token
     */
    function asset() external view returns (address);

    /**
     * @notice Returns the total amount of the underlying asset managed by the vault
     * @return The total amount of the underlying asset
     */
    function totalAssets() external view returns (uint256);

    /**
     * @notice Converts a given amount of assets to the corresponding amount of shares
     * @param assets The amount of assets to convert
     * @return The amount of shares that would be minted
     */
    function convertToShares(uint256 assets) external view returns (uint256);

    /**
     * @notice Converts a given amount of shares to the corresponding amount of assets
     * @param shares The amount of shares to convert
     * @return The amount of assets that would be withdrawn
     */
    function convertToAssets(uint256 shares) external view returns (uint256);

    /**
     * @notice Returns the maximum amount of the underlying asset that can be deposited for a receiver
     * @param receiver The address that would receive the shares
     * @return The maximum amount of assets that can be deposited
     */
    function maxDeposit(address receiver) external view returns (uint256);

    /**
     * @notice Simulates the amount of shares that would be minted for a given amount of assets
     * @param assets The amount of assets to deposit
     * @return The amount of shares that would be minted
     */
    function previewDeposit(uint256 assets) external view returns (uint256);

    /**
     * @notice Deposits assets into the vault and mints shares to the receiver
     * @param assets The amount of assets to deposit
     * @param receiver The address to receive the minted shares
     * @return shares The amount of shares minted
     */
    function deposit(uint256 assets, address receiver) external returns (uint256 shares);

    /**
     * @notice Returns the maximum amount of shares that can be minted for a receiver
     * @param receiver The address that would receive the shares
     * @return The maximum amount of shares that can be minted
     */
    function maxMint(address receiver) external view returns (uint256);

    /**
     * @notice Simulates the amount of assets that would be required to mint a given amount of shares
     * @param shares The amount of shares to mint
     * @return The amount of assets that would be required
     */
    function previewMint(uint256 shares) external view returns (uint256);

    /**
     * @notice Mints shares to the receiver by depositing assets
     * @param shares The amount of shares to mint
     * @param receiver The address to receive the minted shares
     * @return assets The amount of assets deposited
     */
    function mint(uint256 shares, address receiver) external returns (uint256 assets);

    /**
     * @notice Returns the maximum amount of assets that can be withdrawn by a caller
     * @param owner The address that owns the shares
     * @return The maximum amount of assets that can be withdrawn
     */
    function maxWithdraw(address owner) external view returns (uint256);

    /**
     * @notice Simulates the amount of shares that would be burned to withdraw a given amount of assets
     * @param assets The amount of assets to withdraw
     * @return The amount of shares that would be burned
     */
    function previewWithdraw(uint256 assets) external view returns (uint256);

    /**
     * @notice Withdraws assets from the vault to the receiver, burning shares from the owner
     * @param assets The amount of assets to withdraw
     * @param receiver The address to receive the assets
     * @param owner The address that owns the shares
     * @return shares The amount of shares burned
     */
    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);

    /**
     * @notice Returns the maximum amount of shares that can be redeemed by a caller
     * @param owner The address that owns the shares
     * @return The maximum amount of shares that can be redeemed
     */
    function maxRedeem(address owner) external view returns (uint256);

    /**
     * @notice Simulates the amount of assets that would be received for redeeming a given amount of shares
     * @param shares The amount of shares to redeem
     * @return The amount of assets that would be received
     */
    function previewRedeem(uint256 shares) external view returns (uint256);

    /**
     * @notice Redeems shares from the owner and sends assets to the receiver
     * @param shares The amount of shares to redeem
     * @param receiver The address to receive the assets
     * @param owner The address that owns the shares
     * @return assets The amount of assets sent to the receiver
     */
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);

    /* Yearn Vault Specific Functions */

    /**
     * @notice Returns the vault's current version
     * @return The vault's version string
     */
    function apiVersion() external view returns (string memory);

    /**
     * @notice Returns the address of the protocol's governance
     * @return The governance address
     */
    function governance() external view returns (address);

    /**
     * @notice Returns the address of the protocol's management
     * @return The management address
     */
    function management() external view returns (address);

    /**
     * @notice Returns the vault's current performance fee, if any
     * @return The performance fee, scaled by 1e4 (10000 = 100%)
     */
    function performanceFee() external view returns (uint256);

    /**
     * @notice Returns the vault's current management fee, if any
     * @return The management fee, scaled by 1e4 (10000 = 100%)
     */
    function managementFee() external view returns (uint256);

    /**
     * @notice Returns the price of a single vault share in terms of the underlying asset
     * @return The price per share
     */
    function pricePerShare() external view returns (uint256);

    /**
     * @notice Returns the address of the vault's current strategy, if any
     * @return The strategy address
     */
    function strategy() external view returns (address);

    /**
     * @notice Returns the total amount of assets the vault's strategy is managing
     * @return The total strategy assets
     */
    function totalDebt() external view returns (uint256);
} 


================================================
FILE: contracts/yearn/IYvAUSD.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IYearnVault.sol";

/**
 * @title IYvAUSD
 * @notice Interface for the Yearn AUSD ERC4626 vault
 * @dev This vault accepts AUSD and issues yvAUSD tokens
 * @custom:bokuto 0xAe4b2FCf45566893Ee5009BA36792D5078e4AD60
 * @custom:tags yearn,defi,vault,ausd,yield
 */
interface IYvAUSD is IYearnVault {
    /**
     * @notice Returns whether the vault is currently accepting deposits
     * @return True if deposits are enabled, false otherwise
     */
    function depositLimit() external view returns (uint256);

    /**
     * @notice Returns the amount of time (in seconds) between deposits and withdrawals
     * @return The lockup period in seconds
     */
    function depositLimitModule() external view returns (address);

    /**
     * @notice Returns the maximum capacity of the vault in terms of the underlying asset
     * @return The maximum capacity
     */
    function emergencyShutdown() external view returns (bool);

    /**
     * @notice Returns the percentage of assets that should be kept as float (not deployed to strategies)
     * @return The target float percentage, scaled by 1e4 (10000 = 100%)
     */
    function targetFloatPercent() external view returns (uint256);

    /**
     * @notice Withdraws everything from the strategy and puts the vault in emergency shutdown mode
     */
    function setEmergencyShutdown(bool active) external;

    /**
     * @notice Sets a new deposit limit for the vault
     * @param limit The new deposit limit
     */
    function setDepositLimit(uint256 limit) external;

    /**
     * @notice Sets the management fee for the vault
     * @param fee The new management fee
     */
    function setManagementFee(uint256 fee) external;

    /**
     * @notice Sets the performance fee for the vault
     * @param fee The new performance fee
     */
    function setPerformanceFee(uint256 fee) external;

    /**
     * @notice Sets the target percentage of assets to keep as float
     * @param targetPercent The new target percentage
     */
    function setTargetFloatPercent(uint256 targetPercent) external;

    /**
     * @notice Returns the address that will receive management fees
     * @return The rewards address
     */
    function rewards() external view returns (address);

    /**
     * @notice Sets the address that will receive management fees
     * @param rewards The new rewards address
     */
    function setRewards(address rewards) external;
} 


================================================
FILE: contracts/yearn/IYvWETH.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IYearnVault.sol";

/**
 * @title IYvWETH
 * @notice Interface for the Yearn WETH ERC4626 vault
 * @dev This vault accepts WETH and issues yvWETH tokens
 * @custom:bokuto 0xccc0fc2e34428120f985b460b487eb79e3c6fa57
 * @custom:tags yearn,defi,vault,weth,yield
 */
interface IYvWETH is IYearnVault {
    /**
     * @notice Returns the deposit limit for the vault in terms of the underlying asset
     * @return The maximum amount of WETH that can be deposited
     */
    function depositLimit() external view returns (uint256);

    /**
     * @notice Returns the module responsible for enforcing deposit limits
     * @return The address of the deposit limit module
     */
    function depositLimitModule() external view returns (address);

    /**
     * @notice Returns whether the vault is in emergency shutdown mode
     * @return True if the vault is shut down, false otherwise
     */
    function emergencyShutdown() external view returns (bool);

    /**
     * @notice Returns the target percentage of assets to keep as float (not deployed to strategies)
     * @return The target float percentage, scaled by 1e4 (10000 = 100%)
     */
    function targetFloatPercent() external view returns (uint256);

    /**
     * @notice Enables or disables emergency shutdown mode
     * @param active True to enable shutdown, false to disable
     */
    function setEmergencyShutdown(bool active) external;

    /**
     * @notice Sets a new deposit limit for the vault
     * @param limit The new deposit limit
     */
    function setDepositLimit(uint256 limit) external;

    /**
     * @notice Sets the management fee for the vault
     * @param fee The new management fee
     */
    function setManagementFee(uint256 fee) external;

    /**
     * @notice Sets the performance fee for the vault
     * @param fee The new performance fee
     */
    function setPerformanceFee(uint256 fee) external;

    /**
     * @notice Sets the target percentage of assets to keep as float
     * @param targetPercent The new target percentage
     */
    function setTargetFloatPercent(uint256 targetPercent) external;

    /**
     * @notice Returns the address that will receive management fees
     * @return The rewards address
     */
    function rewards() external view returns (address);

    /**
     * @notice Sets the address that will receive management fees
     * @param rewards The new rewards address
     */
    function setRewards(address rewards) external;

    /**
     * @notice Returns the list of strategies currently used by the vault
     * @return Array of strategy addresses
     */
    function withdrawalQueue() external view returns (address[] memory);
} 


================================================
FILE: dist-mcp/README.md
================================================
# Katana Foundry MCP Server

This is a Model Context Protocol (MCP) server for Foundry that provides tools
for interacting with Katana blockchain via the command line.

## Usage

To use this MCP server with Cursor, add the following to your Cursor config:

```json
"mcpServers": {
  "foundry": {
    "command": "bun",
    "args": [
      "/Users/dhananjaypai/Coding/Personal/specialk/dist-mcp/index.js"
    ],
    "env": {
      "PRIVATE_KEY": "0xYourPrivateKeyHere",
      "RPC_URL": "http://localhost:8545"
    }
  }
}
```

The `PRIVATE_KEY` and `RPC_URL` environment variables are optional. If not provided,
the RPC URL will default to http://localhost:8545.



================================================
FILE: examples/ausd-yearnvault/README.md
================================================
# YvAUSD Vault Frontend

A simple, clean interface for interacting with the Yearn AUSD vault on Katana Mainnet.

## Features

- ğŸ”— **Wallet Connection**: MetaMask integration via Wagmi
- ğŸ’° **Vault Operations**: Approve, Deposit, and Withdraw AUSD
- ğŸ“Š **Real-time Data**: View balances, allowances, and vault stats
- ğŸ¨ **Clean UI**: Light theme with subtle design
- ğŸ“± **Responsive**: Works on desktop and mobile

## Quick Setup

### 1. Prerequisites

- MetaMask browser extension
- Access to Katana Mainnet

### 2. Installation

```bash
cd examples/ausd-yearnvault

# Install required packages
bun install
```

### 4. MetaMask Katana Mainnet Setup

Add Katana Mainnet to MetaMask:

**Network Details:**
- **Network Name**: Katana Mainnet
- **RPC URL**: `https://rpc.katana.network/`
- **Chain ID**: `747474`
- **Currency Symbol**: `ETH`
- **Block Explorer**: `https://katanascan.com/`

### 5. File Structure

Replace the generated files with the provided code:

```
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ Navbar.tsx
â”‚   â””â”€â”€ VaultInterface.tsx
â”œâ”€â”€ contracts.ts
â”œâ”€â”€ Web3Provider.tsx
â”œâ”€â”€ App.tsx
â”œâ”€â”€ App.css
â””â”€â”€ index.tsx
```

### 6. Run the Application

```bash
bun start
```

The app will open at `http://localhost:3000`

## Usage Guide

### Step 1: Connect Wallet
- Click "Connect Wallet" in the navbar
- Select MetaMask
- Ensure you're on Katana Mainnet

### Step 2: Get Test Tokens
You'll need AUSD tokens to interact with the vault. If you don't have any, you'll need to:
- Get AUSD tokens from a faucet or
- Use the provided cast commands to mint/transfer if you have access

### Step 3: Approve Tokens
1. Enter the amount of AUSD you want to approve
2. Click "Approve"
3. Confirm the transaction in MetaMask

### Step 4: Deposit AUSD
1. Enter the amount of AUSD to deposit
2. Click "Deposit"
3. Confirm the transaction
4. You'll receive YvAUSD tokens representing your vault share

### Step 5: Monitor Your Position
- View your AUSD and YvAUSD balances
- See vault total assets
- Track your current allowance

### Step 6: Withdraw (Optional)
1. Enter the amount of YvAUSD to redeem
2. Click "Withdraw"
3. Confirm the transaction
4. You'll receive AUSD back

## Contract Addresses

- **AUSD Token**: `0x00000000eFE302BEAA2b3e6e1b18d08D69a9012a`
- **YvAUSD Vault**: `0x93Fec6639717b6215A48E5a72a162C50DCC40d68`

## Cast Commands (For Testing)

If you have a private key with AUSD tokens, you can use these commands:

```bash
# Approve AUSD
cast send 0x00000000eFE302BEAA2b3e6e1b18d08D69a9012a "approve(address,uint256)" 0x93Fec6639717b6215A48E5a72a162C50DCC40d68 1000000 \
    --private-key $PRIVATE_KEY \
    --rpc-url https://rpc.katana.network/

# Deposit AUSD
cast send 0x93Fec6639717b6215A48E5a72a162C50DCC40d68 "deposit(uint256,address)" 1000000 YOUR_ADDRESS \
    --private-key $PRIVATE_KEY \
    --rpc-url https://rpc.katana.network/
```

## Technical Notes

- **Token Decimals**: AUSD uses 6 decimals
- **ERC4626**: The vault follows ERC4626 standard
- **Auto-refresh**: Data updates automatically when transactions complete
- **Error Handling**: Transactions will show loading states and handle errors gracefully

## Troubleshooting

### Common Issues

1. **"Cannot connect to wallet"**
   - Ensure MetaMask is installed and unlocked
   - Check you're on the correct network (Katana mainnet)

2. **"Transaction failed"**
   - Check you have enough ETH for gas fees
   - Verify you have approved sufficient AUSD amount
   - Ensure you have enough AUSD balance

3. **"Network error"**
   - Verify Katana mainnet RPC is working
   - Try refreshing the page

### Getting Test ETH

You'll need ETH for gas fees on Katana mainnet. Contact the Katana team or check their documentation for faucet information.

## Development

The project uses:
- **React 18** with TypeScript
- **Wagmi v2** for Ethereum interactions
- **Viem** for low-level blockchain operations
- **Wagmi** for wallet connection UI
- **TanStack Query** for data fetching and caching

The code is structured to be simple and maintainable:
- All contract ABIs and addresses in one file
- Minimal component structure
- Clean separation of concerns
- Type safety throughout

## Support

If you encounter issues:
1. Check the browser console for error messages
2. Verify all environment variables are set correctly
3. Ensure you're using the correct contract addresses
4. Check MetaMask is connected to Katana Mainnet


================================================
FILE: examples/ausd-yearnvault/package.json
================================================
{
  "name": "yvausd-vault-frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@tanstack/react-query": "^5.28.6",
    "@types/node": "^16.18.11",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18.3.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-scripts": "5.0.1",
    "typescript": "^5.0.4",
    "wagmi": "^2.16.9"
  },
  "scripts": {
    "start": "bun run react-scripts start",
    "build": "bun run react-scripts build",
    "test": "bun run react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}



================================================
FILE: examples/ausd-yearnvault/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": [
    "src"
  ]
}



================================================
FILE: examples/ausd-yearnvault/public/index.html
================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="YvAUSD Vault - Yearn Finance AUSD Vault Interface"
    />
    <title>YvAUSD Vault</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>


================================================
FILE: examples/ausd-yearnvault/src/App.css
================================================
/* Reset and Base Styles */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

:root {
  /* Color System */
  --color-primary: #2563eb;
  --color-primary-hover: #1d4ed8;
  --color-primary-light: #3b82f6;
  --color-success: #10b981;
  --color-success-hover: #059669;
  --color-warning: #f59e0b;
  --color-danger: #ef4444;
  
  /* Neutral Colors */
  --color-gray-50: #f8fafc;
  --color-gray-100: #f1f5f9;
  --color-gray-200: #e2e8f0;
  --color-gray-300: #cbd5e1;
  --color-gray-400: #94a3b8;
  --color-gray-500: #64748b;
  --color-gray-600: #475569;
  --color-gray-700: #334155;
  --color-gray-800: #1e293b;
  --color-gray-900: #0f172a;
  
  /* Typography */
  --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
  --font-weight-normal: 400;
  --font-weight-medium: 500;
  --font-weight-semibold: 600;
  --font-weight-bold: 700;
  
  /* Spacing */
  --space-xs: 0.25rem;
  --space-sm: 0.5rem;
  --space-md: 1rem;
  --space-lg: 1.5rem;
  --space-xl: 2rem;
  --space-2xl: 3rem;
  
  /* Border Radius */
  --radius-sm: 0.375rem;
  --radius-md: 0.5rem;
  --radius-lg: 0.75rem;
  --radius-xl: 1rem;
  --radius-2xl: 1.25rem;
  
  /* Shadows */
  --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
  --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
  
  /* Transitions */
  --transition-fast: 150ms ease;
  --transition-normal: 250ms ease;
  --transition-slow: 350ms ease;
}

html {
  font-size: 16px;
  line-height: 1.5;
}

body {
  font-family: var(--font-family);
  font-weight: var(--font-weight-normal);
  color: var(--color-gray-800);
  background: linear-gradient(135deg, var(--color-gray-50) 0%, var(--color-gray-100) 100%);
  min-height: 100vh;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Layout */
.app {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* Navbar */
.navbar {
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(12px);
  border-bottom: 1px solid var(--color-gray-200);
  position: sticky;
  top: 0;
  z-index: 50;
}

.navbar-content {
  max-width: 1200px;
  margin: 0 auto;
  padding: var(--space-lg) var(--space-xl);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.navbar-brand {
  display: flex;
  align-items: center;
  gap: var(--space-md);
}

.navbar-brand h1 {
  font-size: 1.5rem;
  font-weight: var(--font-weight-bold);
  color: var(--color-gray-900);
  letter-spacing: -0.025em;
}

.network-badge {
  background: var(--color-success);
  color: white;
  padding: var(--space-xs) var(--space-md);
  border-radius: 9999px;
  font-size: 0.75rem;
  font-weight: var(--font-weight-semibold);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  white-space: nowrap;
}

/* Main Content */
.main-content {
  flex: 1;
  max-width: 900px; /* Reduced from 1200px */
  margin: 0 auto;
  padding: var(--space-xl);
  width: 100%;
}

/* Vault Interface */
.vault-interface {
  display: flex;
  flex-direction: column;
  gap: var(--space-xl);
}

.center-card {
  max-width: 400px;
  margin: 0 auto;
  text-align: center;
}

/* Stats Grid */
.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: var(--space-lg);
}

.stat-card {
  background: white;
  padding: var(--space-xl);
  border-radius: var(--radius-2xl);
  border: 1px solid var(--color-gray-200);
  box-shadow: var(--shadow-sm);
  transition: all var(--transition-normal);
  position: relative;
  overflow: hidden;
}

.stat-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, var(--color-primary), var(--color-primary-light));
  opacity: 0;
  transition: opacity var(--transition-normal);
}

.stat-card:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}

.stat-card:hover::before {
  opacity: 1;
}

.stat-card h3 {
  font-size: 0.875rem;
  font-weight: var(--font-weight-semibold);
  color: var(--color-gray-500);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: var(--space-sm);
}

.stat-value {
  font-size: 1.875rem;
  font-weight: var(--font-weight-bold);
  color: var(--color-gray-900);
  line-height: 1.2;
}

/* Transaction Status */
.transaction-status {
  background: white;
  padding: var(--space-lg);
  border-radius: var(--radius-xl);
  border: 1px solid var(--color-gray-200);
  box-shadow: var(--shadow-sm);
}

.status-pending {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  color: var(--color-warning);
  font-weight: var(--font-weight-medium);
}

.status-pending::before {
  content: '';
  width: 12px;
  height: 12px;
  border: 2px solid var(--color-warning);
  border-top-color: transparent;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.status-success {
  display: flex;
  align-items: center;
  justify-content: space-between;
  color: var(--color-success);
  font-weight: var(--font-weight-medium);
}

.explorer-link {
  display: inline-flex;
  align-items: center;
  gap: var(--space-xs);
  color: var(--color-primary);
  text-decoration: none;
  font-weight: var(--font-weight-medium);
  padding: var(--space-sm) var(--space-md);
  border-radius: var(--radius-md);
  transition: all var(--transition-fast);
  border: 1px solid var(--color-primary);
  background: transparent;
}

.explorer-link:hover {
  background: var(--color-primary);
  color: white;
  transform: translateY(-1px);
}

/* Actions Container */
.actions-container {
  display: grid;
  grid-template-columns: 1.5fr 1fr; /* Adjusted ratio */
  gap: var(--space-xl);
  align-items: start;
  max-width: 800px; /* Added max width constraint */
  margin: 0 auto; /* Center the container */
}

/* Cards */
.card, .combined-card {
  background: white;
  padding: var(--space-2xl);
  border-radius: var(--radius-2xl);
  border: 1px solid var(--color-gray-200);
  box-shadow: var(--shadow-md);
  transition: all var(--transition-normal);
}

.card:hover, .combined-card:hover {
  box-shadow: var(--shadow-lg);
}

.card h3, .combined-card h3 {
  font-size: 1.25rem;
  font-weight: var(--font-weight-bold);
  color: var(--color-gray-900);
  margin-bottom: var(--space-sm);
  line-height: 1.3;
}

.card p, .combined-card p {
  color: var(--color-gray-600);
  line-height: 1.6;
  margin-bottom: var(--space-xl);
}

/* Input Groups */
.input-group {
  display: flex;
  flex-direction: column;
  gap: var(--space-lg);
}

.amount-input {
  width: 100%;
  padding: var(--space-lg);
  font-size: 1rem;
  border: 2px solid var(--color-gray-200);
  border-radius: var(--radius-xl);
  background: var(--color-gray-50);
  color: var(--color-gray-900);
  transition: all var(--transition-normal);
  font-weight: var(--font-weight-medium);
}

.amount-input::placeholder {
  color: var(--color-gray-400);
}

.amount-input:focus {
  outline: none;
  border-color: var(--color-primary);
  background: white;
  box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
}

.amount-input:hover:not(:focus) {
  border-color: var(--color-gray-300);
  background: white;
}

/* Info Card */
.info-card {
  background: white;
  padding: var(--space-xl);
  border-radius: var(--radius-2xl);
  border: 1px solid var(--color-gray-200);
  box-shadow: var(--shadow-md);
  margin-bottom: var(--space-xl);
}

.info-card h3 {
  font-size: 1.25rem;
  font-weight: var(--font-weight-bold);
  color: var(--color-gray-900);
  margin-bottom: var(--space-lg);
  text-align: center;
}

.process-steps {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: var(--space-lg);
}

.process-step {
  display: flex;
  align-items: flex-start;
  gap: var(--space-md);
  text-align: left;
}

.process-number {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: var(--color-primary);
  color: white;
  font-weight: var(--font-weight-bold);
  font-size: 0.875rem;
  flex-shrink: 0;
}

.process-step strong {
  display: block;
  font-weight: var(--font-weight-semibold);
  color: var(--color-gray-900);
  margin-bottom: var(--space-xs);
}

.process-step p {
  color: var(--color-gray-600);
  font-size: 0.875rem;
  line-height: 1.5;
  margin: 0;
}

/* Single Step */
.single-step {
  margin-top: var(--space-xl);
}

.single-step .action-button {
  width: 100%;
}

/* Buttons */
.action-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: var(--space-lg) var(--space-xl);
  font-size: 1rem;
  font-weight: var(--font-weight-semibold);
  border: none;
  border-radius: var(--radius-xl);
  cursor: pointer;
  transition: all var(--transition-normal);
  min-height: 52px;
  position: relative;
  flex: 1;
  white-space: nowrap;
}

.action-button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none !important;
}

.action-button.primary {
  background: var(--color-primary);
  color: white;
  box-shadow: var(--shadow-sm);
}

.action-button.primary:hover:not(:disabled) {
  background: var(--color-primary-hover);
  transform: translateY(-1px);
  box-shadow: var(--shadow-md);
}

.action-button.secondary {
  background: var(--color-gray-200);
  color: var(--color-gray-600);
}

.action-button.secondary:hover:not(:disabled) {
  background: var(--color-gray-300);
  transform: translateY(-1px);
}

.action-button.completed {
  background: var(--color-success);
  color: white;
  box-shadow: var(--shadow-sm);
}

.action-button.completed:hover:not(:disabled) {
  background: var(--color-success-hover);
  transform: translateY(-1px);
  box-shadow: var(--shadow-md);
}

/* Preview */
.preview {
  background: linear-gradient(135deg, var(--color-primary-light), var(--color-primary));
  color: white;
  padding: var(--space-lg);
  border-radius: var(--radius-lg);
  font-weight: var(--font-weight-medium);
  margin-top: var(--space-md);
  box-shadow: var(--shadow-sm);
}

/* Loading Animation */
.action-button:disabled::after {
  content: '';
  position: absolute;
  right: var(--space-lg);
  width: 16px;
  height: 16px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

/* Responsive Design */
@media (max-width: 1024px) {
  .actions-container {
    grid-template-columns: 1fr;
    gap: var(--space-lg);
  }
  
  .navbar-content {
    padding: var(--space-md) var(--space-lg);
  }
  
  .main-content {
    padding: var(--space-lg);
  }
}

@media (max-width: 768px) {
  .stats-grid {
    grid-template-columns: 1fr;
    gap: var(--space-md);
  }
  
  .step-buttons {
    flex-direction: column;
    gap: var(--space-md);
  }
  
  .step {
    justify-content: flex-start;
  }
  
  .card, .combined-card {
    padding: var(--space-xl);
  }
  
  .navbar-brand h1 {
    font-size: 1.25rem;
  }
  
  .main-content {
    padding: var(--space-md);
  }
}

@media (max-width: 480px) {
  .navbar-content {
    padding: var(--space-md);
  }
  
  .main-content {
    padding: var(--space-sm);
  }
  
  .card, .combined-card {
    padding: var(--space-lg);
  }
  
  .stat-card {
    padding: var(--space-lg);
  }
  
  .amount-input {
    padding: var(--space-md);
  }
  
  .action-button {
    padding: var(--space-md) var(--space-lg);
    min-height: 48px;
  }
}

/* Accessibility */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

/* Focus styles for accessibility */
.action-button:focus-visible,
.amount-input:focus-visible,
.explorer-link:focus-visible {
  outline: 2px solid var(--color-primary);
  outline-offset: 2px;
}

/* Print styles */
@media print {
  .navbar {
    display: none;
  }
  
  .main-content {
    padding: 0;
    max-width: none;
  }
  
  .card, .combined-card {
    box-shadow: none;
    border: 1px solid var(--color-gray-300);
  }
}


================================================
FILE: examples/ausd-yearnvault/src/App.tsx
================================================
import React from 'react';
import { Web3Provider } from './Web3Provider';
import { Navbar } from './components/Navbar';
import { VaultInterface } from './components/VaultInterface';
import './App.css';

function App() {
  return (
    <Web3Provider>
      <div className="app">
        <Navbar />
        <main className="main-content">
          <VaultInterface />
        </main>
      </div>
    </Web3Provider>
  );
}

export default App;


================================================
FILE: examples/ausd-yearnvault/src/contracts.ts
================================================
import ERC20_ABI from '../../../abis/IERC20.json';
import YEARN_VAULT_ABI from '../../../abis/yearn/IYvAUSD.json';

export const AUSD_TOKEN_ADDRESS = '0x00000000eFE302BEAA2b3e6e1b18d08D69a9012a' as const;
export const YVAUSD_VAULT_ADDRESS = '0x93Fec6639717b6215A48E5a72a162C50DCC40d68' as const;

export { ERC20_ABI, YEARN_VAULT_ABI };


================================================
FILE: examples/ausd-yearnvault/src/index.css
================================================
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}



================================================
FILE: examples/ausd-yearnvault/src/index.tsx
================================================
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import { Web3Provider } from './Web3Provider';


const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

root.render(
  <React.StrictMode>
    <Web3Provider>
      <App />
    </Web3Provider>
  </React.StrictMode>
);


================================================
FILE: examples/ausd-yearnvault/src/Web3Provider.tsx
================================================
import { WagmiProvider, createConfig, http } from "wagmi";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { injected } from "wagmi/connectors";
import { defineChain } from "viem";

const katana = defineChain({
  id: 747474,
  name: 'Katana Testnet',
  nativeCurrency: {
    decimals: 18,
    name: 'ETH',
    symbol: 'ETH',
  },
  rpcUrls: {
    default: { http: ['https://rpc.katana.network'] },
  },
  blockExplorers: {
    default: { name: 'Katana Explorer', url: 'https://katanascan.com' },
  },
});

const config = createConfig({
  chains: [katana],
  transports: {
    [katana.id]: http(),
  },
  connectors: [
    injected()
  ],
});

const queryClient = new QueryClient();

export const Web3Provider = ({ children }: { children: React.ReactNode }) => {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </WagmiProvider>
  );
};


================================================
FILE: examples/ausd-yearnvault/src/components/Navbar.tsx
================================================
import React from 'react';
import { useAccount, useConnect, useDisconnect } from 'wagmi';

export const Navbar: React.FC = () => {
  const { address, isConnected } = useAccount();
  const { connect, connectors, status, error } = useConnect();
  const { disconnect } = useDisconnect();
  console.log('connectors', connectors);

  return (
    <nav className="navbar">
      <div className="navbar-content">
        <div className="navbar-brand">
          <h1>YvAUSD Vault</h1>
          <span className="network-badge">Katana Network</span>
          <span className="badge">Yearn Finance AUSD Vaults on Katana Mainnet</span>
        </div>
        <div className="navbar-actions" style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
          {isConnected ? (
            <>
              <span className="wallet-address" style={{marginRight: '1rem', fontWeight: 500, color: '#444', background: '#f3f3f3', borderRadius: '6px', padding: '0.25rem 0.75rem'}}>
                {address?.slice(0, 6)}...{address?.slice(-4)}
              </span>
              <button
                onClick={() => {
                  disconnect();
                  localStorage.removeItem('wagmi.connected');
                  localStorage.removeItem('wagmi.wallet');
                  localStorage.removeItem('wagmi.store');
                  window.location.reload();
                }}
                className="action-button"
                style={{background: '#eee', color: '#333', border: '1px solid #ccc', borderRadius: '6px', padding: '0.4rem 1.2rem', fontWeight: 500}}
              >
                Disconnect
              </button>
            </>
          ) : (
            <>
              <button
                disabled={connectors.length === 0}
                onClick={() => connect({ connector: connectors[0] })}
                className="action-button primary"
                style={{background: '#f7f7f7', color: '#222', border: '1px solid #ccc', borderRadius: '6px', padding: '0.4rem 1.2rem', fontWeight: 500}}
              >
                Connect Wallet
              </button>
              {!isConnected && error && (
                <span style={{ color: 'red', marginLeft: 8, fontSize: 13 }}>
                  {error.message || 'Connection failed'}
                </span>
              )}
            </>
          )}
        </div>
      </div>
    </nav>
  );
};


================================================
FILE: examples/ausd-yearnvault/src/components/VaultInterface.tsx
================================================
import React, { useState, useEffect } from 'react';
import { useAccount, useReadContract, useWriteContract, useWaitForTransactionReceipt } from 'wagmi';
import { parseUnits, formatUnits } from 'viem';
import { 
  AUSD_TOKEN_ADDRESS, 
  YVAUSD_VAULT_ADDRESS, 
  ERC20_ABI, 
  YEARN_VAULT_ABI 
} from '../contracts';

export const VaultInterface: React.FC = () => {
  const { address, isConnected } = useAccount();
  const [depositAmount, setDepositAmount] = useState('1');
  const [withdrawAmount, setWithdrawAmount] = useState('1');
  const [approveAmount, setApproveAmount] = useState('1');
  const [currentStep, setCurrentStep] = useState<'approve' | 'deposit'>('approve');

  const { writeContract, data: writeData, isPending: isWritePending } = useWriteContract();

  const { isLoading: isConfirming, isSuccess: isConfirmed } = useWaitForTransactionReceipt({
    hash: writeData,
  });

  // Read contract data
  const { data: ausdBalance } = useReadContract({
    address: AUSD_TOKEN_ADDRESS,
    abi: ERC20_ABI,
    functionName: 'balanceOf',
    args: address ? [address] : undefined,
  });

  const { data: yvausdBalance } = useReadContract({
    address: YVAUSD_VAULT_ADDRESS,
    abi: YEARN_VAULT_ABI,
    functionName: 'balanceOf',
    args: address ? [address] : undefined,
  });

  const { data: allowance } = useReadContract({
    address: AUSD_TOKEN_ADDRESS,
    abi: ERC20_ABI,
    functionName: 'allowance',
    args: address ? [address, YVAUSD_VAULT_ADDRESS] : undefined,
  });

  const { data: totalAssets } = useReadContract({
    address: YVAUSD_VAULT_ADDRESS,
    abi: YEARN_VAULT_ABI,
    functionName: 'totalAssets',
  });

  const { data: previewDeposit } = useReadContract({
    address: YVAUSD_VAULT_ADDRESS,
    abi: YEARN_VAULT_ABI,
    functionName: 'previewDeposit',
    args: depositAmount && !isNaN(Number(depositAmount)) && Number(depositAmount) > 0 
      ? [parseUnits(depositAmount, 6)] 
      : undefined,
  });

  const { data: previewWithdraw } = useReadContract({
    address: YVAUSD_VAULT_ADDRESS,
    abi: YEARN_VAULT_ABI,
    functionName: 'previewRedeem',
    args: withdrawAmount && !isNaN(Number(withdrawAmount)) && Number(withdrawAmount) > 0 
      ? [parseUnits(withdrawAmount, 6)] 
      : undefined,
  });

  const isValidAmount = (amount: string) => {
    return amount && !isNaN(Number(amount)) && Number(amount) > 0;
  };

  const hasAllowance =
    typeof allowance === 'bigint' && depositAmount && isValidAmount(depositAmount)
      ? Number(formatUnits(allowance, 6)) >= Number(depositAmount)
      : false;

  // Auto-switch to deposit step when approval is sufficient
  useEffect(() => {
    if (hasAllowance && currentStep === 'approve') {
      setCurrentStep('deposit');
    } else if (!hasAllowance && currentStep === 'deposit') {
      setCurrentStep('approve');
    }
  }, [hasAllowance, currentStep]);

  const handleApprove = async () => {
    if (!isValidAmount(approveAmount)) return;
    try {
      writeContract({
        address: AUSD_TOKEN_ADDRESS,
        abi: ERC20_ABI,
        functionName: 'approve',
        args: [YVAUSD_VAULT_ADDRESS, parseUnits(approveAmount, 6)],
      });
    } catch (error) {
      console.error('Approval failed:', error);
    }
  };

  const handleDeposit = async () => {
    if (!isValidAmount(depositAmount) || !address) return;
    try {
      writeContract({
        address: YVAUSD_VAULT_ADDRESS,
        abi: YEARN_VAULT_ABI,
        functionName: 'deposit',
        args: [parseUnits(depositAmount, 6), address],
      });
    } catch (error) {
      console.error('Deposit failed:', error);
    }
  };

  const handleWithdraw = async () => {
    if (!isValidAmount(withdrawAmount) || !address) return;
    try {
      writeContract({
        address: YVAUSD_VAULT_ADDRESS,
        abi: YEARN_VAULT_ABI,
        functionName: 'redeem',
        args: [parseUnits(withdrawAmount, 6), address, address],
      });
    } catch (error) {
      console.error('Withdrawal failed:', error);
    }
  };

  const getExplorerLink = (hash: string) => {
    return `https://katanascan.com/tx/${hash}`;
  };

  const getButtonText = () => {
    if (currentStep === 'approve') {
      if (isWritePending) return 'Approving...';
      if (hasAllowance) return 'Approved';
      return 'Approve';
    } else {
      if (isWritePending) return 'Depositing...';
      return 'Deposit';
    }
  };

  const isButtonDisabled = () => {
    if (currentStep === 'approve') {
      return !isValidAmount(approveAmount) || isWritePending || isConfirming;
    } else {
      return !isValidAmount(depositAmount) || isWritePending || isConfirming;
    }
  };

  const handleButtonClick = () => {
    if (currentStep === 'approve') {
      handleApprove();
    } else {
      handleDeposit();
    }
  };

  return (
    <div className="vault-interface">
      {!isConnected ? (
        <div className="center-card">
          <h2>YvAUSD Vault</h2>
          <p>Connect your wallet to interact with the vault</p>
        </div>
      ) : (
        <>
          {/* How It Works */}
          <div className="info-card">
            <h3>How Yield Farming Works</h3>
            <div className="process-steps">
              <div className="process-step">
                <span className="process-number">1</span>
                <div>
                  <strong>Approve</strong>
                  <p>Allow the vault to spend your AUSD tokens</p>
                </div>
              </div>
              <div className="process-step">
                <span className="process-number">2</span>
                <div>
                  <strong>Deposit</strong>
                  <p>Deposit AUSD and receive YvAUSD vault shares</p>
                </div>
              </div>
              <div className="process-step">
                <span className="process-number">3</span>
                <div>
                  <strong>Earn Yield</strong>
                  <p>Your YvAUSD grows in value as the vault generates returns</p>
                </div>
              </div>
              <div className="process-step">
                <span className="process-number">4</span>
                <div>
                  <strong>Redeem</strong>
                  <p>Withdraw your YvAUSD for AUSD plus earned yields</p>
                </div>
              </div>
            </div>
          </div>

          {/* Vault Stats */}
          <div className="stats-grid">
            <div className="stat-card">
              <h3>Your AUSD Balance</h3>
              <p className="stat-value">
                {typeof ausdBalance === 'bigint' ? formatUnits(ausdBalance, 6) : '0'} AUSD
              </p>
            </div>
            <div className="stat-card">
              <h3>Your YvAUSD Balance</h3>
              <p className="stat-value">
                {typeof yvausdBalance === 'bigint' ? formatUnits(yvausdBalance, 6) : '0'} YvAUSD
              </p>
            </div>
            <div className="stat-card">
              <h3>Vault Total Assets</h3>
              <p className="stat-value">
                {typeof totalAssets === 'bigint' ? formatUnits(totalAssets, 6) : '0'} AUSD
              </p>
            </div>
            <div className="stat-card">
              <h3>Current Allowance</h3>
              <p className="stat-value">
                {typeof allowance === 'bigint' ? formatUnits(allowance, 6) : '0'} AUSD
              </p>
            </div>
          </div>

          {/* Transaction Status */}
          {writeData && (
            <div className="transaction-status">
              {isConfirming && (
                <p className="status-pending">Transaction confirming...</p>
              )}
              {isConfirmed && (
                <div className="status-success">
                  <p>Transaction confirmed!</p>
                  <a 
                    href={getExplorerLink(writeData)} 
                    target="_blank" 
                    rel="noopener noreferrer"
                    className="explorer-link"
                  >
                    View on Explorer
                  </a>
                </div>
              )}
            </div>
          )}

          {/* Actions */}
          <div className="actions-container">
            
            {/* Approve & Deposit Combined */}
            <div className="combined-card">
              <h3>
                {currentStep === 'approve' ? 'Step 1: Approve AUSD' : 'Step 2: Deposit AUSD'}
              </h3>
              <p>
                {currentStep === 'approve' 
                  ? 'First, approve the vault to spend your AUSD tokens'
                  : 'Now deposit your AUSD to start earning yield'
                }
              </p>
              
              <div className="input-group">
                <input
                  type="number"
                  placeholder="Amount to deposit"
                  value={depositAmount}
                  onChange={(e) => {
                    setDepositAmount(e.target.value);
                    setApproveAmount(e.target.value);
                  }}
                  className="amount-input"
                  min="0"
                  step="0.000001"
                />
              </div>

              {depositAmount && typeof previewDeposit === 'bigint' && isValidAmount(depositAmount) && (
                <div className="preview">
                  You'll receive: {formatUnits(previewDeposit, 6)} YvAUSD
                </div>
              )}

              <div className="single-step">
                <button 
                  onClick={handleButtonClick}
                  disabled={isButtonDisabled()}
                  className={`action-button ${hasAllowance ? 'primary' : 'primary'}`}
                >
                  {getButtonText()}
                </button>
              </div>
            </div>

            {/* Withdraw */}
            <div className="card">
              <h3>Withdraw</h3>
              <p>Redeem your YvAUSD tokens back to AUSD plus yields</p>
              

              <div className="input-group">
                <input
                  type="number"
                  placeholder="YvAUSD amount to redeem"
                  value={withdrawAmount}
                  onChange={(e) => setWithdrawAmount(e.target.value)}
                  className="amount-input"
                  min="0"
                  step="0.000001"
                />
                <button 
                  onClick={handleWithdraw}
                  disabled={!isValidAmount(withdrawAmount) || isWritePending || isConfirming}
                  className="action-button primary"
                >
                  {isWritePending && isValidAmount(withdrawAmount) ? 'Withdrawing...' : 'Withdraw'}
                </button>
              </div>
              {/* Error if withdraw amount exceeds balance */}
              {isValidAmount(withdrawAmount) &&
                (typeof yvausdBalance === 'bigint') &&
                Number(withdrawAmount) > Number(formatUnits(yvausdBalance, 6)) && (
                  <div style={{ color: 'red', marginTop: 8, fontSize: 14 }}>
                    Error: You do not have enough YvAUSD to withdraw this amount.
                  </div>
              )}

              {withdrawAmount && typeof previewWithdraw === 'bigint' && isValidAmount(withdrawAmount) && (
                <div className="preview">
                  You'll receive: {formatUnits(previewWithdraw, 6)} AUSD
                </div>
              )}
            </div>
          </div>
        </>
      )}
    </div>
  );
};


================================================
FILE: examples/wrapping/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Katana Demo app</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="container">
    <header>
      <h1>Katana Demo app</h1>
      <div class="network-status">
        <span id="network-indicator"></span>
        <span id="network-name">Connecting...</span>
      </div>
    </header>

    <main>
      <section id="wallet-section">
        <h2>Wallet Connection</h2>
        <div class="card">
          <div id="wallet-status">Not connected</div>
          <button id="connect-wallet" class="primary-button">Connect Wallet</button>
        </div>
      </section>

      <section id="contracts-section">
        <h2>Chain Contracts</h2>
        
        <!-- AUSD Token -->
        <div class="card">
          <h3>AUSD Token</h3>
          <div class="contract-address" id="ausd-address">
            <span>Address:</span>
            <code>Loading...</code>
          </div>
          <div class="contract-data" id="ausd-data">
            <div class="spinner"></div>
            <p>Loading data...</p>
          </div>
        </div>

        <!-- bvbEth Token -->
        <div class="card">
          <h3>bvbEth Token (Bridged Vault Bridge ETH)</h3>
          <div class="contract-address" id="weth-address">
            <span>Address:</span>
            <code>Loading...</code>
          </div>
          <div class="contract-data" id="weth-data">
            <div class="spinner"></div>
            <p>Loading data...</p>
          </div>
        </div>

        <!-- MorphoBlue -->
        <div class="card">
          <h3>MorphoBlue Protocol</h3>
          <div class="contract-address" id="morpho-address">
            <span>Address:</span>
            <code>Loading...</code>
          </div>
          <div class="contract-data" id="morpho-data">
            <div class="spinner"></div>
            <p>Loading data...</p>
          </div>
        </div>
      </section>

      <section id="origin-contracts-section">
        <h2>Origin Chain Contracts</h2>
        <p class="section-description">Cross-chain contracts deployed on origin chains (Ethereum/Sepolia) accessible from the current chain context.</p>
        
        <!-- VB USDC Origin -->
        <div class="card">
          <h3>vbUSDC (Vault Bridge USDC)</h3>
          <div class="contract-address" id="vbusdc-origin-address">
            <span>Origin Address:</span>
            <code>Loading...</code>
          </div>
          <div class="contract-data" id="vbusdc-origin-data">
            <div class="spinner"></div>
            <p>Loading data...</p>
          </div>
        </div>

        <!-- VB ETH Origin -->
        <div class="card">
          <h3>vbETH (Vault Bridge ETH)</h3>
          <div class="contract-address" id="vbeth-origin-address">
            <span>Origin Address:</span>
            <code>Loading...</code>
          </div>
          <div class="contract-data" id="vbeth-origin-data">
            <div class="spinner"></div>
            <p>Loading data...</p>
          </div>
        </div>
      </section>

      <!-- ETH/bvbEth Operations Section -->
      <section id="eth-weth-section">
        <h2>ETH/bvbEth Wrapping Operations</h2>
        <div class="card">
          <h3>Token Balances</h3>
          <div class="balances-container">
            <div class="balance-item">
              <div class="label">ETH Balance</div>
              <div id="eth-balance" class="value">-</div>
            </div>
            <div class="balance-item">
              <div class="label">bvbEth Balance</div>
              <div id="weth-balance" class="value">-</div>
            </div>
          </div>
          
          <div class="operations-container">
            <div class="operation-card">
              <h4>Wrap ETH to bvbEth</h4>
              <p class="operation-description">Convert your ETH into yield-bearing bvbEth tokens</p>
              <div class="form-group">
                <label for="wrap-amount">Amount (ETH)</label>
                <input type="number" id="wrap-amount" min="0" step="0.01" placeholder="0.0">
              </div>
              <button id="wrap-button" class="primary-button" disabled>Wrap ETH</button>
            </div>
            
            <div class="operation-card">
              <h4>Unwrap bvbEth to ETH</h4>
              <p class="operation-description">Convert your bvbEth tokens back to ETH</p>
              <div class="form-group">
                <label for="unwrap-amount">Amount (bvbEth)</label>
                <input type="number" id="unwrap-amount" min="0" step="0.01" placeholder="0.0">
              </div>
              <button id="unwrap-button" class="primary-button" disabled>Unwrap bvbEth</button>
            </div>
          </div>
        </div>
      </section>
    </main>

    <footer>
      <p>
        Built with <a href="https://github.com/katana-network/specialk" target="_blank" rel="noopener noreferrer">Katana Development Starter Kit</a>
      </p>
    </footer>
  </div>

  <script type="module" src="main.js"></script>
</body>
</html>



================================================
FILE: examples/wrapping/main.ts
================================================
import { createPublicClient, createWalletClient, http, custom, formatEther, formatUnits, parseUnits, PublicClient, WalletClient } from 'viem';
import { addresses, CHAIN_IDS } from '@/utils/addresses/index.ts';

// Import ABIs from their respective locations
import AUSD_ABI from '@/abis/tokens/IAUSD.json';
import WETH_ABI from '@/abis/vb/tokens/IbvbEth.json';
import MORPHO_BLUE_ABI from '@/abis/morpho/IMorphoBlue.json';

// Chain information
const CHAIN_INFO = {
  [CHAIN_IDS.KATANA]: { name: 'Katana', symbol: 'ETH' },
  [CHAIN_IDS.BOKUTO]: { name: 'Bokuto', symbol: 'ETH' }
};

// Current chain context - will be set dynamically
let currentChainId: number | null = null;
let currentChainInfo: { name: string; symbol: string } | null = null;

// DOM Elements
const networkIndicator = document.getElementById('network-indicator') as HTMLElement;
const networkName = document.getElementById('network-name') as HTMLElement;
const walletStatus = document.getElementById('wallet-status') as HTMLElement;
const connectWalletButton = document.getElementById('connect-wallet') as HTMLButtonElement;
const ausdDataElement = document.getElementById('ausd-data') as HTMLElement;
const wethDataElement = document.getElementById('weth-data') as HTMLElement;
const morphoDataElement = document.getElementById('morpho-data') as HTMLElement;

// Address display elements
const ausdAddressElement = document.getElementById('ausd-address') as HTMLElement;
const wethAddressElement = document.getElementById('weth-address') as HTMLElement;
const morphoAddressElement = document.getElementById('morpho-address') as HTMLElement;

// Origin contract elements
const vbusdcOriginDataElement = document.getElementById('vbusdc-origin-data') as HTMLElement;
const vbethOriginDataElement = document.getElementById('vbeth-origin-data') as HTMLElement;
const vbusdcOriginAddressElement = document.getElementById('vbusdc-origin-address') as HTMLElement;
const vbethOriginAddressElement = document.getElementById('vbeth-origin-address') as HTMLElement;

// ETH/bvbEth wrapping elements
const ethBalanceElement = document.getElementById('eth-balance') as HTMLElement;
const wethBalanceElement = document.getElementById('weth-balance') as HTMLElement;
const wrapAmountInput = document.getElementById('wrap-amount') as HTMLInputElement;
const unwrapAmountInput = document.getElementById('unwrap-amount') as HTMLInputElement;
const wrapButton = document.getElementById('wrap-button') as HTMLButtonElement;
const unwrapButton = document.getElementById('unwrap-button') as HTMLButtonElement;

// Check for wallet
const hasEthereum = typeof window !== 'undefined' && window.ethereum;

// Create clients
let publicClient: PublicClient;
let walletClient: WalletClient;

// Create transport with retry logic
function createRobustTransport() {
  // Create transport with retries
  return http('http://localhost:8545', {
    timeout: 10000, // 10 seconds
    fetchOptions: {
      headers: {
        'Content-Type': 'application/json',
      },
      cache: 'no-cache',
    },
    // Basic retry with exponential backoff
    retryCount: 3,
    retryDelay: 1000,
  });
}

// Setup
async function initialize() {
  try {
    // Create a public client with custom config
    publicClient = createPublicClient({
      transport: createRobustTransport()
    });

    // Test connection with a simple method first
    try {
      // Ping the RPC with a simple request before attempting more complex calls
      await publicClient.getBlockNumber();
      
      // Then try to get chain ID and detect which chain we're connected to
      const chainId = await publicClient.getChainId();
      const chainInfo = CHAIN_INFO[chainId as keyof typeof CHAIN_INFO];
      
      if (!chainInfo) {
        const validChainIds = Object.keys(CHAIN_INFO).join(', ');
        updateNetworkStatus('error', `Unknown network: ${chainId}`);
        displayRpcError(`Connected to unknown network. Expected one of: ${validChainIds}`);
        return;
      }
      
      // Set the global chain context
      currentChainId = chainId;
      currentChainInfo = chainInfo;
      
      // Set the address context for this chain
      addresses.setChain(chainId);
      
      updateNetworkStatus('connected', chainInfo.name);
      console.log(`âœ… Connected to ${chainInfo.name} (Chain ID: ${chainId})`);
      
      // Test if we have contracts available on this chain
      const availableContracts = addresses.getAllContracts();
      console.log(`ğŸ“‹ Found ${availableContracts.length} contracts available on ${chainInfo.name}`);
      
      // Check if we have the key contracts we want to display
      const hasAUSD = addresses.hasContract('AUSD');
      const hasWETH = addresses.hasContract('bvbEth');
      const hasMorpho = addresses.hasContract('MorphoBlue');
      
      if (!hasAUSD && !hasWETH && !hasMorpho) {
        updateNetworkStatus('warning', `${chainInfo.name} (No contracts)`);
        displayRpcError(`No key contracts (AUSD, bvbEth, MorphoBlue) found on ${chainInfo.name}. The contracts may not be deployed on this chain yet.`);
        return;
      }
      
      // Test reading a contract to validate the connection
      if (hasAUSD) {
        try {
          const ausdAddress = addresses.getAddress('AUSD');
          const ausdSymbol = await publicClient.readContract({
            address: ausdAddress,
            abi: AUSD_ABI,
            functionName: 'symbol'
          });
          console.log(`Connected and able to read contracts. AUSD symbol: ${ausdSymbol}`);
        } catch (contractError) {
          console.error('Contract read test failed:', contractError);
          updateNetworkStatus('error', 'Contract read failed');
          displayRpcError('Contract read error. The fork might not have the contract state loaded correctly.');
          return;
        }
      }
      
      // Update address displays
      updateAddressDisplays();
      
      // Now load all contract data
      loadContractData();
        
    } catch (error) {
      console.error('RPC connection error:', error);
      updateNetworkStatus('error', 'Fork not running');
      displayRpcError('Unable to connect to local chain fork');
    }
  } catch (error) {
    console.error('Initialization error:', error);
    updateNetworkStatus('error', 'Connection error');
    displayRpcError();
  }

  // Handle wallet connection separately from RPC connection
  if (!hasEthereum) {
    walletStatus.textContent = 'No wallet detected';
  }
}

// Display RPC connection error
function displayRpcError(customMessage?: string) {
  const errorMessage = `
    <div class="error-message">
      <h4>âš ï¸ Connection Error</h4>
      ${customMessage ? `<p>${customMessage}</p>` : ''}
      <p>Make sure you've started a local chain fork with:</p>
      <pre>bun run start:anvil bokuto   # or bokuto/katana</pre>
      <p>Your local RPC should be running at http://localhost:8545</p>
    </div>
  `;

  // Display error in all contract data elements
  ausdDataElement.innerHTML = errorMessage;
  wethDataElement.innerHTML = errorMessage;
  morphoDataElement.innerHTML = errorMessage;
  vbusdcOriginDataElement.innerHTML = errorMessage;
  vbethOriginDataElement.innerHTML = errorMessage;
}

// Update network status indicator
function updateNetworkStatus(status: 'connected' | 'error' | 'warning', name: string) {
  networkIndicator.className = status;
  networkName.textContent = name;
}

// Update address displays
function updateAddressDisplays() {
  try {
    // Update regular contract addresses
    if (addresses.hasContract('AUSD')) {
      const ausdAddress = addresses.getAddress('AUSD');
      ausdAddressElement.querySelector('code')!.textContent = ausdAddress;
    } else {
      ausdAddressElement.querySelector('code')!.textContent = 'Not deployed on this chain';
    }

    if (addresses.hasContract('bvbEth')) {
      const wethAddress = addresses.getAddress('bvbEth');
      wethAddressElement.querySelector('code')!.textContent = wethAddress;
    } else {
      wethAddressElement.querySelector('code')!.textContent = 'Not deployed on this chain';
    }

    if (addresses.hasContract('MorphoBlue')) {
      const morphoAddress = addresses.getAddress('MorphoBlue');
      morphoAddressElement.querySelector('code')!.textContent = morphoAddress;
    } else {
      morphoAddressElement.querySelector('code')!.textContent = 'Not deployed on this chain';
    }

    // Update origin contract addresses
    if (addresses.hasOriginContract('vbUSDC')) {
      const vbusdcOriginAddress = addresses.getOriginAddress('vbUSDC');
      const originChain = currentChainId === CHAIN_IDS.KATANA ? 'Ethereum' : 'Sepolia';
      vbusdcOriginAddressElement.querySelector('code')!.textContent = vbusdcOriginAddress;
      vbusdcOriginAddressElement.querySelector('span')!.textContent = `${originChain} Address:`;
    } else {
      vbusdcOriginAddressElement.querySelector('code')!.textContent = 'Not available in this context';
    }

    if (addresses.hasOriginContract('vbETH')) {
      const vbethOriginAddress = addresses.getOriginAddress('vbETH');
      const originChain = currentChainId === CHAIN_IDS.KATANA ? 'Ethereum' : 'Sepolia';
      vbethOriginAddressElement.querySelector('code')!.textContent = vbethOriginAddress;
      vbethOriginAddressElement.querySelector('span')!.textContent = `${originChain} Address:`;
    } else {
      vbethOriginAddressElement.querySelector('code')!.textContent = 'Not available in this context';
    }
  } catch (error) {
    console.error('Error updating address displays:', error);
  }
}

// Connect wallet
async function connectWallet() {
  if (!hasEthereum) {
    alert('Please install MetaMask or another Ethereum wallet');
    return;
  }

  try {
    // Request account access
    walletClient = createWalletClient({
      transport: custom(window.ethereum)
    });
    
    const accounts = await walletClient.requestAddresses();
    
    if (accounts.length > 0) {
      walletStatus.textContent = `Connected: ${shortenAddress(accounts[0])}`;
      connectWalletButton.textContent = 'Connected';
      connectWalletButton.disabled = true;
      
      // Load balances after wallet connection
      loadBalances();
    }
  } catch (error) {
    console.error('Connection error:', error);
    walletStatus.textContent = 'Connection failed';
  }
}

// Shorten address for display
function shortenAddress(address: string): string {
  return `${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
}

// Generic function to safely load contract data with fallback
async function safeContractCall<T>(
  callback: () => Promise<T>,
  errorHandler: (error: any) => void
): Promise<T | null> {
  try {
    return await callback();
  } catch (error) {
    errorHandler(error);
    return null;
  }
}

// Load AUSD Token data
async function loadAUSDData() {
  // Check if AUSD is available on current chain
  if (!addresses.hasContract('AUSD')) {
    ausdDataElement.innerHTML = `<p>AUSD not available on ${currentChainInfo?.name || 'this chain'}</p>`;
    return;
  }

  // Get AUSD address dynamically
  const ausdAddress = addresses.getAddress('AUSD');

  // Clear previous content and show loading state
  ausdDataElement.innerHTML = '<div class="spinner"></div><p>Loading data...</p>';
  
  try {
    // Load data sequentially to avoid batching issues
    const name = await safeContractCall(
      () => publicClient.readContract({
        address: ausdAddress,
        abi: AUSD_ABI,
        functionName: 'name'
      }),
      (error) => console.error('Error reading AUSD name:', error)
    );
    
    const symbol = await safeContractCall(
      () => publicClient.readContract({
        address: ausdAddress,
        abi: AUSD_ABI,
        functionName: 'symbol'
      }),
      (error) => console.error('Error reading AUSD symbol:', error)
    );
    
    const decimals = await safeContractCall(
      () => publicClient.readContract({
        address: ausdAddress,
        abi: AUSD_ABI,
        functionName: 'decimals'
      }),
      (error) => console.error('Error reading AUSD decimals:', error)
    );
    
    const totalSupply = await safeContractCall(
      () => publicClient.readContract({
        address: ausdAddress,
        abi: AUSD_ABI,
        functionName: 'totalSupply'
      }),
      (error) => console.error('Error reading AUSD totalSupply:', error)
    );

    // If we couldn't get any data, show error
    if (!name && !symbol && !decimals && !totalSupply) {
      throw new Error('Failed to load any AUSD data');
    }

    // Format and display data
    ausdDataElement.innerHTML = '';
    ausdDataElement.classList.add('loaded');

    // Calculate total supply formatted string
    let formattedSupply = 'Error loading';
    if (totalSupply !== null && decimals !== null) {
      try {
        // totalSupply is expected to be a bigint, ensure it is one
        const supplyBigInt = typeof totalSupply === 'bigint' ? totalSupply : BigInt(0);
        const decimalNumber = typeof decimals === 'number' ? decimals : 18;
        formattedSupply = `${formatUnits(supplyBigInt, decimalNumber)} ${symbol || ''}`;
      } catch (e) {
        console.error('Error formatting AUSD supply:', e);
      }
    }

    // Use type guards to ensure proper formatting
    const formattedData = [
      { label: 'Name', value: name ? String(name) : 'Error loading' },
      { label: 'Symbol', value: symbol ? String(symbol) : 'Error loading' },
      { label: 'Decimals', value: decimals !== null ? String(decimals) : 'Error loading' },
      { label: 'Total Supply', value: formattedSupply },
      { label: 'Address', value: ausdAddress }
    ];

    formattedData.forEach(item => {
      const dataItem = document.createElement('div');
      dataItem.className = 'data-item';
      dataItem.innerHTML = `
        <div class="label">${item.label}</div>
        <div class="value">${item.value}</div>
      `;
      ausdDataElement.appendChild(dataItem);
    });
  } catch (error) {
    console.error('Error loading AUSD data:', error);
    ausdDataElement.innerHTML = `<p>Error loading data. Make sure the ${currentChainInfo?.name || 'chain'} fork is running.</p>`;
  }
}

// Load bvbEth Token data
async function loadWETHData() {
  // Check if bvbEth is available on current chain
  if (!addresses.hasContract('bvbEth')) {
    wethDataElement.innerHTML = `<p>bvbEth not available on ${currentChainInfo?.name || 'this chain'}</p>`;
    return;
  }

  // Get bvbEth address dynamically
  const wethAddress = addresses.getAddress('bvbEth');

  // Clear previous content and show loading state
  wethDataElement.innerHTML = '<div class="spinner"></div><p>Loading data...</p>';
  
  try {
    // Load data sequentially to avoid batching issues
    const name = await safeContractCall(
      () => publicClient.readContract({
        address: wethAddress,
        abi: WETH_ABI,
        functionName: 'name'
      }),
              (error) => console.error('Error reading bvbEth name:', error)
    );
    
    const symbol = await safeContractCall(
      () => publicClient.readContract({
        address: wethAddress,
        abi: WETH_ABI,
        functionName: 'symbol'
      }),
              (error) => console.error('Error reading bvbEth symbol:', error)
    );
    
    const totalSupply = await safeContractCall(
      () => publicClient.readContract({
        address: wethAddress,
        abi: WETH_ABI,
        functionName: 'totalSupply'
      }),
              (error) => console.error('Error reading bvbEth totalSupply:', error)
    );

    // If we couldn't get any data, show error
    if (!name && !symbol && !totalSupply) {
      throw new Error('Failed to load any bvbEth data');
    }

    // Format and display data
    wethDataElement.innerHTML = '';
    wethDataElement.classList.add('loaded');

    // Calculate total supply formatted string
    let formattedSupply = 'Error loading';
    if (totalSupply !== null) {
      try {
        // totalSupply is expected to be a bigint, ensure it is one
        const supplyBigInt = typeof totalSupply === 'bigint' ? totalSupply : BigInt(0);
        formattedSupply = `${formatEther(supplyBigInt)} ${symbol || ''}`;
      } catch (e) {
        console.error('Error formatting bvbEth supply:', e);
      }
    }

    // Use type guards to ensure proper formatting
    const formattedData = [
      { label: 'Name', value: name ? String(name) : 'Error loading' },
      { label: 'Symbol', value: symbol ? String(symbol) : 'Error loading' },
      { label: 'Total Supply', value: formattedSupply },
      { label: 'Address', value: wethAddress }
    ];

    formattedData.forEach(item => {
      const dataItem = document.createElement('div');
      dataItem.className = 'data-item';
      dataItem.innerHTML = `
        <div class="label">${item.label}</div>
        <div class="value">${item.value}</div>
      `;
      wethDataElement.appendChild(dataItem);
    });
  } catch (error) {
    console.error('Error loading bvbEth data:', error);
    wethDataElement.innerHTML = `<p>Error loading data. Make sure the ${currentChainInfo?.name || 'chain'} fork is running.</p>`;
  }
}

// Load MorphoBlue data
async function loadMorphoData() {
  // Check if MorphoBlue is available on current chain
  if (!addresses.hasContract('MorphoBlue')) {
    morphoDataElement.innerHTML = `<p>MorphoBlue not available on ${currentChainInfo?.name || 'this chain'}</p>`;
    return;
  }

  // Get MorphoBlue address dynamically
  const morphoAddress = addresses.getAddress('MorphoBlue');

  // Clear previous content and show loading state
  morphoDataElement.innerHTML = '<div class="spinner"></div><p>Loading data...</p>';
  
  try {
    // Load data sequentially to avoid batching issues
    const owner = await safeContractCall(
      () => publicClient.readContract({
        address: morphoAddress,
        abi: MORPHO_BLUE_ABI,
        functionName: 'owner'
      }),
      (error) => console.error('Error reading MorphoBlue owner:', error)
    );
    
    const feeRecipient = await safeContractCall(
      () => publicClient.readContract({
        address: morphoAddress,
        abi: MORPHO_BLUE_ABI,
        functionName: 'feeRecipient'
      }),
      (error) => console.error('Error reading MorphoBlue feeRecipient:', error)
    );

    // Check if 50% LLTV is enabled
    const lltv50Percent = 5000n; // 50% in basis points
    const isLltv50Enabled = await safeContractCall(
      () => publicClient.readContract({
        address: morphoAddress,
        abi: MORPHO_BLUE_ABI,
        functionName: 'isLltvEnabled',
        args: [lltv50Percent]
      }),
      (error) => console.error('Error reading MorphoBlue LLTV:', error)
    );

    // If we couldn't get any data, show error
    if (!owner && !feeRecipient && isLltv50Enabled === null) {
      throw new Error('Failed to load any MorphoBlue data');
    }

    // Format and display data
    morphoDataElement.innerHTML = '';
    morphoDataElement.classList.add('loaded');

    // Use type guards to ensure proper formatting
    const formattedData = [
      { label: 'Owner', value: owner ? shortenAddress(String(owner)) : 'Error loading' },
      { label: 'Fee Recipient', value: feeRecipient ? shortenAddress(String(feeRecipient)) : 'Error loading' },
      { label: '50% LLTV Enabled', value: isLltv50Enabled === null ? 'Error loading' : 
          isLltv50Enabled ? 'Yes' : 'No' },
      { label: 'Address', value: morphoAddress }
    ];

    formattedData.forEach(item => {
      const dataItem = document.createElement('div');
      dataItem.className = 'data-item';
      dataItem.innerHTML = `
        <div class="label">${item.label}</div>
        <div class="value">${item.value}</div>
      `;
      morphoDataElement.appendChild(dataItem);
    });
  } catch (error) {
    console.error('Error loading MorphoBlue data:', error);
    morphoDataElement.innerHTML = `<p>Error loading data. Make sure the ${currentChainInfo?.name || 'chain'} fork is running.</p>`;
  }
}

// Load origin contract data for vbUSDC
async function loadVBUSDCOriginData() {
  if (!addresses.hasOriginContract('vbUSDC')) {
    const originChain = currentChainId === CHAIN_IDS.KATANA ? 'Ethereum' : 'Sepolia';
    vbusdcOriginDataElement.innerHTML = `<p>vbUSDC not available on ${originChain} in this context</p>`;
    return;
  }

  vbusdcOriginDataElement.innerHTML = '<div class="spinner"></div><p>Loading origin data...</p>';
  
  try {
    const vbusdcOriginAddress = addresses.getOriginAddress('vbUSDC');
    const originChain = currentChainId === CHAIN_IDS.KATANA ? 'Ethereum' : 'Sepolia';
    
    // Since we're demonstrating cross-chain addresses, we can't actually read from origin contracts
    // via the local fork, but we can show the address and explain the concept
    vbusdcOriginDataElement.innerHTML = '';
    vbusdcOriginDataElement.classList.add('loaded');

    const formattedData = [
      { label: 'Origin Chain', value: originChain },
      { label: 'Contract Type', value: 'Vault Bridge USDC Token' },
      { label: 'Purpose', value: 'Cross-chain yield-bearing USDC' },
      { label: 'Origin Address', value: vbusdcOriginAddress },
      { label: 'Note', value: 'This contract exists on the origin chain and cannot be read directly from the destination chain fork.' }
    ];

    formattedData.forEach(item => {
      const dataItem = document.createElement('div');
      dataItem.className = 'data-item';
      dataItem.innerHTML = `
        <div class="label">${item.label}</div>
        <div class="value">${item.value}</div>
      `;
      vbusdcOriginDataElement.appendChild(dataItem);
    });
  } catch (error) {
    console.error('Error loading vbUSDC origin data:', error);
    vbusdcOriginDataElement.innerHTML = `<p>Error loading origin data.</p>`;
  }
}

// Load origin contract data for vbETH
async function loadVBETHOriginData() {
  if (!addresses.hasOriginContract('vbETH')) {
    const originChain = currentChainId === CHAIN_IDS.KATANA ? 'Ethereum' : 'Sepolia';
    vbethOriginDataElement.innerHTML = `<p>vbETH not available on ${originChain} in this context</p>`;
    return;
  }

  vbethOriginDataElement.innerHTML = '<div class="spinner"></div><p>Loading origin data...</p>';
  
  try {
    const vbethOriginAddress = addresses.getOriginAddress('vbETH');
    const originChain = currentChainId === CHAIN_IDS.KATANA ? 'Ethereum' : 'Sepolia';
    
    vbethOriginDataElement.innerHTML = '';
    vbethOriginDataElement.classList.add('loaded');

    const formattedData = [
      { label: 'Origin Chain', value: originChain },
      { label: 'Contract Type', value: 'Vault Bridge ETH Token' },
      { label: 'Purpose', value: 'Cross-chain yield-bearing ETH' },
      { label: 'Origin Address', value: vbethOriginAddress },
      { label: 'Note', value: 'This contract exists on the origin chain and cannot be read directly from the destination chain fork.' }
    ];

    formattedData.forEach(item => {
      const dataItem = document.createElement('div');
      dataItem.className = 'data-item';
      dataItem.innerHTML = `
        <div class="label">${item.label}</div>
        <div class="value">${item.value}</div>
      `;
      vbethOriginDataElement.appendChild(dataItem);
    });
  } catch (error) {
    console.error('Error loading vbETH origin data:', error);
    vbethOriginDataElement.innerHTML = `<p>Error loading origin data.</p>`;
  }
}

// Helper function to create chain config for viem
function createChainConfig() {
  return {
    id: currentChainId,
    name: currentChainInfo?.name || 'Unknown',
    nativeCurrency: {
      decimals: 18,
      name: 'Ether',
      symbol: 'ETH',
    },
    rpcUrls: {
      default: {
        http: ['http://localhost:8545'],
      },
    },
  };
}

// Load all contract data
async function loadContractData() {
  // Load data sequentially to avoid overloading the server
  // Only load contracts that are available on the current chain
  try {
    console.log(`ğŸ“Š Loading contract data for ${currentChainInfo?.name}...`);
    
    if (addresses.hasContract('AUSD')) {
      await loadAUSDData();
    } else {
      ausdDataElement.innerHTML = `<p>AUSD not deployed on ${currentChainInfo?.name}</p>`;
    }
    
    if (addresses.hasContract('bvbEth')) {
      await loadWETHData();
    } else {
      wethDataElement.innerHTML = `<p>bvbEth not deployed on ${currentChainInfo?.name}</p>`;
    }
    
    if (addresses.hasContract('MorphoBlue')) {
      await loadMorphoData();
    } else {
      morphoDataElement.innerHTML = `<p>MorphoBlue not deployed on ${currentChainInfo?.name}</p>`;
    }

    // Load origin contract data
    await loadVBUSDCOriginData();
    await loadVBETHOriginData();
    
    console.log('âœ… Contract data loading complete');
  } catch (error) {
    console.error('Failed to load contract data:', error);
  }
}

// Load ETH and bvbEth balances
async function loadBalances() {
  if (!walletClient || !publicClient) {
    ethBalanceElement.textContent = 'Wallet not connected';
    wethBalanceElement.textContent = 'Wallet not connected';
    return;
  }
  
  try {
    // Get connected account
    const accounts = await walletClient.getAddresses();
    if (accounts.length === 0) {
      return;
    }
    const account = accounts[0];
    
    // Get bvbEth address for the current chain
    const wethAddress = addresses.getAddress('bvbEth');
    if (!wethAddress) {
      ethBalanceElement.textContent = 'bvbEth not available';
      wethBalanceElement.textContent = 'bvbEth not available';
      return;
    }
    
    // Read ETH balance
    const ethBalance = await publicClient.getBalance({ address: account });
    ethBalanceElement.textContent = `${formatEther(ethBalance)} ETH`;
    
    // Read bvbEth balance
    const wethBalance = await publicClient.readContract({
      address: wethAddress,
      abi: WETH_ABI,
      functionName: 'balanceOf',
      args: [account]
    });
    
    wethBalanceElement.textContent = `${formatEther(wethBalance as bigint)} bvbEth`;
    
    // Enable buttons if wallet is connected
    wrapButton.disabled = false;
    unwrapButton.disabled = false;
  } catch (error) {
    console.error('Error loading balances:', error);
    ethBalanceElement.textContent = 'Error loading';
    wethBalanceElement.textContent = 'Error loading';
  }
}

// Wrap ETH to bvbEth
async function wrapEth() {
  if (!walletClient || !publicClient) {
    alert('Please connect your wallet first');
    return;
  }
  
  const wrapAmount = wrapAmountInput.value;
  if (!wrapAmount || parseFloat(wrapAmount) <= 0) {
    alert('Please enter a valid amount');
    return;
  }
  
  try {
    const accounts = await walletClient.getAddresses();
    const account = accounts[0];
    
    // Get bvbEth address for the current chain
    const wethAddress = addresses.getAddress('bvbEth');
    if (!wethAddress) {
      alert('bvbEth not available on this chain');
      return;
    }
    
    // Convert the input value to Wei (bigint)
    const wrapAmountWei = parseUnits(wrapAmount, 18);
    

    
    // Show loading state
    wrapButton.disabled = true;
    wrapButton.textContent = 'Processing...';
    
    // Call bvbEth deposit function
    const hash = await walletClient.writeContract({
      address: wethAddress,
      abi: WETH_ABI,
      functionName: 'deposit',
      value: wrapAmountWei,
      account,
      chain: createChainConfig()
    });
    
    // Wait for transaction to be mined
    const receipt = await publicClient.waitForTransactionReceipt({ hash });
    
    if (receipt.status === 'success') {
      alert(`Successfully wrapped ${wrapAmount} ETH to bvbEth!`);
      
      // Clear input and update balances
      wrapAmountInput.value = '';
      loadBalances();
    } else {
      alert('Transaction failed. Please try again.');
    }
  } catch (error) {
    console.error('Error wrapping ETH:', error);
    alert('Error wrapping ETH. See console for details.');
  } finally {
    // Reset button state
    wrapButton.disabled = false;
    wrapButton.textContent = 'Wrap ETH';
  }
}

// Unwrap bvbEth to ETH
async function unwrapWeth() {
  if (!walletClient || !publicClient) {
    alert('Please connect your wallet first');
    return;
  }
  
  const unwrapAmount = unwrapAmountInput.value;
  if (!unwrapAmount || parseFloat(unwrapAmount) <= 0) {
    alert('Please enter a valid amount');
    return;
  }
  
  try {
    const accounts = await walletClient.getAddresses();
    const account = accounts[0];
    
    // Get bvbEth address for the current chain
    const wethAddress = addresses.getAddress('bvbEth');
    if (!wethAddress) {
      alert('bvbEth not available on this chain');
      return;
    }
    
    // Convert the input value to Wei (bigint)
    const unwrapAmountWei = parseUnits(unwrapAmount, 18);
    
    // Show loading state
    unwrapButton.disabled = true;
    unwrapButton.textContent = 'Processing...';
    
    // Call bvbEth withdraw function
    const hash = await walletClient.writeContract({
      address: wethAddress,
      abi: WETH_ABI,
      functionName: 'withdraw',
      args: [unwrapAmountWei],
      account,
      chain: createChainConfig()
    });
    
    // Wait for transaction to be mined
    const receipt = await publicClient.waitForTransactionReceipt({ hash });
    
    if (receipt.status === 'success') {
      alert(`Successfully unwrapped ${unwrapAmount} bvbEth to ETH!`);
      
      // Clear input and update balances
      unwrapAmountInput.value = '';
      loadBalances();
    } else {
      alert('Transaction failed. Please try again.');
    }
  } catch (error) {
    console.error('Error unwrapping bvbEth:', error);
    alert('Error unwrapping bvbEth. See console for details.');
  } finally {
    // Reset button state
    unwrapButton.disabled = false;
    unwrapButton.textContent = 'Unwrap bvbEth';
  }
}

// Add error styles and section styling
const style = document.createElement('style');
style.textContent = `
  .error-message {
    background-color: #fef2f2;
    border: 1px solid #fee2e2;
    border-radius: 6px;
    padding: 12px;
    margin-top: 10px;
  }
  
  .error-message h4 {
    color: #dc2626;
    margin-bottom: 8px;
  }
  
  .error-message pre {
    background-color: #f1f5f9;
    padding: 8px;
    border-radius: 4px;
    margin: 8px 0;
    overflow-x: auto;
  }
  
  .section-description {
    color: #6b7280;
    font-style: italic;
    margin-bottom: 1rem;
    line-height: 1.5;
  }
  
  #origin-contracts-section {
    margin-top: 2rem;
    padding-top: 1.5rem;
    border-top: 1px solid #e5e7eb;
  }
  
  #origin-contracts-section .card {
    border-left: 3px solid #10b981;
  }
`;
document.head.appendChild(style);

// Event listeners
connectWalletButton.addEventListener('click', connectWallet);
wrapButton.addEventListener('click', wrapEth);
unwrapButton.addEventListener('click', unwrapWeth);

// Initialize the app
initialize();

// Add window.ethereum type
declare global {
  interface Window {
    ethereum: any;
  }
}



================================================
FILE: examples/wrapping/style.css
================================================
:root {
  --primary-color: #6366f1;
  --secondary-color: #4f46e5;
  --text-color: #1e293b;
  --light-text: #94a3b8;
  --background: #f8fafc;
  --card-bg: #ffffff;
  --border-color: #e2e8f0;
  --success-color: #10b981;
  --error-color: #ef4444;
  --warning-color: #f59e0b;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  line-height: 1.6;
  color: var(--text-color);
  background-color: var(--background);
}

.container {
  max-width: 1100px;
  margin: 0 auto;
  padding: 20px;
}

header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 30px;
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 20px;
}

header h1 {
  font-size: 2rem;
  color: var(--primary-color);
}

.network-status {
  display: flex;
  align-items: center;
  gap: 10px;
}

#network-indicator {
  display: inline-block;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background-color: var(--warning-color);
}

#network-indicator.connected {
  background-color: var(--success-color);
}

#network-indicator.error {
  background-color: var(--error-color);
}

section {
  margin-bottom: 30px;
}

h2 {
  margin-bottom: 15px;
  color: var(--text-color);
  font-weight: 600;
}

h3 {
  margin-bottom: 15px;
  color: var(--text-color);
  font-weight: 500;
}

.card {
  background-color: var(--card-bg);
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  margin-bottom: 20px;
}

.contract-address {
  margin-bottom: 15px;
  font-size: 0.9rem;
  color: var(--light-text);
}

.contract-address code {
  display: block;
  margin-top: 5px;
  padding: 5px;
  background-color: var(--background);
  border-radius: 4px;
  overflow-wrap: break-word;
}

.contract-data {
  min-height: 100px;
}

.contract-data.loaded {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 10px;
}

.data-item {
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 10px;
}

.data-item .label {
  font-size: 0.9rem;
  color: var(--light-text);
}

.data-item .value {
  font-weight: 500;
}

.spinner {
  margin: 20px auto;
  width: 30px;
  height: 30px;
  border: 3px solid var(--light-text);
  border-top: 3px solid var(--primary-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

button {
  padding: 10px 15px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 500;
  transition: all 0.2s ease;
}

.primary-button {
  background-color: var(--primary-color);
  color: white;
}

.primary-button:hover {
  background-color: var(--secondary-color);
}

/* Error message styling */
.error-message {
  background-color: #fef2f2;
  border: 1px solid #fee2e2;
  border-radius: 6px;
  padding: 12px;
  margin-top: 10px;
  color: #b91c1c;
}

.error-message h4 {
  color: #dc2626;
  margin-bottom: 8px;
  font-weight: 600;
}

.error-message pre {
  background-color: #f1f5f9;
  padding: 8px;
  border-radius: 4px;
  margin: 8px 0;
  overflow-x: auto;
  color: #334155;
  font-family: monospace;
}

footer {
  margin-top: 50px;
  padding-top: 20px;
  border-top: 1px solid var(--border-color);
  text-align: center;
  color: var(--light-text);
  font-size: 0.9rem;
}

/* ETH/bvbEth Operations */
#eth-weth-section {
  margin-top: 2rem;
}

.balances-container {
  display: flex;
  gap: 1.5rem;
  margin-bottom: 1.5rem;
}

.balance-item {
  flex: 1;
  background-color: #f5f7fa;
  border-radius: 6px;
  padding: 0.8rem 1rem;
}

.balance-item .label {
  font-size: 0.9rem;
  color: #687588;
  margin-bottom: 0.4rem;
}

.balance-item .value {
  font-weight: 600;
  font-size: 1.2rem;
}

.operations-container {
  display: flex;
  gap: 1.5rem;
}

.operation-card {
  flex: 1;
  border: 1px solid #e0e4e9;
  border-radius: 6px;
  padding: 1rem;
}

.operation-card h4 {
  margin-top: 0;
  margin-bottom: 0.5rem;
  font-size: 1rem;
}

.operation-description {
  font-size: 0.85rem;
  color: #687588;
  margin-bottom: 1rem;
  margin-top: 0;
}

.form-group {
  margin-bottom: 1rem;
}

.form-group label {
  display: block;
  margin-bottom: 0.5rem;
  font-size: 0.9rem;
  font-weight: 500;
}

.form-group input {
  width: 100%;
  padding: 0.6rem;
  border: 1px solid #d0d6df;
  border-radius: 4px;
  font-size: 1rem;
  box-sizing: border-box;
}

.form-group input:focus {
  outline: none;
  border-color: #1a73e8;
}

@media (max-width: 768px) {
  .balances-container,
  .operations-container {
    flex-direction: column;
  }
}



================================================
FILE: forge/README.md
================================================
## Foundry

**Foundry is a blazing fast, portable and modular toolkit for Ethereum application development written in Rust.**

Foundry consists of:

-   **Forge**: Ethereum testing framework (like Truffle, Hardhat and DappTools).
-   **Cast**: Swiss army knife for interacting with EVM smart contracts, sending transactions and getting chain data.
-   **Anvil**: Local Ethereum node, akin to Ganache, Hardhat Network.
-   **Chisel**: Fast, utilitarian, and verbose solidity REPL.

## Documentation

https://book.getfoundry.sh/

## Usage

### Build

```shell
$ forge build
```

### Test

```shell
$ forge test
```

### Format

```shell
$ forge fmt
```

### Gas Snapshots

```shell
$ forge snapshot
```

### Anvil

```shell
$ anvil
```

### Deploy

```shell
$ forge script script/Counter.s.sol:CounterScript --rpc-url <your_rpc_url> --private-key <your_private_key>
```

### Cast

```shell
$ cast <subcommand>
```

### Help

```shell
$ forge --help
$ anvil --help
$ cast --help
```

# Forge Scripts

## Requesting Funds from AgoraFaucet

You can request funds using the AgoraFaucet script with Forge. Make sure you have a `.env` file in the `forge/` directory containing your `PRIVATE_KEY`:

```
PRIVATE_KEY=your_private_key_here
```

Then run the following command from the `forge/` directory:

```
forge script script/AgoraFaucet.s.sol --rpc-url tatara
```



================================================
FILE: forge/foundry.toml
================================================
[profile.default]
src = "src"
out = "out"
libs = ["lib"]
evm_version = "cancun"
optimizer = true
optimizer_runs = 200
cache = true
cache_path = 'cache'
broadcast = 'broadcast'


[rpc_endpoints]
katana = "https://rpc.katana.network"
bokuto = "https://rpc-bokuto.katanarpc.com"
# See more config options https://github.com/foundry-rs/foundry/blob/master/crates/config/README.md#all-options



================================================
FILE: forge/remappings.txt
================================================
forge-std/=lib/forge-std/src/
contracts/=../contracts/


================================================
FILE: forge/script/AgoraFaucet.s.sol
================================================
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

import {Script, console} from "../lib/forge-std/src/Script.sol";
import { IAgoraFaucet } from "contracts/IAgoraFaucet.sol";
import { BokutoAddresses } from "contracts/utils/BokutoAddresses.sol";

contract CounterScript is Script {
    IAgoraFaucet public agoraFaucet;

    function setUp() public {
        agoraFaucet = IAgoraFaucet(BokutoAddresses.getAgoraFaucetAddress());
    }

    function run() public {
        uint256 privateKey = vm.envUint("PRIVATE_KEY");

        address msgSender = vm.addr(privateKey);
        console.log("msg.sender is : ", msgSender);

        vm.startBroadcast(privateKey);

        agoraFaucet.requestFunds(msgSender);

        vm.stopBroadcast();
    }
}



================================================
FILE: forge/script/Counter.s.sol
================================================
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

import {Script, console} from "../lib/forge-std/src/Script.sol";
import {Counter} from "../src/Counter.sol";

contract CounterScript is Script {
    Counter public counter;

    function setUp() public {}

    function run() public {
        vm.startBroadcast();

        counter = new Counter();

        vm.stopBroadcast();
    }
}



================================================
FILE: forge/src/Coinflip.sol
================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

/**
 * @title CoinFlipper
 * @dev A simple contract that simulates coin flips and stores results
 */
contract CoinFlipper {
    // Struct to store flip results
    struct FlipResult {
        bool isHeads;
        uint256 timestamp;
        address player;
    }

    // Array to store all flip results
    FlipResult[] public flipHistory;

    // Event emitted on each flip
    event CoinFlipped(address indexed player, bool isHeads, uint256 timestamp);

    /**
     * @dev Flips a coin and stores the result
     * @return bool true for heads, false for tails
     */
    function flipCoin() public returns (bool) {
        // Use block hash and sender address for randomness
        // Note: This is not cryptographically secure, but sufficient for demo
        bytes32 randomHash = keccak256(
            abi.encodePacked(
                blockhash(block.number - 1),
                msg.sender,
                block.timestamp
            )
        );
        
        // Use the first byte of the hash to determine heads/tails
        bool isHeads = uint8(randomHash[0]) > 127;
        
        // Store the result
        flipHistory.push(
            FlipResult({
                isHeads: isHeads,
                timestamp: block.timestamp,
                player: msg.sender
            })
        );
        
        // Emit the event
        emit CoinFlipped(msg.sender, isHeads, block.timestamp);
        
        return isHeads;
    }

    /**
     * @dev Get the total number of flips
     * @return uint256 number of flips
     */
    function getFlipCount() public view returns (uint256) {
        return flipHistory.length;
    }

    /**
     * @dev Get multiple flip results at once
     * @param startIndex start index in the history
     * @param count number of results to return
     * @return FlipResult[] array of flip results
     */
    function getFlipResults(uint256 startIndex, uint256 count) 
        public 
        view 
        returns (FlipResult[] memory) 
    {
        require(startIndex < flipHistory.length, "Start index out of bounds");
        
        // Adjust count if it would exceed array bounds
        if (startIndex + count > flipHistory.length) {
            count = flipHistory.length - startIndex;
        }
        
        FlipResult[] memory results = new FlipResult[](count);
        for (uint256 i = 0; i < count; i++) {
            results[i] = flipHistory[startIndex + i];
        }
        
        return results;
    }
}



================================================
FILE: forge/src/Counter.sol
================================================
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

contract Counter {
    uint256 public number;

    function setNumber(uint256 newNumber) public {
        number = newNumber;
    }

    function increment() public {
        number++;
    }
}



================================================
FILE: forge/src/Lock.sol
================================================
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

contract Lock {
    uint public unlockTime;
    address payable public owner;

    event Withdrawal(uint amount, uint when);

    constructor(uint _unlockTime) payable {
        require(
            block.timestamp < _unlockTime,
            "Unlock time should be in the future"
        );

        unlockTime = _unlockTime;
        owner = payable(msg.sender);
    }

    function withdraw() public {

        require(block.timestamp >= unlockTime, "You can't withdraw yet");
        require(msg.sender == owner, "You aren't the owner");

        emit Withdrawal(address(this).balance, block.timestamp);

        owner.transfer(address(this).balance);
    }
}



================================================
FILE: forge/test/Coinflip.t.sol
================================================
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

import {Test, console} from "../lib/forge-std/src/Test.sol";
import {CoinFlipper} from "../src/Coinflip.sol";

contract CoinFlipperTest is Test {
    CoinFlipper public flipper;
    address public player1;
    address public player2;

    function setUp() public {
        flipper = new CoinFlipper();
        player1 = address(0x1);
        player2 = address(0x2);
        
        // Give both players some ETH for gas
        vm.deal(player1, 1 ether);
        vm.deal(player2, 1 ether);
    }

    function test_InitialState() public {
        assertEq(flipper.getFlipCount(), 0);
    }

    function test_SingleFlip() public {
        vm.prank(player1);
        bool result = flipper.flipCoin();
        
        assertEq(flipper.getFlipCount(), 1);
        
        CoinFlipper.FlipResult[] memory results = flipper.getFlipResults(0, 1);
        assertEq(results[0].player, player1);
        assertEq(results[0].isHeads, result);
        assertEq(results[0].timestamp, block.timestamp);
    }

    function test_MultipleFlips() public {
        // Player 1 flips
        vm.prank(player1);
        flipper.flipCoin();
        
        // Player 2 flips
        vm.prank(player2);
        flipper.flipCoin();
        
        // Check count
        assertEq(flipper.getFlipCount(), 2);
        
        // Check results
        CoinFlipper.FlipResult[] memory results = flipper.getFlipResults(0, 2);
        assertEq(results[0].player, player1);
        assertEq(results[1].player, player2);
    }

    function test_FlipEvent() public {
        vm.prank(player1);
        
        // Expect the CoinFlipped event with correct parameters
        vm.expectEmit(true, true, true, true);
        emit CoinFlipper.CoinFlipped(player1, true, block.timestamp);
        
        // This might fail sometimes since the result is random
        // We'll handle this in the fuzz test
        flipper.flipCoin();
    }

    function testRevert_GetResultsOutOfBounds() public {
        vm.expectRevert("Start index out of bounds");
        flipper.getFlipResults(1, 1);
    }

    function test_GetResultsAdjustCount() public {
        // Do one flip
        vm.prank(player1);
        flipper.flipCoin();
        
        // Try to get 2 results
        CoinFlipper.FlipResult[] memory results = flipper.getFlipResults(0, 2);
        assertEq(results.length, 1);
    }

    function testFuzz_MultipleFlips(uint8 numFlips) public {
        // Bound number of flips to something reasonable
        numFlips = uint8(bound(uint256(numFlips), 1, 10));
        
        // Do the flips
        for(uint8 i = 0; i < numFlips; i++) {
            vm.prank(player1);
            flipper.flipCoin();
        }
        
        // Check count
        assertEq(flipper.getFlipCount(), numFlips);
        
        // Check results
        CoinFlipper.FlipResult[] memory results = flipper.getFlipResults(0, numFlips);
        assertEq(results.length, numFlips);
        
        // Verify all results are from player1
        for(uint8 i = 0; i < numFlips; i++) {
            assertEq(results[i].player, player1);
        }
    }

    function testFuzz_RandomnessDistribution(uint256 numFlips) public {
        // Bound number of flips to something statistically significant
        numFlips = bound(numFlips, 100, 1000);
        
        uint256 heads = 0;
        
        // Do the flips
        for(uint256 i = 0; i < numFlips; i++) {
            // Change block number and timestamp to affect randomness
            vm.roll(block.number + 1);
            vm.warp(block.timestamp + 1);
            
            vm.prank(player1);
            bool isHeads = flipper.flipCoin();
            if(isHeads) heads++;
        }
        
        // Check that heads ratio is roughly 50% (within 10% margin)
        uint256 ratio = (heads * 100) / numFlips;
        assertTrue(ratio >= 40 && ratio <= 60, "Random distribution is too skewed");
    }
} 


================================================
FILE: forge/test/Counter.t.sol
================================================
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

import {Test, console} from "../lib/forge-std/src/Test.sol";
import {Counter} from "../src/Counter.sol";

contract CounterTest is Test {
    Counter public counter;

    function setUp() public {
        counter = new Counter();
        counter.setNumber(0);
    }

    function test_Increment() public {
        counter.increment();
        assertEq(counter.number(), 1);
    }

    function testFuzz_SetNumber(uint256 x) public {
        counter.setNumber(x);
        assertEq(counter.number(), x);
    }
}



================================================
FILE: forge/test/Lock.t.sol
================================================
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

import {Test, console} from "../lib/forge-std/src/Test.sol";
import {Lock} from "../src/Lock.sol";

contract LockTest is Test {
    Lock public lock;
    uint256 public unlockTime;
    uint256 public lockedAmount = 1 ether;
    address payable public owner;
    address payable public otherUser;

    function setUp() public {
        owner = payable(makeAddr("owner"));
        otherUser = payable(makeAddr("other"));
        unlockTime = block.timestamp + 1 days;
        
        // Give owner some ETH
        vm.deal(owner, 10 ether);
        
        // Deploy contract as owner
        vm.prank(owner);
        lock = new Lock{value: lockedAmount}(unlockTime);
    }

    function test_Constructor() public {
        assertEq(lock.unlockTime(), unlockTime);
        assertEq(lock.owner(), owner);
        assertEq(address(lock).balance, lockedAmount);
    }

    function testRevert_ConstructorPastTime() public {
        vm.warp(block.timestamp + 2 days); // Move time forward
        vm.expectRevert("Unlock time should be in the future");
        new Lock(block.timestamp - 1);
    }

    function testRevert_WithdrawTooEarly() public {
        vm.prank(owner);
        vm.expectRevert("You can't withdraw yet");
        lock.withdraw();
    }

    function testRevert_WithdrawNotOwner() public {
        vm.warp(block.timestamp + 2 days); // Move past unlock time
        vm.prank(otherUser); // Impersonate other user
        vm.expectRevert("You aren't the owner");
        lock.withdraw();
    }

    function test_Withdraw() public {
        uint256 preBalance = owner.balance;
        
        // Move time forward
        vm.warp(block.timestamp + 2 days);
        
        // Withdraw as owner
        vm.prank(owner);
        lock.withdraw();
        
        // Check balances
        assertEq(address(lock).balance, 0);
        assertEq(owner.balance, preBalance + lockedAmount);
    }

    // Fuzz test the constructor with different unlock times
    function testFuzz_Constructor(uint256 futureTime) public {
        // Bound the future time to something reasonable
        futureTime = bound(futureTime, block.timestamp + 1, block.timestamp + 100 days);
        
        vm.prank(owner);
        Lock newLock = new Lock{value: lockedAmount}(futureTime);
        assertEq(newLock.unlockTime(), futureTime);
    }
} 


================================================
FILE: runbooks/README.md
================================================
# specialk Runbooks

[![Txtx](https://img.shields.io/badge/Operated%20with-Txtx-gree?labelColor=gray)](https://txtx.sh)

## Runbooks available

### deployer


## Getting Started

This repository is using [txtx](https://txtx.sh) for handling its on-chain operations.

`txtx` takes its inspiration from a battle tested devops best practice named `infrastructure as code`, that have transformed cloud architectures. 

`txtx` simplifies and streamlines Smart Contract Infrastructure management across blockchains, focusing on robustness, reproducibility and composability.

### Installation

```console
$ curl -sL https://install.txtx.sh/ | bash
```

### Scaffold a new runbook

```console
$ txtx new
```

Access tutorials and documentation at [docs.txtx.sh](https://docs.txtx.sh) to understand the syntax and discover the powerful features of txtx. 

Additionally, the [Visual Studio Code extension](https://marketplace.visualstudio.com/items?itemName=txtx.txtx) will make writing runbooks easier.

### List runbooks available in this repository
```console
$ txtx ls
Name                ID               Description
BNS Multisig        bns-multisig     Register a BNS name using a multisig signer
```

### Execute an existing runbook
```console
$ txtx run bns-multisig
```

### Update the README documentation
```console
$ txtx docs --update 
```



================================================
FILE: runbooks/deployments/deployer.tx
================================================
// Access tutorials and documentation at [docs.txtx.sh](https://docs.txtx.sh) 
// to understand the syntax and discover the powerful features of txtx.

addon "stacks" {
  network_id = input.stacks_network_id
  rpc_api_url = input.stacks_api_url
}

signer "alice" "stacks::web_wallet" {
  expected_address = input.stacks_operator_address
}

variable "step" {
  description = "Amount of steps to increment"
  value = 1
}

action "increment_counter" "stacks::call_contract" {
  description = "Increment counter contract of ${variable.step}"
  contract_id = "ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.counter"
  function_name = "increment"
  function_args = [
      stacks::cv_uint(variable.step),
  ]
  signer = signer.alice
  confirmations = 1
}

output "counter_value" {
  description = "Increment counter contract of ${variable.step}"
  value = action.increment_counter.tx_id
}



================================================
FILE: scripts/build_abi.js
================================================
#!/usr/bin/env node

import { execSync } from 'node:child_process';
import { existsSync, mkdirSync, rmSync, readdirSync, statSync, writeFileSync, readFileSync } from 'node:fs';
import { join, relative, dirname, basename } from 'node:path';

// Paths
const CONTRACTS_DIR = join(process.cwd(), 'contracts');
const ABIS_DIR = join(process.cwd(), 'abis');
const TEMP_DIR = join(process.cwd(), 'temp_abis');

// Check if contracts directory exists
if (!existsSync(CONTRACTS_DIR)) {
  console.error('Contracts directory not found');
  process.exit(1);
}

// Clean up existing directories
if (existsSync(ABIS_DIR)) {
  console.log('Cleaning up existing abis directory');
  rmSync(ABIS_DIR, { recursive: true, force: true });
}

if (existsSync(TEMP_DIR)) {
  rmSync(TEMP_DIR, { recursive: true, force: true });
}

// Create directories
console.log('Creating directories');
mkdirSync(ABIS_DIR);
mkdirSync(TEMP_DIR);

// Get all contract files (interfaces and contracts)
function getAllContractFiles(dir, relativePath = '', result = []) {
  const files = readdirSync(dir);
  
  for (const file of files) {
    const filePath = join(dir, file);
    const stats = statSync(filePath);
    
    if (stats.isDirectory()) {
      // Skip the utils directory since those are generated files
      if (file === 'utils') {
        console.log(`Skipping generated directory: ${join(relativePath, file)}`);
        continue;
      }
      
      const newRelativePath = join(relativePath, file);
      getAllContractFiles(filePath, newRelativePath, result);
    } else if (file.endsWith('.sol')) {
      result.push({
        path: filePath,
        relativePath: relativePath
      });
    }
  }
  
  return result;
}

// Extract contract/interface name from file content
function extractContractName(filePath) {
  try {
    const content = readFileSync(filePath, 'utf8');
    
    // Try to match interface definition
    const interfaceMatch = content.match(/interface\s+(\w+)/);
    if (interfaceMatch && interfaceMatch[1]) {
      return interfaceMatch[1];
    }
    
    // Try to match contract definition
    const contractMatch = content.match(/contract\s+(\w+)/);
    if (contractMatch && contractMatch[1]) {
      return contractMatch[1];
    }
    
    // Fallback to filename
    const fileName = basename(filePath, '.sol');
    return fileName;
  } catch (error) {
    console.error(`Error reading file ${filePath}:`, error.message);
    return basename(filePath, '.sol'); // Fallback to filename even on error
  }
}

// Format JSON nicely
function formatJson(jsonStr) {
  try {
    const obj = JSON.parse(jsonStr);
    return JSON.stringify(obj, null, 2);
  } catch (error) {
    return jsonStr;
  }
}

// Process a single contract/interface file to extract ABI
function processContract(contractFile) {
  const { path, relativePath } = contractFile;
  const fileName = basename(path, '.sol');
  const outDir = join(ABIS_DIR, relativePath);
  
  // Create directory if it doesn't exist
  if (!existsSync(outDir)) {
    mkdirSync(outDir, { recursive: true });
  }
  
  const outputPath = join(outDir, `${fileName}.json`);
  console.log(`Processing ${relative(CONTRACTS_DIR, path)}`);
  
  try {
    // Generate ABI using solc
    let solcCmd = `solc --abi --pretty-json --include-path node_modules/ --base-path . -o ${TEMP_DIR} ${path}`;
    try {
      execSync(solcCmd, { stdio: 'pipe' });
    } catch (solcError) {
      // If solc fails, try solcjs
      solcCmd = `solcjs --abi --include-path node_modules/ --base-path . -o ${TEMP_DIR} ${path}`;
      try{
        execSync(solcCmd, { stdio: 'pipe' });
      } catch (solcjsError){
        console.error(`  - Error generating ABI for ${fileName}: ${solcjsError.message}`);
      }
      
    }
    
    // Find the generated ABI file
    const abiFiles = readdirSync(TEMP_DIR);
    let abiFile = null;
    
    const contractName = extractContractName(path);
    for (const file of abiFiles) {
      if (contractName && file.includes(contractName)) {
        abiFile = file;
        break;
      } else if (file.includes(fileName)) {
        abiFile = file;
        break;
      }
    }
    
    if (!abiFile && abiFiles.length > 0) {
      // Just use the first one if we can't match by name
      abiFile = abiFiles[0];
    }
    
    if (abiFile) {
      // Read, format, and write the ABI
      const abiContent = readFileSync(join(TEMP_DIR, abiFile), 'utf8');
      writeFileSync(outputPath, formatJson(abiContent));
      console.log(`  - ABI written to ${relative(process.cwd(), outputPath)}`);
    } else {
      console.error(`  - No ABI file generated for ${fileName}`);
    }
    
    // Clean up temp files
    for (const file of abiFiles) {
      rmSync(join(TEMP_DIR, file));
    }
  } catch (error) {
    console.error(`  - Error processing ${path}: ${error.message}`);
  }
}

// Main execution
console.log('Scanning contracts...');
const contractFiles = getAllContractFiles(CONTRACTS_DIR);
console.log(`Found ${contractFiles.length} contract files`);

console.log('Generating ABIs...');
for (const contractFile of contractFiles) {
  processContract(contractFile);
}

// Clean up temp directory
if (existsSync(TEMP_DIR)) {
  rmSync(TEMP_DIR, { recursive: true, force: true });
}

console.log('ABI generation complete');

// Validation function
function countFilesRecursively(dir, extension, skipDirs = []) {
  let count = 0;
  const items = readdirSync(dir);
  
  for (const item of items) {
    const fullPath = join(dir, item);
    const stats = statSync(fullPath);
    
    if (stats.isDirectory()) {
      // Skip specified directories
      if (skipDirs.includes(item)) {
        continue;
      }
      count += countFilesRecursively(fullPath, extension, skipDirs);
    } else if (item.endsWith(extension)) {
      count++;
    }
  }
  
  return count;
}

// Validate the generated ABIs
console.log('\nValidation Check:');
const contractCount = countFilesRecursively(CONTRACTS_DIR, '.sol', ['utils']);
const abiCount = countFilesRecursively(ABIS_DIR, '.json');

console.log(`  - Total contract files: ${contractCount}`);
console.log(`  - Total generated ABIs: ${abiCount}`);

if (abiCount === contractCount) {
  console.log('\nâœ… OK: The number of generated ABIs matches the number of contract files.');
} else {
  console.log('\nâŒ NOK: The number of generated ABIs does not match the number of contract files.');
  process.exit(1); // Exit with error code if validation fails
} 


================================================
FILE: scripts/build_address_utils.js
================================================
#!/usr/bin/env node

import { existsSync, readdirSync, readFileSync, writeFileSync, statSync, mkdirSync } from 'node:fs';
import { join, basename, relative } from 'node:path';
import { createHash } from 'node:crypto';

// Constants
const CONTRACTS_DIR = join(process.cwd(), 'contracts');
const UTILS_DIR = join(CONTRACTS_DIR, 'utils');
const JS_UTILS_DIR = join(process.cwd(), 'utils', 'addresses');
const JS_OUTPUT_PATH = join(JS_UTILS_DIR, 'mapping.ts');

// Supported networks
const NETWORKS = ['katana', 'bokuto'];

// Chain IDs for each network
const CHAIN_IDS = {
  katana: 747474,
  bokuto: 737373,
};

/**
 * Get all Solidity files recursively
 */
function getAllSolidityFiles(dir, result = []) {
  const files = readdirSync(dir);
  
  for (const file of files) {
    const filePath = join(dir, file);
    const stats = statSync(filePath);
    
    if (stats.isDirectory() && file !== 'utils') { // Skip the utils directory to avoid circular references
      getAllSolidityFiles(filePath, result);
    } else if (file.endsWith('.sol')) {
      result.push(filePath);
    }
  }
  
  return result;
}

/**
 * Extract contract name from file content
 */
function extractContractName(filePath) {
  try {
    const content = readFileSync(filePath, 'utf8');
    
    // Split content into lines and process each line
    const lines = content.split('\n');
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      
      // Skip empty lines and comment lines
      if (!trimmedLine || trimmedLine.startsWith('//') || trimmedLine.startsWith('*') || trimmedLine.startsWith('/*')) {
        continue;
      }
      
      // Look for interface or contract declarations (not inside comments)
      const interfaceMatch = trimmedLine.match(/^interface\s+(\w+)/);
      if (interfaceMatch && interfaceMatch[1]) {
        return interfaceMatch[1];
      }
      
      const contractMatch = trimmedLine.match(/^contract\s+(\w+)/);
      if (contractMatch && contractMatch[1]) {
        return contractMatch[1];
      }
      
      // Also check for interface/contract after modifiers like 'abstract'
      const modifiedInterfaceMatch = trimmedLine.match(/^(?:abstract\s+)?interface\s+(\w+)/);
      if (modifiedInterfaceMatch && modifiedInterfaceMatch[1]) {
        return modifiedInterfaceMatch[1];
      }
      
      const modifiedContractMatch = trimmedLine.match(/^(?:abstract\s+)?contract\s+(\w+)/);
      if (modifiedContractMatch && modifiedContractMatch[1]) {
        return modifiedContractMatch[1];
      }
    }
    
    // Fallback to filename without extension
    return basename(filePath, '.sol');
  } catch (error) {
    console.error(`Error reading file ${filePath}:`, error.message);
    return basename(filePath, '.sol');
  }
}

/**
 * Convert address to proper checksum format
 * Maps known problematic addresses to their correct checksummed versions
 */
function toChecksumAddress(address) {
  // Known checksum mappings for problematic addresses
  const checksumMap = {
    '0xa40d5f56745a118d0906a34e69aec8c0db1cb8fa': '0xa40D5f56745a118D0906a34E69aeC8C0Db1cB8fA',
    '0x7fc98430eaedbb6070b35b39d798725049088348': '0x7fc98430eAEdbb6070B35B39D798725049088348',
    '0xccc0fc2e34428120f985b460b487eb79e3c6fa57': '0xccC0Fc2E34428120f985b460b487eB79E3C6FA57'
  };
  
  const lowerAddress = address.toLowerCase();
  
  // Return known checksum version if available
  if (checksumMap[lowerAddress]) {
    return checksumMap[lowerAddress];
  }
  
  // For other addresses, ensure they start with 0x
  return address.startsWith('0x') ? address : '0x' + address;
}

/**
 * Extract network addresses from doccomments
 */
function extractNetworkAddresses(filePath) {
  try {
    const content = readFileSync(filePath, 'utf8');
    const addresses = {};
    const originAddresses = {};
    
    // Look for @custom:networkName address patterns (destination chain)
    for (const network of NETWORKS) {
      const regex = new RegExp(`@custom:${network}\\s+(0x[a-fA-F0-9]{40})`, 'gi');
      const match = regex.exec(content);
      if (match && match[1]) {
        // Apply proper checksumming
        addresses[network] = toChecksumAddress(match[1]);
      }
    }
    
    // Look for @custom:networkName originChain:address patterns (origin chain)
    for (const network of NETWORKS) {
      const regex = new RegExp(`@custom:${network}\\s+(ethereum|sepolia):(0x[a-fA-F0-9]{40})`, 'gi');
      const match = regex.exec(content);
      if (match && match[2]) {
        // Apply proper checksumming
        originAddresses[network] = {
          originChain: match[1],
          address: toChecksumAddress(match[2])
        };
      }
    }
    
    return { addresses, originAddresses };
  } catch (error) {
    console.error(`Error reading file ${filePath}:`, error.message);
    return { addresses: {}, originAddresses: {} };
  }
}

/**
 * Convert contract name to function name
 * e.g., "IMultiSend" -> "getMultiSendAddress"
 */
function contractNameToFunctionName(contractName) {
  // Remove 'I' prefix if it exists and starts with uppercase
  let name = contractName;
  if (name.startsWith('I') && name.length > 1 && name[1] === name[1].toUpperCase()) {
    name = name.substring(1);
  }
  
  return `get${name}Address`;
}

/**
 * Generate address library file for a specific network
 */
function generateAddressLibrary(network, contracts) {
  const networkName = network.charAt(0).toUpperCase() + network.slice(1);
  const chainId = CHAIN_IDS[network];
  
  let content = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title ${networkName}Addresses
 * @notice Library for accessing ${networkName} network contract addresses
 * @dev Auto-generated from contract doccomments. Do not edit manually.
 */
library ${networkName}Addresses {\n`;

  // Add chain ID constant
  content += `    /**
     * @notice Chain ID for ${networkName} network
     */
    uint256 internal constant CHAIN_ID = ${chainId};

`;

  // Sort contracts by name for consistent output
  const sortedContracts = Object.entries(contracts).sort(([a], [b]) => a.localeCompare(b));

  if (sortedContracts.length === 0) {
    content += `    // No contracts found with @custom:${network} addresses
    // This file will be populated as contracts are deployed to ${networkName}

`;
  } else {
    // Add functions for each contract
    for (const [contractName, address] of sortedContracts) {
      const functionName = contractNameToFunctionName(contractName);
      
      content += `    /**
     * @notice Returns the address of ${contractName}
     * @return The ${contractName} contract address
     */
    function ${functionName}() internal pure returns (address) {
        return ${address};
    }

`;
    }
  }

  content += `}`; // Close the library

  return content;
}

/**
 * Generate origin addresses library file for a specific network
 */
function generateOriginAddressLibrary(network, originContracts) {
  const networkName = network.charAt(0).toUpperCase() + network.slice(1);
  
  let content = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title ${networkName}OriginAddresses
 * @notice Library for accessing origin chain contract addresses when operating in ${networkName} context
 * @dev Auto-generated from contract doccomments. Do not edit manually.
 *      These are contracts deployed on origin chains (Ethereum/Sepolia) that are accessed
 *      from the ${networkName} context for cross-chain operations like Vault Bridge.
 */
library ${networkName}OriginAddresses {\n`;

  // Sort contracts by name for consistent output
  const sortedContracts = Object.entries(originContracts).sort(([a], [b]) => a.localeCompare(b));

  if (sortedContracts.length === 0) {
    content += `    // No origin chain contracts found for ${network} context
    // This file will be populated as origin chain contracts are added

`;
  } else {
    // Add functions for each contract
    for (const [contractName, contractData] of sortedContracts) {
      const functionName = contractNameToFunctionName(contractName);
      const originChain = contractData.originChain;
      const address = contractData.address;
      
      content += `    /**
     * @notice Returns the origin chain address of ${contractName}
     * @dev This contract is deployed on ${originChain} and accessed from ${networkName} context
     * @return The ${contractName} contract address on ${originChain}
     */
    function ${functionName}() internal pure returns (address) {
        return ${address};
    }

`;
    }
  }

  content += `}`; // Close the library

  return content;
}

/**
 * Generate TypeScript address mapping file
 */
function generateTypeScriptMapping(networkContracts, originNetworkContracts) {
  // Get all unique contract names across all networks (destination contracts)
  const allContractNames = new Set();
  
  for (const network of NETWORKS) {
    for (const contractName of Object.keys(networkContracts[network])) {
      allContractNames.add(contractName);
    }
  }
  
  // Get all unique origin contract names across all networks
  const allOriginContractNames = new Set();
  
  for (const network of NETWORKS) {
    for (const contractName of Object.keys(originNetworkContracts[network])) {
      allOriginContractNames.add(contractName);
    }
  }
  
  // Create the mapping object for destination contracts
  const addressMapping = {};
  
  allContractNames.forEach(contractName => {
    addressMapping[contractName] = {
      katana: networkContracts.katana[contractName] || null,
      bokuto: networkContracts.bokuto[contractName] || null
    };
  });
  
  // Create the mapping object for origin contracts
  const originAddressMapping = {};
  
  allOriginContractNames.forEach(contractName => {
    originAddressMapping[contractName] = {
      katana: originNetworkContracts.katana[contractName]?.address || null,
      bokuto: originNetworkContracts.bokuto[contractName]?.address || null
    };
  });
  
  // Create the TypeScript file content - minimal data-only file
  const tsContent = `// Auto-generated contract address mapping data
// Generated on ${new Date().toISOString()}
// Do not edit manually - this file is generated by scripts/build_address_utils.js
// Add this file to .gitignore

export const CHAIN_IDS = {
  KATANA: ${CHAIN_IDS.katana},
  BOKUTO: ${CHAIN_IDS.bokuto}
} as const;

export const CONTRACT_ADDRESSES = {
${Object.entries(addressMapping)
  .sort(([a], [b]) => a.localeCompare(b))
  .map(([name, addrs]) => {
    // Simple string values, typing will be in index.ts
    const katana = addrs.katana ? `"katana": "${addrs.katana}"` : '"katana": null';
    const bokuto = addrs.bokuto ? `"bokuto": "${addrs.bokuto}"` : '"bokuto": null';
    return `  "${name}": { ${katana}, ${bokuto} }`;
  })
  .join(',\n')}
} as const;

export const ORIGIN_CONTRACT_ADDRESSES = {
${Object.entries(originAddressMapping)
  .sort(([a], [b]) => a.localeCompare(b))
  .map(([name, addrs]) => {
    // Simple string values, typing will be in index.ts
    const katana = addrs.katana ? `"katana": "${addrs.katana}"` : '"katana": null';
    const bokuto = addrs.bokuto ? `"bokuto": "${addrs.bokuto}"` : '"bokuto": null';
    return `  "${name}": { ${katana}, ${bokuto} }`;
  })
  .join(',\n')}
} as const;
`;

  return tsContent;
}

/**
 * Main function
 */
function main() {
  console.log('Building address utility files...');
  
  // Check if contracts directory exists
  if (!existsSync(CONTRACTS_DIR)) {
    console.error('Contracts directory not found');
    process.exit(1);
  }

  // Create utils directory if it doesn't exist
  if (!existsSync(UTILS_DIR)) {
    console.error('Utils directory not found');
    process.exit(1);
  }

  // Get all Solidity files
  console.log('Scanning for Solidity files...');
  const solidityFiles = getAllSolidityFiles(CONTRACTS_DIR);
  console.log(`Found ${solidityFiles.length} Solidity files`);

  // Parse files and extract addresses
  console.log('Extracting addresses from doccomments...');
  const networkContracts = {
    katana: {},
    bokuto: {}
  };

  const originNetworkContracts = {
    katana: {},
    bokuto: {}
  };

  let totalAddressesFound = 0;
  let totalOriginAddressesFound = 0;

  for (const filePath of solidityFiles) {
    const contractName = extractContractName(filePath);
    const { addresses, originAddresses } = extractNetworkAddresses(filePath);
    
    // Add destination chain addresses to appropriate network mappings
    for (const [network, address] of Object.entries(addresses)) {
      if (networkContracts[network]) {
        // Check for duplicates
        if (networkContracts[network][contractName] && networkContracts[network][contractName] !== address) {
          console.log(`  Warning: Duplicate contract name "${contractName}" with different addresses:`);
          console.log(`    Existing: ${networkContracts[network][contractName]}`);
          console.log(`    New: ${address} (from ${relative(CONTRACTS_DIR, filePath)})`);
          
          // Use the relative file path to create a unique name
          const uniqueName = `${contractName}_${relative(CONTRACTS_DIR, filePath).replace(/[/.]/g, '_').replace(/_sol$/, '')}`;
          networkContracts[network][uniqueName] = address;
          console.log(`    Renamed to: ${uniqueName}`);
        } else {
          networkContracts[network][contractName] = address;
        }
        
        totalAddressesFound++;
        console.log(`  Found ${network}: ${contractName} -> ${address} (${relative(CONTRACTS_DIR, filePath)})`);
      }
    }

    // Add origin chain addresses to appropriate network mappings
    for (const [network, addressData] of Object.entries(originAddresses)) {
      if (originNetworkContracts[network]) {
        // Check for duplicates
        if (originNetworkContracts[network][contractName] && originNetworkContracts[network][contractName].address !== addressData.address) {
          console.log(`  Warning: Duplicate origin contract name "${contractName}" with different addresses:`);
          console.log(`    Existing: ${originNetworkContracts[network][contractName].address} (${originNetworkContracts[network][contractName].originChain})`);
          console.log(`    New: ${addressData.address} (${addressData.originChain}) (from ${relative(CONTRACTS_DIR, filePath)})`);
          
          // Use the relative file path to create a unique name
          const uniqueName = `${contractName}_${relative(CONTRACTS_DIR, filePath).replace(/[/.]/g, '_').replace(/_sol$/, '')}`;
          originNetworkContracts[network][uniqueName] = addressData;
          console.log(`    Renamed to: ${uniqueName}`);
        } else {
          originNetworkContracts[network][contractName] = addressData;
        }
        
        totalOriginAddressesFound++;
        console.log(`  Found ${network} origin (${addressData.originChain}): ${contractName} -> ${addressData.address} (${relative(CONTRACTS_DIR, filePath)})`);
      }
    }
  }

  console.log(`\nTotal addresses found: ${totalAddressesFound}`);
  console.log(`Total origin addresses found: ${totalOriginAddressesFound}`);

  // Generate library files for each network
  console.log('\nGenerating address library files...');
  for (const network of NETWORKS) {
    const networkName = network.charAt(0).toUpperCase() + network.slice(1);
    const fileName = `${networkName}Addresses.sol`;
    const filePath = join(UTILS_DIR, fileName);
    
    const content = generateAddressLibrary(network, networkContracts[network]);
    writeFileSync(filePath, content);
    
    const contractCount = Object.keys(networkContracts[network]).length;
    console.log(`  Generated ${fileName} with ${contractCount} contracts`);
  }

  // Generate origin address library files for each network
  console.log('\nGenerating origin address library files...');
  for (const network of NETWORKS) {
    const networkName = network.charAt(0).toUpperCase() + network.slice(1);
    const fileName = `${networkName}OriginAddresses.sol`;
    const filePath = join(UTILS_DIR, fileName);
    
    const content = generateOriginAddressLibrary(network, originNetworkContracts[network]);
    writeFileSync(filePath, content);
    
    const contractCount = Object.keys(originNetworkContracts[network]).length;
    console.log(`  Generated ${fileName} with ${contractCount} origin contracts`);
  }

  // Generate TypeScript address mapping
  console.log('\nGenerating TypeScript address mapping...');
  
  // Ensure JS utils directory exists
  if (!existsSync(JS_UTILS_DIR)) {
    console.log(`  Creating ${JS_UTILS_DIR} directory...`);
    mkdirSync(JS_UTILS_DIR, { recursive: true });
  }
  
  const tsContent = generateTypeScriptMapping(networkContracts, originNetworkContracts);
  writeFileSync(JS_OUTPUT_PATH, tsContent);
  console.log(`  Generated ${relative(process.cwd(), JS_OUTPUT_PATH)}`);

  console.log('\nAddress utility files generated successfully!');
}

// Run the script
main();


================================================
FILE: scripts/forge-deploy.sh
================================================
#!/usr/bin/env bash
# Re-exec under bash if not already, or if POSIX mode is on
if [ -z "${BASH_VERSION:-}" ]; then exec /usr/bin/env bash "$0" "$@"; fi
if (set -o | grep -q 'posix[[:space:]]*on'); then exec /usr/bin/env bash "$0" "$@"; fi

set -euo pipefail

# Defaults
DEFAULT_RPC_URL="${DEFAULT_RPC_URL:-http://localhost:8545}"
DEFAULT_PRIVATE_KEY="${DEFAULT_PRIVATE_KEY:-0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80}"

if ! command -v forge >/dev/null 2>&1; then
  echo "Error: forge not found in PATH. Install Foundry: https://book.getfoundry.sh/getting-started/installation" >&2
  exit 1
fi

script_dir="$(cd "$(dirname "$0")" && pwd)"
repo_root="$(cd "$script_dir/.." && pwd)"

# Load root .env if present so we can read chain RPCs and deployer keys
if [ -f "$repo_root/.env" ]; then
  set +u
  set -a
  # shellcheck disable=SC1090
  source "$repo_root/.env"
  set +a
  set -u
fi

target=""
rpc_url="$DEFAULT_RPC_URL"
private_key="$DEFAULT_PRIVATE_KEY"
rpc_url_explicit=0
private_key_explicit=0
chain=""

# Collect any extra flags to pass along unchanged
passthrough_args=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    --chain)
      [[ $# -ge 2 ]] || { echo "Error: --chain requires a value (local|tatara|bokuto|katana)" >&2; exit 1; }
      chain="$2"
      shift 2
      ;;
    --rpc-url)
      [[ $# -ge 2 ]] || { echo "Error: --rpc-url requires a value" >&2; exit 1; }
      rpc_url="$2"
      rpc_url_explicit=1
      shift 2
      ;;
    --private-key)
      [[ $# -ge 2 ]] || { echo "Error: --private-key requires a value" >&2; exit 1; }
      private_key="$2"
      private_key_explicit=1
      shift 2
      ;;
    --*)
      # Forward any other flags as-is (value, if present, will be handled in next loop iteration)
      passthrough_args+=("$1")
      shift
      ;;
    *)
      if [[ -z "$target" ]]; then
        target="$1"
      else
        # Forward stray args
        passthrough_args+=("$1")
      fi
      shift
      ;;
  esac
done

if [[ -z "$target" ]]; then
  echo "Usage: scripts/forge-deploy.sh <@script/FILE:Contract | script/FILE:Contract | FILE:Contract> [--rpc-url URL] [--private-key KEY] [--chain local|tatara|bokuto|katana] [extra forge flags]" >&2
  exit 1
fi

# If user specified --chain, map to RPC and deployer key from .env, unless explicitly overridden
if [[ -n "$chain" ]]; then
  # Normalize chain to lowercase/uppercase (portable for macOS bash 3.x)
  chain_lc=$(printf '%s' "$chain" | tr '[:upper:]' '[:lower:]')
  if [[ "$chain_lc" == "local" ]]; then
    # Use built-in defaults for local anvil
    if [[ $rpc_url_explicit -eq 0 ]]; then rpc_url="$DEFAULT_RPC_URL"; fi
    if [[ $private_key_explicit -eq 0 ]]; then private_key="$DEFAULT_PRIVATE_KEY"; fi
    echo "Using chain 'local' RPC: $rpc_url"
    if [[ $private_key_explicit -eq 0 ]]; then echo "Using default local anvil deployer key"; fi
  else
    case "$chain_lc" in
      tatara|bokuto|katana) : ;;
      *) echo "Error: unknown --chain '$chain'. Expected one of: local, tatara, bokuto, katana" >&2; exit 1;;
    esac

    chain_uc=$(printf '%s' "$chain_lc" | tr '[:lower:]' '[:upper:]')
    rpc_var="${chain_uc}_RPC_URL"
    key_var="${chain_uc}_DEPLOYER_KEY"

    chain_rpc="${!rpc_var-}"
    chain_key="${!key_var-}"

    if [[ -z "${chain_rpc:-}" ]]; then
      echo "Error: $rpc_var not set in $repo_root/.env. Please define it (see .env.example for reference)." >&2
      exit 1
    fi

    if [[ $rpc_url_explicit -eq 0 ]]; then
      rpc_url="$chain_rpc"
    fi
    if [[ $private_key_explicit -eq 0 && -n "${chain_key:-}" ]]; then
      private_key="$chain_key"
    fi

    echo "Using chain '$chain_lc' RPC: $rpc_url"
    if [[ $private_key_explicit -eq 0 ]]; then
      if [[ -n "${chain_key:-}" ]]; then
        echo "Using deployer key from \$$key_var"
      else
        echo "Warning: $key_var not set in .env; falling back to default key."
      fi
    fi
  fi
fi

# Normalize target to path relative to forge workspace
if [[ "$target" == @script/* ]]; then
  target="${target#@}"
fi
if [[ "$target" == forge/* ]]; then
  target="${target#forge/}"
fi
if [[ "$target" != script/* ]]; then
  target="script/$target"
fi

# Enter the forge workspace root
cd "$repo_root/forge"

# Avoid duplicating --broadcast if already provided
broadcast_flag="--broadcast"
if [ "${#passthrough_args[@]:-0}" -gt 0 ] 2>/dev/null; then
  for arg in "${passthrough_args[@]}"; do
    if [[ "$arg" == "--broadcast" ]]; then
      broadcast_flag=""
      break
    fi
  done
fi

set -x
forge script "$target" ${broadcast_flag} --rpc-url "$rpc_url" --private-key "$private_key" ${passthrough_args+"${passthrough_args[@]}"}


================================================
FILE: scripts/fork_example.js
================================================
#!/usr/bin/env node

import { existsSync, mkdirSync, readdirSync, statSync, rmSync, copyFileSync, readSync as fsReadSync } from 'node:fs';
import { join } from 'node:path';
import { execSync } from 'node:child_process';

const repoRoot = process.cwd();
const srcDir = join(repoRoot, 'src');
const examplesDir = join(repoRoot, 'examples');
const backupsDir = join(repoRoot, '.fork-backups');

function listExamples() {
  if (!existsSync(examplesDir)) return [];
  return readdirSync(examplesDir).filter(d => {
    try { return statSync(join(examplesDir, d)).isDirectory(); } catch { return false; }
  });
}

function usage(examples) {
  console.log('Usage: bun run fork <example> [--yes] [--no-build] [--list]');
  console.log('\nOptions:');
  console.log('  --yes        Proceed without interactive confirmation');
  console.log('  --no-build   Skip running "bun run build" after forking');
  console.log('  --list       List available examples and exit');
  if (examples.length) {
    console.log('\nAvailable examples:');
    for (const ex of examples) console.log(`  - ${ex}`);
  }
}

function ensureDir(path) {
  try { mkdirSync(path, { recursive: true }); } catch {}
}

function copyDirRecursive(src, dest) {
  ensureDir(dest);
  for (const entry of readdirSync(src)) {
    const srcPath = join(src, entry);
    const destPath = join(dest, entry);
    const st = statSync(srcPath);
    if (st.isDirectory()) {
      copyDirRecursive(srcPath, destPath);
    } else {
      ensureDir(join(destPath, '..'));
      copyFileSync(srcPath, destPath);
    }
  }
}

function clearDirContents(dir) {
  if (!existsSync(dir)) return;
  for (const entry of readdirSync(dir)) {
    const p = join(dir, entry);
    rmSync(p, { recursive: true, force: true });
  }
}

function promptYesNo(msg) {
  if (!process.stdin.isTTY) return false;
  process.stdout.write(msg);
  try {
    const buf = Buffer.alloc(1);
    const n = fsReadSync(0, buf, 0, 1, null);
    const ch = String.fromCharCode(buf[0] ?? 110).toLowerCase();
    return ch === 'y';
  } catch {
    return false;
  }
}

function main() {
  const args = process.argv.slice(2);
  const examples = listExamples();

  if (args.includes('--list')) {
    usage(examples);
    process.exit(0);
  }

  const exIdx = args.findIndex(a => a === '--example');
  const exampleFlag = exIdx >= 0 ? (args[exIdx + 1] || '') : '';
  const exampleArg = exampleFlag || args.find(a => !a.startsWith('-'));
  const yes = args.includes('--yes');
  const noBuild = args.includes('--no-build');

  if (!exampleArg) {
    console.error('Error: missing <example> argument.\n');
    usage(examples);
    process.exit(1);
  }

  const exampleName = exampleArg;
  const exampleDir = join(examplesDir, exampleName);
  if (!existsSync(exampleDir) || !statSync(exampleDir).isDirectory()) {
    console.error(`Error: example "${exampleName}" not found at ${exampleDir}`);
    console.error('\nUse "--list" to see available examples.');
    process.exit(1);
  }


  if (!yes) {
    const ok = promptYesNo(`This will replace contents of ./src with example "${exampleName}". Continue? [y/N]: `);
    if (!ok) {
      console.log('Aborted.');
      process.exit(1);
    }
  }

  const hasSrc = existsSync(srcDir) && statSync(srcDir).isDirectory();
  const stamp = new Date().toISOString().replace(/[:.]/g, '-');
  const backupDir = join(backupsDir, `src-${stamp}`);
  ensureDir(backupsDir);
  if (hasSrc) {
    console.log(`Backing up current src to ${backupDir}`);
    ensureDir(backupDir);
    copyDirRecursive(srcDir, backupDir);
  }

  console.log(`Forking example "${exampleName}" into ./src`);
  ensureDir(srcDir);
  clearDirContents(srcDir);
  copyDirRecursive(exampleDir, srcDir);

  if (!noBuild) {
    console.log('Building app (bun run build)...');
    try {
      execSync('bun run build', { stdio: 'inherit' });
      console.log('âœ… Build complete.');
    } catch {
      console.error('âŒ Build failed.');
      process.exit(1);
    }
  } else {
    console.log('Skipping build (--no-build specified).');
  }

  console.log('\nDone.');
  console.log(`- Example: ${exampleName}`);
  console.log(`- Backup: ${backupDir}`);
  console.log('- Next steps:');
  console.log('  bun run dev    # serves dist/ at http://localhost:8080');
  console.log('  bun run build  # rebuild if you change files');
}

main();


================================================
FILE: scripts/generate_contract_dir.js
================================================
#!/usr/bin/env node

import { existsSync, readdirSync, readFileSync, writeFileSync, statSync, mkdirSync } from 'node:fs';
import { join, basename, dirname } from 'node:path';

// Constants
const CONTRACTS_DIR = join(process.cwd(), 'contracts');
const ABIS_DIR = join(process.cwd(), 'abis');
const ADDRESSES_DIR = join(process.cwd(), 'utils', 'addresses');
const OUTPUT_DIR = join(process.cwd(), 'utils');
const FULL_OUTPUT = join(OUTPUT_DIR, 'contractdir.json');
const SAMPLE_OUTPUT = join(OUTPUT_DIR, 'contractdir_sample.json');
const SCHEMA_OUTPUT = join(OUTPUT_DIR, 'contractdir_schema.json');
const DIVERSE_OUTPUT = join(OUTPUT_DIR, 'contractdir_diverse.json');
const SAMPLE_SIZE = 10; // Number of contracts to include in the sample
const DIVERSE_SIZE = 4; // Number of diverse contracts for LLM analysis

// Network mappings
const NETWORKS = ['tatara', 'katana', 'bokuto'];

// Check that required directories exist
if (!existsSync(CONTRACTS_DIR)) {
  console.error('Error: Contracts directory does not exist');
  process.exit(1);
}

if (!existsSync(ABIS_DIR)) {
  console.error('Error: ABIs directory does not exist. Run "bun run build:abi" first.');
  process.exit(1);
}

if (!existsSync(ADDRESSES_DIR)) {
  console.error('Error: Addresses directory does not exist. Run "bun run build:addressutils" first.');
  process.exit(1);
}

if (!existsSync(OUTPUT_DIR)) {
  mkdirSync(OUTPUT_DIR, { recursive: true });
}

console.log('Generating contract directory files...');

// Define contexts and their theme colors based on tags
const CONTEXTS = {
  "morpho": {
    name: "morpho",
    color: "#6f4ff2", // Purple
    priority: 1
  },
  "yearn": {
    name: "yearn", 
    color: "#0657F9", // Blue
    priority: 2
  },
  "vaultbridge": {
    name: "vaultbridge",
    color: "#f59e0b", // Amber
    priority: 3
  },
  "oracle": {
    name: "oracle",
    color: "#8b5cf6", // Violet
    priority: 4
  },
  "chainlink": {
    name: "chainlink",
    color: "#3b82f6", // Blue
    priority: 5
  },
  "redstone": {
    name: "redstone",
    color: "#ef4444", // Red
    priority: 6
  },
  "opensea": {
    name: "opensea",
    color: "#2081e2", // OpenSea blue
    priority: 7
  },
  "account-abstraction": {
    name: "account-abstraction",
    color: "#ff7a00", // Orange
    priority: 8
  },
  "agglayer": {
    name: "agglayer",
    color: "#8b46ff", // Purple
    priority: 9
  },
  "nft": {
    name: "nft",
    color: "#ec4899", // Pink
    priority: 10
  },
  "erc20": {
    name: "erc20",
    color: "#10b981", // Green
    priority: 11
  },
  "defi": {
    name: "defi",
    color: "#6366f1", // Indigo
    priority: 12
  },
  "utility": {
    name: "utility",
    color: "#00b7c5", // Cyan
    priority: 13
  },
  "bridge": {
    name: "bridge",
    color: "#e20b8c", // Magenta
    priority: 14
  },
  "general": {
    name: "general",
    color: "#6b7280", // Gray
    priority: 999
  }
};

// Load addresses from the new address utility system
function loadAddresses() {
  try {
    const addressMappingFile = join(ADDRESSES_DIR, 'mapping.ts');
    if (!existsSync(addressMappingFile)) {
      console.warn('Warning: Address mapping file not found. Addresses will not be included.');
      return {};
    }

    const mappingContent = readFileSync(addressMappingFile, 'utf8');
    
    // Extract the CONTRACT_ADDRESSES object
    const contractAddressMatch = mappingContent.match(/export const CONTRACT_ADDRESSES = ({[\s\S]*?}) as const;/);
    if (!contractAddressMatch) {
      console.warn('Warning: Could not parse CONTRACT_ADDRESSES from mapping.ts');
      return {};
    }

    // Convert TypeScript object to JSON-parseable format
    let addressDataStr = contractAddressMatch[1];
    
    // Replace TypeScript syntax with JSON syntax
    addressDataStr = addressDataStr
      .replace(/(\w+):/g, '"$1":')  // Add quotes around keys
      .replace(/'/g, '"')          // Replace single quotes with double quotes
      .replace(/,(\s*[}\]])/g, '$1'); // Remove trailing commas

    try {
      const addressData = JSON.parse(addressDataStr);
      console.log(`Loaded addresses for ${Object.keys(addressData).length} contracts`);
      return addressData;
    } catch (parseError) {
      console.warn('Warning: Could not parse address data:', parseError.message);
      return {};
    }
  } catch (error) {
    console.error('Error loading addresses:', error);
    return {};
  }
}

// Load origin addresses from the new address utility system  
function loadOriginAddresses() {
  try {
    const addressMappingFile = join(ADDRESSES_DIR, 'mapping.ts');
    if (!existsSync(addressMappingFile)) {
      return {};
    }

    const mappingContent = readFileSync(addressMappingFile, 'utf8');
    
    // Extract the ORIGIN_CONTRACT_ADDRESSES object
    const originAddressMatch = mappingContent.match(/export const ORIGIN_CONTRACT_ADDRESSES = ({[\s\S]*?}) as const;/);
    if (!originAddressMatch) {
      return {};
    }

    // Convert TypeScript object to JSON-parseable format
    let originDataStr = originAddressMatch[1];
    
    // Replace TypeScript syntax with JSON syntax
    originDataStr = originDataStr
      .replace(/(\w+):/g, '"$1":')  // Add quotes around keys
      .replace(/'/g, '"')          // Replace single quotes with double quotes
      .replace(/,(\s*[}\]])/g, '$1'); // Remove trailing commas

    try {
      const originData = JSON.parse(originDataStr);
      console.log(`Loaded origin addresses for ${Object.keys(originData).length} contracts`);
      return originData;
    } catch (parseError) {
      console.warn('Warning: Could not parse origin address data:', parseError.message);
      return {};
    }
  } catch (error) {
    console.error('Error loading origin addresses:', error);
    return {};
  }
}

// Get all contract files recursively (excluding utils)
function getAllFiles(dir, relativePath = '', fileMap = {}) {
  const files = readdirSync(dir);
  
  for (const file of files) {
    const filePath = join(dir, file);
    const stats = statSync(filePath);
    
    if (stats.isDirectory()) {
      // Skip the utils directory since those are generated files
      if (file === 'utils') {
        console.log(`Skipping generated directory: ${join(relativePath, file)}`);
        continue;
      }
      
      getAllFiles(filePath, join(relativePath, file), fileMap);
    } else if (file.endsWith('.sol')) {
      const key = join(relativePath, file).replace(/\\/g, '/');
      fileMap[key] = {
        path: filePath,
        relativePath: relativePath
      };
    }
  }
  
  return fileMap;
}

// Get all ABI files recursively
function getAllABIs(dir, relativePath = '', abiMap = {}) {
  const files = readdirSync(dir);
  
  for (const file of files) {
    const filePath = join(dir, file);
    const stats = statSync(filePath);
    
    if (stats.isDirectory()) {
      getAllABIs(filePath, join(relativePath, file), abiMap);
    } else if (file.endsWith('.json')) {
      const key = join(relativePath, file).replace(/\\/g, '/');
      abiMap[key] = {
        path: filePath,
        relativePath: relativePath
      };
    }
  }
  
  return abiMap;
}

// Extract function signatures from ABI
function extractFunctionSignatures(abi) {
  const signatures = [];
  
  if (!Array.isArray(abi)) return signatures;
  
  for (const item of abi) {
    if (item.type === 'function') {
      let signature = `${item.name}(${(item.inputs || []).map(input => input.type).join(',')})`;
      let outputTypes = (item.outputs || []).map(output => output.type).join(',');
      let abiSignature = {
        name: item.name,
        signature,
        inputs: item.inputs || [],
        outputs: item.outputs || [],
        stateMutability: item.stateMutability
      };
      
      // Add signature to the list
      signatures.push(abiSignature);
    }
  }
  
  return signatures;
}

// Extract documentation comments, network addresses, and tags from contract file
function extractContractMetadata(content) {
  // Find the main comment block before the interface/contract declaration
  const commentBlockRegex = /\/\*\*([\s\S]*?)\*\/\s*(?:interface|contract)\s+\w+/;
  const commentMatch = content.match(commentBlockRegex);
  
  if (!commentMatch) return null;
  
  const commentBlock = commentMatch[1];
  
  // Extract various tags
  const titleMatches = commentBlock.match(/@title\s+(.*?)(?=\s*\*\s*@|\s*\*\/)/gs) || [];
  const noticeMatches = commentBlock.match(/@notice\s+(.*?)(?=\s*\*\s*@|\s*\*\/)/gs) || [];
  const devMatches = commentBlock.match(/@dev\s+(.*?)(?=\s*\*\s*@|\s*\*\/)/gs) || [];
  
  // Extract network addresses (new format)
  const networkAddresses = {};
  const originAddresses = {};
  
  for (const network of NETWORKS) {
    // Regular network addresses: @custom:tatara 0x123...
    const networkRegex = new RegExp(`@custom:${network}\\s+(0x[a-fA-F0-9]{40})`, 'gi');
    const networkMatch = networkRegex.exec(commentBlock);
    if (networkMatch && networkMatch[1]) {
      networkAddresses[network] = networkMatch[1];
    }
    
    // Origin chain addresses: @custom:tatara ethereum:0x123...
    const originRegex = new RegExp(`@custom:${network}\\s+(ethereum|sepolia):(0x[a-fA-F0-9]{40})`, 'gi');
    const originMatch = originRegex.exec(commentBlock);
    if (originMatch && originMatch[2]) {
      originAddresses[network] = {
        originChain: originMatch[1],
        address: originMatch[2]
      };
    }
  }
  
  // Extract tags
  const tagsMatches = commentBlock.match(/@custom:tags\s+([^\n\r]*)/g) || [];
  const tags = tagsMatches.length > 0 
    ? tagsMatches[0].replace(/@custom:tags\s+/g, '').trim().split(',').map(tag => tag.trim())
    : [];
  
  // Clean up the extracted comments
  const titles = titleMatches.map(title => 
    title.replace(/@title\s+/g, '').replace(/\s*\*\s*/g, ' ').trim()
  );
  
  const notices = noticeMatches.map(notice => 
    notice.replace(/@notice\s+/g, '').replace(/\s*\*\s*/g, ' ').trim()
  );
  
  const devs = devMatches.map(dev => 
    dev.replace(/@dev\s+/g, '').replace(/\s*\*\s*/g, ' ').trim()
  );
  
  // Combine all information in a structured way
  const metadata = {
    title: titles.length > 0 ? titles[0] : null,
    notice: notices.length > 0 ? notices.join(' ') : null,
    dev: devs.length > 0 ? devs.join(' ') : null,
    tags: tags,
    networkAddresses: networkAddresses,
    originAddresses: originAddresses,
    full: ''
  };
  
  // Build a full text description
  let fullText = '';
  
  if (metadata.title) {
    fullText += metadata.title;
  }
  
  if (metadata.notice) {
    if (fullText) fullText += ': ';
    fullText += metadata.notice;
  }
  
  if (metadata.dev) {
    if (fullText) fullText += ' ';
    fullText += '(' + metadata.dev + ')';
  }
  
  metadata.full = fullText.trim() || null;
  
  return metadata;
}

// Determine the context for a contract based on tags (primary) and fallback to name/path matching
function determineContext(name, path, relativePath, tags = [], description) {
  // First priority: use tags to determine context
  if (tags && tags.length > 0) {
    // Find the highest priority context from tags
    let bestContext = null;
    let bestPriority = 999;
    
    for (const tag of tags) {
      const tagLower = tag.toLowerCase();
      
      // Check if this tag matches any context
      for (const [contextKey, contextData] of Object.entries(CONTEXTS)) {
        if (tagLower === contextKey || tagLower.includes(contextKey)) {
          if (contextData.priority < bestPriority) {
            bestContext = contextData;
            bestPriority = contextData.priority;
          }
        }
      }
      
      // Special mappings for common tag variations
      if (tagLower === 'erc4337') {
        if (CONTEXTS["account-abstraction"].priority < bestPriority) {
          bestContext = CONTEXTS["account-abstraction"];
          bestPriority = CONTEXTS["account-abstraction"].priority;
        }
      }
      
      if (tagLower === 'token' && !bestContext) {
        if (CONTEXTS["erc20"].priority < bestPriority) {
          bestContext = CONTEXTS["erc20"];
          bestPriority = CONTEXTS["erc20"].priority;
        }
      }
    }
    
    if (bestContext) {
      return bestContext;
    }
  }
  
  // Fallback: determine context based on name, path, etc.
  const nameLower = name.toLowerCase();
  const pathLower = path.toLowerCase();
  const relativeLower = relativePath ? relativePath.toLowerCase() : '';
  const desc = description ? description.toLowerCase() : '';
  
  // Check against each context
  for (const [contextKey, contextData] of Object.entries(CONTEXTS)) {
    if (contextKey === 'general') continue; // Skip general for fallback matching
    
    const contextLower = contextKey.toLowerCase();
    
    if (
      nameLower.includes(contextLower) || 
      pathLower.includes(contextLower) || 
      relativeLower.includes(contextLower) ||
      desc.includes(contextLower)
    ) {
      return contextData;
    }
  }
  
  // Special cases for common patterns not captured by tags
  if (nameLower.includes('erc4337') || pathLower.includes('aav0') || relativeLower.includes('aav0')) {
    return CONTEXTS["account-abstraction"];
  }
  
  if (nameLower.includes('seaport') || nameLower.includes('conduit') || desc.includes('opensea')) {
    return CONTEXTS["opensea"];
  }
  
  if (nameLower.includes('create2') || nameLower.includes('createx') || nameLower.includes('deploy')) {
    return CONTEXTS["utility"];
  }
  
  if (nameLower.includes('multicall') || nameLower.includes('permit2') || nameLower.includes('bundler')) {
    return CONTEXTS["utility"];
  }
  
  if (nameLower.includes('bridge') || nameLower.includes('sovereign') || nameLower.includes('l2')) {
    return CONTEXTS["bridge"];
  }
  
  // Default context for anything else
  return CONTEXTS["general"];
}

// Generate the contract directory
function generateContractDirectory() {
  const addresses = loadAddresses();
  const originAddresses = loadOriginAddresses();
  const contractFiles = getAllFiles(CONTRACTS_DIR);
  const abiFiles = getAllABIs(ABIS_DIR);
  
  const contractDir = [];
  
  // Process each contract file
  for (const [key, contractInfo] of Object.entries(contractFiles)) {
    const fileName = basename(key, '.sol');
    const abiKey = join(contractInfo.relativePath, `${fileName}.json`).replace(/\\/g, '/');
    
    // Get the contract content
    const contractContent = readFileSync(contractInfo.path, 'utf8');
    
    // Extract contract/interface name - improved regex to match actual declarations not comments
    const interfaceMatch = contractContent.match(/(?:^|\n)\s*interface\s+(\w+)/);
    const contractMatch = contractContent.match(/(?:^|\n)\s*contract\s+(\w+)/);
    const contractName = interfaceMatch ? interfaceMatch[1] : (contractMatch ? contractMatch[1] : fileName);
    
    // Extract contract metadata (description, tags, addresses)
    const metadata = extractContractMetadata(contractContent);
    
    // Try to find matching ABI
    let abi = null;
    let functionSignatures = [];
    if (abiFiles[abiKey]) {
      try {
        abi = JSON.parse(readFileSync(abiFiles[abiKey].path, 'utf8'));
        functionSignatures = extractFunctionSignatures(abi);
      } catch (err) {
        console.warn(`Warning: Could not parse ABI for ${abiKey}`);
      }
    }
    
    // Get addresses for this contract
    let contractAddresses = {};
    let contractOriginAddresses = {};
    
    // Try to match by name (remove leading 'I' if present for interfaces)
    let addressMatchName = contractName;
    if (addressMatchName.startsWith('I')) {
      addressMatchName = addressMatchName.substring(1);
    }
    
    // Look up in the address utilities
    if (addresses[contractName] || addresses[addressMatchName]) {
      contractAddresses = addresses[contractName] || addresses[addressMatchName];
      console.log(`Found addresses for ${contractName}: ${JSON.stringify(contractAddresses)}`);
    }
    
    // Look up origin addresses
    if (originAddresses[contractName] || originAddresses[addressMatchName]) {
      contractOriginAddresses = originAddresses[contractName] || originAddresses[addressMatchName];
      console.log(`Found origin addresses for ${contractName}: ${JSON.stringify(contractOriginAddresses)}`);
    }
    
    // If we didn't find addresses in utilities but found them in doccomments, use those
    if (Object.keys(contractAddresses).length === 0 && metadata && Object.keys(metadata.networkAddresses).length > 0) {
      contractAddresses = metadata.networkAddresses;
      console.log(`Using doccomment addresses for ${contractName}: ${JSON.stringify(contractAddresses)}`);
    }
    
    if (Object.keys(contractOriginAddresses).length === 0 && metadata && Object.keys(metadata.originAddresses).length > 0) {
      contractOriginAddresses = metadata.originAddresses;
      console.log(`Using doccomment origin addresses for ${contractName}: ${JSON.stringify(contractOriginAddresses)}`);
    }
    
    // Determine context using tags as primary method
    const context = determineContext(
      contractName, 
      key, 
      contractInfo.relativePath, 
      metadata ? metadata.tags : [], 
      metadata ? metadata.full : null
    );
    
    // Create contract entry with enhanced structure
    const contract = {
      name: contractName,
      path: key,
      relativePath: contractInfo.relativePath,
      description: metadata ? metadata.full : null,
      metadata: {
        title: metadata ? metadata.title : null,
        notice: metadata ? metadata.notice : null,
        dev: metadata ? metadata.dev : null,
        tags: metadata ? metadata.tags : []
      },
      context: context.name,
      theme: context.color,
      addresses: contractAddresses,
      originAddresses: contractOriginAddresses,
      abi,
      functionSignatures,
      // Add some computed fields for easier filtering
      hasAddresses: Object.keys(contractAddresses).length > 0,
      hasOriginAddresses: Object.keys(contractOriginAddresses).length > 0,
      hasAbi: abi !== null,
      functionCount: functionSignatures.length
    };
    
    contractDir.push(contract);
  }
  
  // Sort contracts by context priority, then by name
  contractDir.sort((a, b) => {
    const contextA = CONTEXTS[a.context] || CONTEXTS["general"];
    const contextB = CONTEXTS[b.context] || CONTEXTS["general"];
    
    if (contextA.priority !== contextB.priority) {
      return contextA.priority - contextB.priority;
    }
    
    return a.name.localeCompare(b.name);
  });
  
  return contractDir;
}

// Generate schema file
function generateSchema() {
  return {
    version: "2.0",
    description: "Katana Contract Directory Schema",
    generatedAt: new Date().toISOString(),
    networks: NETWORKS,
    contexts: Object.keys(CONTEXTS),
    contractStructure: {
      name: "string - Contract or interface name",
      path: "string - Relative path from contracts/ directory", 
      relativePath: "string - Parent directory path",
      description: "string|null - Combined title, notice, and dev comments",
      metadata: {
        title: "string|null - @title doccomment",
        notice: "string|null - @notice doccomment", 
        dev: "string|null - @dev doccomment",
        tags: "string[] - @custom:tags doccomment"
      },
      context: "string - Primary context/category based on tags",
      theme: "string - Hex color for UI theming",
      addresses: "object - Network addresses {tatara?, katana?, bokuto?}",
      originAddresses: "object - Origin chain addresses for cross-chain operations", 
      abi: "array|null - Contract ABI if available",
      functionSignatures: "array - Parsed function signatures from ABI",
      hasAddresses: "boolean - Whether contract has any network addresses",
      hasOriginAddresses: "boolean - Whether contract has origin addresses",
      hasAbi: "boolean - Whether ABI is available",
      functionCount: "number - Number of functions in ABI"
    }
  };
}

// Generate diverse sample for LLM analysis
function generateDiverseSample(contractDir) {
  const diverseContracts = [];
  const usedContexts = new Set();
  
  // Try to get one contract from each major context
  const priorityContexts = ['morpho', 'vaultbridge', 'oracle', 'erc20', 'account-abstraction', 'nft', 'utility'];
  
  for (const targetContext of priorityContexts) {
    const contractInContext = contractDir.find(c => 
      c.context === targetContext && 
      !usedContexts.has(c.context) &&
      c.hasAbi && 
      c.functionCount > 0
    );
    
    if (contractInContext) {
      diverseContracts.push(contractInContext);
      usedContexts.add(contractInContext.context);
      
      if (diverseContracts.length >= DIVERSE_SIZE) break;
    }
  }
  
  // Fill remaining slots with any interesting contracts
  while (diverseContracts.length < DIVERSE_SIZE) {
    const remaining = contractDir.find(c => 
      !diverseContracts.includes(c) &&
      c.hasAbi && 
      c.functionCount > 2
    );
    
    if (!remaining) break;
    diverseContracts.push(remaining);
  }
  
  return diverseContracts;
}

// Main execution
console.log('Generating contract directory...');
const contractDir = generateContractDirectory();

// Write full directory
writeFileSync(FULL_OUTPUT, JSON.stringify(contractDir, null, 2));
console.log(`âœ… Full contract directory written to ${FULL_OUTPUT}`);

// Write sample directory (first SAMPLE_SIZE entries with good coverage)
const sampleContracts = contractDir.filter(c => c.hasAbi).slice(0, SAMPLE_SIZE);
writeFileSync(SAMPLE_OUTPUT, JSON.stringify(sampleContracts, null, 2));
console.log(`âœ… Sample contract directory written to ${SAMPLE_OUTPUT}`);

// Write schema file
const schema = generateSchema();
writeFileSync(SCHEMA_OUTPUT, JSON.stringify(schema, null, 2));
console.log(`âœ… Schema written to ${SCHEMA_OUTPUT}`);

// Write diverse sample for LLM analysis
const diverseContracts = generateDiverseSample(contractDir);
writeFileSync(DIVERSE_OUTPUT, JSON.stringify(diverseContracts, null, 2));
console.log(`âœ… Diverse sample written to ${DIVERSE_OUTPUT}`);

// Print detailed statistics
console.log('\nğŸ“Š Directory Statistics:');
console.log(`  - Total contracts: ${contractDir.length}`);
console.log(`  - Contracts with ABIs: ${contractDir.filter(c => c.hasAbi).length}`);
console.log(`  - Contracts with addresses: ${contractDir.filter(c => c.hasAddresses).length}`);
console.log(`  - Contracts with origin addresses: ${contractDir.filter(c => c.hasOriginAddresses).length}`);
console.log(`  - Total function signatures: ${contractDir.reduce((sum, c) => sum + c.functionCount, 0)}`);

// Context breakdown
console.log('\nğŸ“‚ Context Breakdown:');
const contextStats = {};
contractDir.forEach(c => {
  contextStats[c.context] = (contextStats[c.context] || 0) + 1;
});

Object.entries(contextStats)
  .sort(([,a], [,b]) => b - a)
  .forEach(([context, count]) => {
    console.log(`  - ${context}: ${count} contracts`);
  });

// Network coverage
console.log('\nğŸŒ Network Coverage:');
NETWORKS.forEach(network => {
  const withAddress = contractDir.filter(c => c.addresses[network]).length;
  const withOrigin = contractDir.filter(c => c.originAddresses[network]).length;
  console.log(`  - ${network}: ${withAddress} regular, ${withOrigin} origin addresses`);
});

console.log('\nğŸ‰ Generation complete!'); 


================================================
FILE: scripts/generate_mintlify_context.js
================================================
#!/usr/bin/env node

import { existsSync, mkdirSync, rmSync, writeFileSync, readFileSync } from 'node:fs';
import { dirname, join, basename } from 'node:path';
import { execSync } from 'node:child_process';

const ROOT_DIR = process.cwd();
const CONTRACT_DIR_JSON = join(ROOT_DIR, 'utils', 'contractdir.json');
const OUTPUT_DIR = join(ROOT_DIR, 'mintlify_context');
const GITIGNORE_FILE = join(ROOT_DIR, '.gitignore');
const NAV_TAB_NAME = 'Contracts';
const NAV_BASE_PATH = 'mintlify_context';

function ensureGitignoreHasMintlify() {
  try {
    const entry = 'mintlify_context/';
    if (!existsSync(GITIGNORE_FILE)) {
      writeFileSync(GITIGNORE_FILE, `${entry}\n`);
      return;
    }
    const current = readFileSync(GITIGNORE_FILE, 'utf8');
    if (!current.split(/\r?\n/).some(line => line.trim() === entry)) {
      const content = current.endsWith('\n') ? `${current}${entry}\n` : `${current}\n${entry}\n`;
      writeFileSync(GITIGNORE_FILE, content);
    }
  } catch (err) {
    console.warn('Warning: could not update .gitignore:', err.message);
  }
}

function recreateOutputDir() {
  if (existsSync(OUTPUT_DIR)) {
    rmSync(OUTPUT_DIR, { recursive: true, force: true });
  }
  mkdirSync(OUTPUT_DIR, { recursive: true });
}

function loadContractDirectory() {
  if (!existsSync(CONTRACT_DIR_JSON)) {
    console.log('contractdir.json not found. Generating it first...');
    try {
      execSync('bun scripts/generate_contract_dir.js', { stdio: 'inherit' });
    } catch (err) {
      console.error('Error running generate_contract_dir:', err.message);
      process.exit(1);
    }
  }

  try {
    const data = JSON.parse(readFileSync(CONTRACT_DIR_JSON, 'utf8'));
    if (!Array.isArray(data)) {
      throw new Error('contractdir.json did not contain an array');
    }
    return data;
  } catch (err) {
    console.error('Failed to read utils/contractdir.json:', err.message);
    process.exit(1);
  }
}

function sanitizeFileName(name) {
  return name.replace(/[^a-zA-Z0-9_.-]/g, '_');
}

function ensureDirForFile(filePath) {
  const dir = dirname(filePath);
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }
}

function toFrontmatterValue(value) {
  if (value == null) return '';
  const str = String(value);
  // Escape double quotes in YAML string values
  return str.replace(/"/g, '\\"');
}

function generateMarkdown(contract) {
  const title = contract.name || 'Unknown Contract';
  const description = contract.description || `Documentation for ${contract.name} at ${contract.path}`;
  const tags = (contract.metadata && Array.isArray(contract.metadata.tags)) ? contract.metadata.tags : [];
  const addresses = contract.addresses || {};
  const originAddresses = contract.originAddresses || {};
  const abiJson = contract.abi ? JSON.stringify(contract.abi, null, 2) : null;
  const functionSigs = Array.isArray(contract.functionSignatures) ? contract.functionSignatures : [];

  const lines = [];
  lines.push('---');
  lines.push(`title: "${toFrontmatterValue(title)}"`);
  lines.push(`description: "${toFrontmatterValue(description)}"`);
  lines.push('---');
  lines.push('');

  lines.push('### Overview');
  lines.push('');
  lines.push(`- **name**: ${title}`);
  lines.push(`- **path**: \`${contract.path}\``);
  lines.push(`- **context**: ${contract.context || 'general'}`);
  if (tags.length > 0) {
    lines.push(`- **tags**: ${tags.join(', ')}`);
  }
  if (contract.metadata && (contract.metadata.title || contract.metadata.notice || contract.metadata.dev)) {
    if (contract.metadata.title) lines.push(`- **title**: ${contract.metadata.title}`);
    if (contract.metadata.notice) lines.push(`- **notice**: ${contract.metadata.notice}`);
    if (contract.metadata.dev) lines.push(`- **dev**: ${contract.metadata.dev}`);
  }
  lines.push('');

  if (Object.keys(addresses).length > 0) {
    lines.push('### Addresses');
    lines.push('');
    for (const [network, addr] of Object.entries(addresses)) {
      if (!addr) continue;
      const href = networkAddressExplorerUrl(network, String(addr));
      const linked = href ? `[\`${addr}\`](${href})` : `\`${addr}\``;
      lines.push(`- **${network}**: ${linked}`);
    }
    lines.push('');
  }

  if (Object.keys(originAddresses).length > 0) {
    lines.push('### Origin addresses');
    lines.push('');
    for (const [network, entry] of Object.entries(originAddresses)) {
      if (!entry) continue;
      const { originChain, address } = normalizeOriginAddress(network, entry);
      const label = `${originChain} (${network})`;
      const href = originAddressExplorerUrl(originChain, address);
      const linked = href ? `[\`${address}\`](${href})` : `\`${address}\``;
      lines.push(`- **${network}**: ${label} â€“ ${linked}`);
    }
    lines.push('');
  }

  if (functionSigs.length > 0) {
    lines.push('### Function signatures');
    lines.push('');
    lines.push('```');
    for (const sig of functionSigs) {
      const signature = typeof sig === 'string' ? sig : sig.signature || '';
      if (signature) lines.push(signature);
    }
    lines.push('```');
    lines.push('');
  }

  if (abiJson) {
    lines.push('### ABI');
    lines.push('');
    lines.push('```json');
    lines.push(abiJson);
    lines.push('```');
    lines.push('');
  }

  return lines.join('\n');
}

function networkAddressExplorerUrl(network, address) {
  try {
    const lower = String(network).toLowerCase();
    if (lower === 'bokuto') return `https://explorer-bokuto.katanarpc.com/address/${address}`;
    if (lower === 'katana') return `https://katanascan.com/address/${address}`;
    return null;
  } catch {
    return null;
  }
}

function originAddressExplorerUrl(originChain, address) {
  const chain = String(originChain).toLowerCase();
  if (chain === 'ethereum') return `https://etherscan.io/address/${address}`;
  if (chain === 'sepolia') return `https://sepolia.etherscan.io/address/${address}`;
  return null;
}

function normalizeOriginAddress(network, entry) {
  // Returns { originChain, address }
  if (entry && typeof entry === 'object') {
    const originChain = entry.originChain || inferOriginChainFromNetwork(network);
    const address = entry.address || '';
    return { originChain, address };
  }
  // entry is a string from ORIGIN_CONTRACT_ADDRESSES
  return { originChain: inferOriginChainFromNetwork(network), address: String(entry) };
}

function inferOriginChainFromNetwork(network) {
  const lower = String(network).toLowerCase();
  if (lower === 'katana') return 'ethereum';
  if (lower === 'bokuto') return 'sepolia';
  return 'ethereum';
}

function filePathForContract(contract) {
  // Mirror the contracts directory structure to avoid name collisions
  // Example: mintlify_context/contracts/vb/IMigrationManager.md
  const relativeDir = contract.relativePath ? contract.relativePath : '';
  const baseName = sanitizeFileName(`${contract.name}.md`);
  const fullDir = join(OUTPUT_DIR, relativeDir);
  return join(fullDir, baseName);
}

function main() {
  console.log('Generating Mintlify context markdown...');
  ensureGitignoreHasMintlify();
  recreateOutputDir();

  const contractDir = loadContractDirectory();
  let count = 0;
  const writtenFiles = [];

  for (const contract of contractDir) {
    const outPath = filePathForContract(contract);
    ensureDirForFile(outPath);
    const markdown = generateMarkdown(contract);
    writeFileSync(outPath, markdown, 'utf8');
    count += 1;
    // Track relative path from OUTPUT_DIR for navigation building
    const relativeFromOutput = outPath.replace(OUTPUT_DIR + '/', '');
    writtenFiles.push(relativeFromOutput);
  }

  // Add a simple index file for convenience
  try {
    const indexLines = [];
    indexLines.push('---');
    indexLines.push('title: "Contract Index"');
    indexLines.push('description: "Index of generated contract docs"');
    indexLines.push('---');
    indexLines.push('');
    indexLines.push('Generated contract documentation for Mintlify RAG.');
    writeFileSync(join(OUTPUT_DIR, 'index.md'), indexLines.join('\n'), 'utf8');
    writtenFiles.push('index.md');
  } catch {}

  // Build and write Mintlify navigation tab JSON
  try {
    const tab = buildMintlifyTabObject(writtenFiles);
    writeFileSync(join(OUTPUT_DIR, 'docs_tab.json'), JSON.stringify(tab, null, 2), 'utf8');
  } catch (err) {
    console.warn('Warning: failed to build docs_tab.json:', err?.message || err);
  }

  console.log(`âœ… Wrote ${count} markdown files to ${OUTPUT_DIR}`);
}

main();

function buildMintlifyTabObject(files) {
  // files: relative paths under OUTPUT_DIR, e.g. 'vb/tokens/IvbETH.md'
  const tree = {};

  function addFile(relPath) {
    if (!relPath || !relPath.endsWith('.md')) return;
    const parts = relPath.split('/');
    let node = tree;
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      const isFile = i === parts.length - 1;
      if (isFile) {
        node.__files = node.__files || [];
        node.__files.push(part);
      } else {
        node[part] = node[part] || {};
        node = node[part];
      }
    }
  }

  for (const f of files) addFile(f);

  // Helper to convert a directory node into a group object
  function buildGroup(dirName, node, parentSegments) {
    const pages = [];
    const groups = [];

    const filesHere = (node.__files || []).filter(name => name.toLowerCase() !== 'index.md');
    filesHere.sort((a, b) => a.localeCompare(b));
    for (const file of filesHere) {
      const slug = file.replace(/\.md$/i, '');
      const fullPath = [NAV_BASE_PATH, ...parentSegments, dirName, slug].filter(Boolean).join('/');
      pages.push(fullPath);
    }

    for (const [key, child] of Object.entries(node)) {
      if (key === '__files') continue;
      groups.push(buildGroup(key, child, [...parentSegments, dirName]));
    }

    const groupObj = { group: dirName };
    if (pages.length > 0) groupObj.pages = pages;
    if (groups.length > 0) groupObj.groups = groups;
    return groupObj;
  }

  // Build top-level pages for files at root (excluding index.md)
  const rootPages = [];
  const rootFiles = (tree.__files || []).filter(name => name.toLowerCase() !== 'index.md');
  rootFiles.sort((a, b) => a.localeCompare(b));
  for (const file of rootFiles) {
    const slug = file.replace(/\.md$/i, '');
    rootPages.push([NAV_BASE_PATH, slug].join('/'));
  }

  // Build top-level groups from top-level directories
  const topGroups = [];
  for (const [key, child] of Object.entries(tree)) {
    if (key === '__files') continue;
    topGroups.push(buildGroup(key, child, []));
  }

  const tab = { tab: NAV_TAB_NAME };

  // Include index page and other root pages at the tab level
  const tabPages = [];
  if ((tree.__files || []).includes('index.md')) tabPages.push(`${NAV_BASE_PATH}/index`);
  if (tabPages.length > 0) tab.pages = tabPages;

  // Put root-level pages (without a folder) into a Utilities group so they show up in the menu
  if (rootPages.length > 0) {
    topGroups.unshift({ group: 'utilities', pages: rootPages });
  }

  if (topGroups.length > 0) tab.groups = topGroups;
  return tab;
}




================================================
FILE: scripts/start_anvil.sh
================================================
#!/bin/bash

# Check if chain parameter is provided
if [ -z "$1" ]; then
  echo "âŒ Error: Please specify a chain to fork"
  echo "Usage: $0 [tatara|bokuto|katana]"
  echo "Example: $0 tatara"
  exit 1
fi

CHAIN=$1

# Set chain-specific variables
case $CHAIN in
  "tatara")
    CHAIN_ID=129399
    RPC_VAR="TATARA_RPC_URL"
    ;;
  "bokuto")
    CHAIN_ID=737373
    RPC_VAR="BOKUTO_RPC_URL"
    ;;
  "katana")
    CHAIN_ID=747474
    RPC_VAR="KATANA_RPC_URL"
    ;;
  *)
    echo "âŒ Error: Invalid chain '$CHAIN'"
    echo "Supported chains: tatara, bokuto, katana"
    exit 1
    ;;
esac

# Get RPC URL from .env file
RPC_URL=$(grep "^$RPC_VAR=" $(pwd)/.env 2>/dev/null | cut -d '=' -f2)

if [ -z "$RPC_URL" ]; then
  echo "âŒ Error: $RPC_VAR environment variable is not set"
  echo "Please set it in your .env file"
  echo "Example: $RPC_VAR=https://your-rpc-endpoint.com"
  exit 1
fi

echo "âš¡ Starting local $CHAIN fork with Anvil..."
echo "Chain ID: $CHAIN_ID"
echo "RPC URL: $RPC_URL"

# Start anvil with the specified chain fork
anvil \
  --fork-url "$RPC_URL" \
  --chain-id $CHAIN_ID \
  --port 8545 \
  --block-time 12

# This will keep running until Ctrl+C is pressed 


================================================
FILE: scripts/verify_anvil.js
================================================
#!/usr/bin/env node

import { parseAbi, formatEther, formatUnits, createPublicClient, http } from 'viem';
import { addresses, CHAIN_IDS } from '../utils/addresses/index.js';

// Configuration
const PORT = 8545;
const LOCAL_RPC_URL = `http://localhost:${PORT}`;

// Chain information
const CHAIN_INFO = {
  [CHAIN_IDS.TATARA]: { name: 'Tatara', symbol: 'ETH' },
  [CHAIN_IDS.KATANA]: { name: 'Katana', symbol: 'ETH' },
  [CHAIN_IDS.BOKUTO]: { name: 'Bokuto', symbol: 'ETH' }
};

// ABIs for the contracts we want to interact with
const ERC20_ABI = parseAbi([
  'function name() view returns (string)',
  'function symbol() view returns (string)',
  'function decimals() view returns (uint8)',
  'function totalSupply() view returns (uint256)',
  'function balanceOf(address) view returns (uint256)'
]);

const MORPHO_BLUE_ABI = parseAbi([
  'function owner() view returns (address)',
  'function feeRecipient() view returns (address)',
  'function isLltvEnabled(uint256 lltv) view returns (bool)'
]);

// Verify contracts by connecting to the fork
async function verifyContracts() {
  console.log('\nğŸ“‹ Verifying contracts on the fork:');
  
  try {
    // Create a viem client connected to Anvil
    const client = createPublicClient({
      transport: http(LOCAL_RPC_URL),
    });

    // Wait for anvil to be fully ready 
    let retries = 10;
    while (retries > 0) {
      try {
        // Check if we can connect
        await client.getChainId();
        break;
      } catch (error) {
        console.log(`Waiting for Anvil to be ready... (${retries} retries left)`);
        await new Promise(resolve => setTimeout(resolve, 1000));
        retries--;
        
        if (retries === 0) {
          throw new Error("Timed out waiting for Anvil to be ready");
        }
      }
    }

    // Detect which chain is running and set context
    const chainId = await client.getChainId();
    const chainInfo = CHAIN_INFO[chainId];
    
    if (!chainInfo) {
      const validChainIds = Object.keys(CHAIN_INFO).join(', ');
      throw new Error(`Unknown chain ID ${chainId}. Expected one of: ${validChainIds}`);
    }
    
    console.log(`âœ… Chain ID verified: ${chainId} (${chainInfo.name})`);
    
    // Set the address context for this chain
    addresses.setChain(chainId);

    // Get available contracts for this chain
    const availableContracts = addresses.getAllContracts();
    console.log(`\nğŸ“‹ Found ${availableContracts.length} contracts available on ${chainInfo.name}`);
    
    // Test some key contracts if available
    const contractsToTest = ['AUSD', 'WETH', 'MorphoBlue'];
    let testedCount = 0;
    
    for (const contractName of contractsToTest) {
      try {
        if (addresses.hasContract(contractName)) {
          const contractAddress = addresses.getAddress(contractName);
          console.log(`\nğŸª™ Checking ${contractName} contract...`);
          console.log(`Address: ${contractAddress}`);
          
          // Test basic ERC20 functions
          try {
            const name = await client.readContract({
              address: contractAddress,
              abi: ERC20_ABI,
              functionName: 'name'
            });
            
            const symbol = await client.readContract({
              address: contractAddress,
              abi: ERC20_ABI,
              functionName: 'symbol'
            });
            
            const decimals = await client.readContract({
              address: contractAddress,
              abi: ERC20_ABI,
              functionName: 'decimals'
            });
            
            const totalSupply = await client.readContract({
              address: contractAddress,
              abi: ERC20_ABI,
              functionName: 'totalSupply'
            });
            
            console.log(`Name: ${name}`);
            console.log(`Symbol: ${symbol}`);
            console.log(`Decimals: ${decimals}`);
            console.log(`Total Supply: ${formatUnits(totalSupply, decimals)} ${symbol}`);
            
            testedCount++;
          } catch (contractError) {
            console.log(`âš ï¸  Contract ${contractName} exists but couldn't read ERC20 data (might not be an ERC20 token)`);
            testedCount++;
          }
        } else {
          console.log(`âš ï¸  ${contractName} not available on ${chainInfo.name}`);
        }
      } catch (error) {
        console.log(`âŒ Error testing ${contractName}:`, error.message);
      }
    }
    
    console.log(`\nâœ… Contract verification successful! Tested ${testedCount} contracts.`);
    
    // Print connection information
    console.log(`\nYour ${chainInfo.name} fork is ready for use!`);
    console.log('\nConnect MetaMask or other wallets to this RPC endpoint:');
    console.log(`- Network Name: ${chainInfo.name} Local Fork`);
    console.log(`- RPC URL: http://localhost:${PORT}`);
    console.log(`- Chain ID: ${chainId}`);
    console.log(`- Currency Symbol: ${chainInfo.symbol}`);
    
    return { success: true, chainInfo, testedCount, availableContracts: availableContracts.length };
  } catch (error) {
    console.error('âŒ Error verifying contracts:', error);
    return false;
  }
}

// Main function
async function main() {
  console.log(`ğŸ” Verifying Anvil fork at: ${LOCAL_RPC_URL}`);
  
  // Verify the contracts
  const result = await verifyContracts();
  
  if (result && result.success) {
    console.log("\nYou can leave the Anvil process running for as long as you need it.");
    console.log("Press Ctrl+C in the Anvil terminal to stop the server when done.");
    console.log(`\nğŸ“Š Summary: ${result.testedCount} contracts tested, ${result.availableContracts} total available on ${result.chainInfo.name}`);
  } else {
    console.error("\nâŒ Failed to verify Anvil fork.");
    console.error("Make sure Anvil is running with the correct parameters:");
    console.error("Examples:");
    console.error("  bun run start:anvil tatara");
    console.error("  bun run start:anvil katana");
    console.error("  bun run start:anvil bokuto");
    process.exit(1);
  }
}

// Only run if executed directly
if (process.argv[1] === import.meta.url.substring(7)) {
  main().catch(error => {
    console.error('Fatal error:', error);
    process.exit(1);
  });
}

export { verifyContracts }; 


================================================
FILE: src/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Katana Demo app</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="container">
    <header>
      <h1>Katana Demo app</h1>
      <div class="network-status">
        <span id="network-indicator"></span>
        <span id="network-name">Connecting...</span>
      </div>
    </header>

    <main>
      <section id="wallet-section">
        <h2>Wallet Connection</h2>
        <div class="card">
          <div id="wallet-status">Not connected</div>
          <button id="connect-wallet" class="primary-button">Connect Wallet</button>
        </div>
      </section>

      <section id="contracts-section">
        <h2>Chain Contracts</h2>
        
        <!-- AUSD Token -->
        <div class="card">
          <h3>AUSD Token</h3>
          <div class="contract-address" id="ausd-address">
            <span>Address:</span>
            <code>Loading...</code>
          </div>
          <div class="contract-data" id="ausd-data">
            <div class="spinner"></div>
            <p>Loading data...</p>
          </div>
        </div>

        <!-- bvbEth Token -->
        <div class="card">
          <h3>bvbEth Token (Bridged Vault Bridge ETH)</h3>
          <div class="contract-address" id="weth-address">
            <span>Address:</span>
            <code>Loading...</code>
          </div>
          <div class="contract-data" id="weth-data">
            <div class="spinner"></div>
            <p>Loading data...</p>
          </div>
        </div>

        <!-- MorphoBlue -->
        <div class="card">
          <h3>MorphoBlue Protocol</h3>
          <div class="contract-address" id="morpho-address">
            <span>Address:</span>
            <code>Loading...</code>
          </div>
          <div class="contract-data" id="morpho-data">
            <div class="spinner"></div>
            <p>Loading data...</p>
          </div>
        </div>
      </section>

      <section id="origin-contracts-section">
        <h2>Origin Chain Contracts</h2>
        <p class="section-description">Cross-chain contracts deployed on origin chains (Ethereum/Sepolia) accessible from the current chain context.</p>
        
        <!-- VB USDC Origin -->
        <div class="card">
          <h3>vbUSDC (Vault Bridge USDC)</h3>
          <div class="contract-address" id="vbusdc-origin-address">
            <span>Origin Address:</span>
            <code>Loading...</code>
          </div>
          <div class="contract-data" id="vbusdc-origin-data">
            <div class="spinner"></div>
            <p>Loading data...</p>
          </div>
        </div>

        <!-- VB ETH Origin -->
        <div class="card">
          <h3>vbETH (Vault Bridge ETH)</h3>
          <div class="contract-address" id="vbeth-origin-address">
            <span>Origin Address:</span>
            <code>Loading...</code>
          </div>
          <div class="contract-data" id="vbeth-origin-data">
            <div class="spinner"></div>
            <p>Loading data...</p>
          </div>
        </div>
      </section>
    </main>

    <footer>
      <p>
        Built with <a href="https://github.com/katana-network/specialk" target="_blank" rel="noopener noreferrer">Katana Development Starter Kit</a>
      </p>
    </footer>
  </div>

  <script type="module" src="main.js"></script>
</body>
</html>



================================================
FILE: src/main.ts
================================================
import { createPublicClient, createWalletClient, http, custom, formatEther, formatUnits, PublicClient, WalletClient } from 'viem';
import { addresses, CHAIN_IDS } from '../utils/addresses/index.js';

// Import ABIs from their respective locations
import AUSD_ABI from '../abis/tokens/IAUSD.json';
import WETH_ABI from '../abis/vb/tokens/IbvbEth.json';
import MORPHO_BLUE_ABI from '../abis/morpho/IMorphoBlue.json';

// Chain information
const CHAIN_INFO = {
  [CHAIN_IDS.KATANA]: { name: 'Katana', symbol: 'ETH' },
  [CHAIN_IDS.BOKUTO]: { name: 'Bokuto', symbol: 'ETH' }
};

// Current chain context - will be set dynamically
let currentChainId: number | null = null;
let currentChainInfo: { name: string; symbol: string } | null = null;

// DOM Elements
const networkIndicator = document.getElementById('network-indicator') as HTMLElement;
const networkName = document.getElementById('network-name') as HTMLElement;
const walletStatus = document.getElementById('wallet-status') as HTMLElement;
const connectWalletButton = document.getElementById('connect-wallet') as HTMLButtonElement;
const ausdDataElement = document.getElementById('ausd-data') as HTMLElement;
const wethDataElement = document.getElementById('weth-data') as HTMLElement;
const morphoDataElement = document.getElementById('morpho-data') as HTMLElement;

// Address display elements
const ausdAddressElement = document.getElementById('ausd-address') as HTMLElement;
const wethAddressElement = document.getElementById('weth-address') as HTMLElement;
const morphoAddressElement = document.getElementById('morpho-address') as HTMLElement;

// Origin contract elements
const vbusdcOriginDataElement = document.getElementById('vbusdc-origin-data') as HTMLElement;
const vbethOriginDataElement = document.getElementById('vbeth-origin-data') as HTMLElement;
const vbusdcOriginAddressElement = document.getElementById('vbusdc-origin-address') as HTMLElement;
const vbethOriginAddressElement = document.getElementById('vbeth-origin-address') as HTMLElement;

// Check for wallet
const hasEthereum = typeof window !== 'undefined' && window.ethereum;

// Create clients
let publicClient: PublicClient;
let walletClient: WalletClient;

// Create transport with retry logic
function createRobustTransport() {
  // Create transport with retries
  return http('http://localhost:8545', {
    timeout: 10000, // 10 seconds
    fetchOptions: {
      headers: {
        'Content-Type': 'application/json',
      },
      cache: 'no-cache',
    },
    // Basic retry with exponential backoff
    retryCount: 3,
    retryDelay: 1000,
  });
}

// Setup
async function initialize() {
  try {
    // Create a public client with custom config
    publicClient = createPublicClient({
      transport: createRobustTransport()
    });

    // Test connection with a simple method first
    try {
      // Ping the RPC with a simple request before attempting more complex calls
      await publicClient.getBlockNumber();
      
      // Then try to get chain ID and detect which chain we're connected to
      const chainId = await publicClient.getChainId();
      const chainInfo = CHAIN_INFO[chainId as keyof typeof CHAIN_INFO];
      
      if (!chainInfo) {
        const validChainIds = Object.keys(CHAIN_INFO).join(', ');
        updateNetworkStatus('error', `Unknown network: ${chainId}`);
        displayRpcError(`Connected to unknown network. Expected one of: ${validChainIds}`);
        return;
      }
      
      // Set the global chain context
      currentChainId = chainId;
      currentChainInfo = chainInfo;
      
      // Set the address context for this chain
      addresses.setChain(chainId);
      
      updateNetworkStatus('connected', chainInfo.name);
      console.log(`âœ… Connected to ${chainInfo.name} (Chain ID: ${chainId})`);
      
      // Test if we have contracts available on this chain
      const availableContracts = addresses.getAllContracts();
      console.log(`ğŸ“‹ Found ${availableContracts.length} contracts available on ${chainInfo.name}`);
      
      // Check if we have the key contracts we want to display
      const hasAUSD = addresses.hasContract('AUSD');
      const hasWETH = addresses.hasContract('bvbEth');
      const hasMorpho = addresses.hasContract('MorphoBlue');
      
      if (!hasAUSD && !hasWETH && !hasMorpho) {
        updateNetworkStatus('warning', `${chainInfo.name} (No contracts)`);
        displayRpcError(`No key contracts (AUSD, bvbEth, MorphoBlue) found on ${chainInfo.name}. The contracts may not be deployed on this chain yet.`);
        return;
      }
      
      // Test reading a contract to validate the connection
      if (hasAUSD) {
        try {
          const ausdAddress = addresses.getAddress('AUSD');
          const ausdSymbol = await publicClient.readContract({
            address: ausdAddress,
            abi: AUSD_ABI,
            functionName: 'symbol'
          });
          console.log(`Connected and able to read contracts. AUSD symbol: ${ausdSymbol}`);
        } catch (contractError) {
          console.error('Contract read test failed:', contractError);
          updateNetworkStatus('error', 'Contract read failed');
          displayRpcError('Contract read error. The fork might not have the contract state loaded correctly.');
          return;
        }
      }
      
      // Update address displays
      updateAddressDisplays();
      
      // Now load all contract data
      loadContractData();
        
    } catch (error) {
      console.error('RPC connection error:', error);
      updateNetworkStatus('error', 'Fork not running');
      displayRpcError('Unable to connect to local chain fork');
    }
  } catch (error) {
    console.error('Initialization error:', error);
    updateNetworkStatus('error', 'Connection error');
    displayRpcError();
  }

  // Handle wallet connection separately from RPC connection
  if (!hasEthereum) {
    walletStatus.textContent = 'No wallet detected';
  }
}

// Display RPC connection error
function displayRpcError(customMessage?: string) {
  const errorMessage = `
    <div class="error-message">
      <h4>âš ï¸ Connection Error</h4>
      ${customMessage ? `<p>${customMessage}</p>` : ''}
      <p>Make sure you've started a local chain fork with:</p>
      <pre>bun run start:anvil bokuto   # or bokuto/katana</pre>
      <p>Your local RPC should be running at http://localhost:8545</p>
    </div>
  `;

  // Display error in all contract data elements
  ausdDataElement.innerHTML = errorMessage;
  wethDataElement.innerHTML = errorMessage;
  morphoDataElement.innerHTML = errorMessage;
  vbusdcOriginDataElement.innerHTML = errorMessage;
  vbethOriginDataElement.innerHTML = errorMessage;
}

// Update network status indicator
function updateNetworkStatus(status: 'connected' | 'error' | 'warning', name: string) {
  networkIndicator.className = status;
  networkName.textContent = name;
}

// Update address displays
function updateAddressDisplays() {
  try {
    // Update regular contract addresses
    if (addresses.hasContract('AUSD')) {
      const ausdAddress = addresses.getAddress('AUSD');
      ausdAddressElement.querySelector('code')!.textContent = ausdAddress;
    } else {
      ausdAddressElement.querySelector('code')!.textContent = 'Not deployed on this chain';
    }

    if (addresses.hasContract('bvbEth')) {
      const wethAddress = addresses.getAddress('bvbEth');
      wethAddressElement.querySelector('code')!.textContent = wethAddress;
    } else {
      wethAddressElement.querySelector('code')!.textContent = 'Not deployed on this chain';
    }

    if (addresses.hasContract('MorphoBlue')) {
      const morphoAddress = addresses.getAddress('MorphoBlue');
      morphoAddressElement.querySelector('code')!.textContent = morphoAddress;
    } else {
      morphoAddressElement.querySelector('code')!.textContent = 'Not deployed on this chain';
    }

    // Update origin contract addresses
    if (addresses.hasOriginContract('vbUSDC')) {
      const vbusdcOriginAddress = addresses.getOriginAddress('vbUSDC');
      const originChain = currentChainId === CHAIN_IDS.KATANA ? 'Ethereum' : 'Sepolia';
      vbusdcOriginAddressElement.querySelector('code')!.textContent = vbusdcOriginAddress;
      vbusdcOriginAddressElement.querySelector('span')!.textContent = `${originChain} Address:`;
    } else {
      vbusdcOriginAddressElement.querySelector('code')!.textContent = 'Not available in this context';
    }

    if (addresses.hasOriginContract('vbETH')) {
      const vbethOriginAddress = addresses.getOriginAddress('vbETH');
      const originChain = currentChainId === CHAIN_IDS.KATANA ? 'Ethereum' : 'Sepolia';
      vbethOriginAddressElement.querySelector('code')!.textContent = vbethOriginAddress;
      vbethOriginAddressElement.querySelector('span')!.textContent = `${originChain} Address:`;
    } else {
      vbethOriginAddressElement.querySelector('code')!.textContent = 'Not available in this context';
    }
  } catch (error) {
    console.error('Error updating address displays:', error);
  }
}

// Connect wallet
async function connectWallet() {
  if (!hasEthereum) {
    alert('Please install MetaMask or another Ethereum wallet');
    return;
  }

  try {
    // Request account access
    walletClient = createWalletClient({
      transport: custom(window.ethereum)
    });
    
    const accounts = await walletClient.requestAddresses();
    
    if (accounts.length > 0) {
      walletStatus.textContent = `Connected: ${shortenAddress(accounts[0])}`;
      connectWalletButton.textContent = 'Connected';
      connectWalletButton.disabled = true;
    }
  } catch (error) {
    console.error('Connection error:', error);
    walletStatus.textContent = 'Connection failed';
  }
}

// Shorten address for display
function shortenAddress(address: string): string {
  return `${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
}

// Generic function to safely load contract data with fallback
async function safeContractCall<T>(
  callback: () => Promise<T>,
  errorHandler: (error: any) => void
): Promise<T | null> {
  try {
    return await callback();
  } catch (error) {
    errorHandler(error);
    return null;
  }
}

// Load AUSD Token data
async function loadAUSDData() {
  // Check if AUSD is available on current chain
  if (!addresses.hasContract('AUSD')) {
    ausdDataElement.innerHTML = `<p>AUSD not available on ${currentChainInfo?.name || 'this chain'}</p>`;
    return;
  }

  // Get AUSD address dynamically
  const ausdAddress = addresses.getAddress('AUSD');

  // Clear previous content and show loading state
  ausdDataElement.innerHTML = '<div class="spinner"></div><p>Loading data...</p>';
  
  try {
    // Load data sequentially to avoid batching issues
    const name = await safeContractCall(
      () => publicClient.readContract({
        address: ausdAddress,
        abi: AUSD_ABI,
        functionName: 'name'
      }),
      (error) => console.error('Error reading AUSD name:', error)
    );
    
    const symbol = await safeContractCall(
      () => publicClient.readContract({
        address: ausdAddress,
        abi: AUSD_ABI,
        functionName: 'symbol'
      }),
      (error) => console.error('Error reading AUSD symbol:', error)
    );
    
    const decimals = await safeContractCall(
      () => publicClient.readContract({
        address: ausdAddress,
        abi: AUSD_ABI,
        functionName: 'decimals'
      }),
      (error) => console.error('Error reading AUSD decimals:', error)
    );
    
    const totalSupply = await safeContractCall(
      () => publicClient.readContract({
        address: ausdAddress,
        abi: AUSD_ABI,
        functionName: 'totalSupply'
      }),
      (error) => console.error('Error reading AUSD totalSupply:', error)
    );

    // If we couldn't get any data, show error
    if (!name && !symbol && !decimals && !totalSupply) {
      throw new Error('Failed to load any AUSD data');
    }

    // Format and display data
    ausdDataElement.innerHTML = '';
    ausdDataElement.classList.add('loaded');

    // Calculate total supply formatted string
    let formattedSupply = 'Error loading';
    if (totalSupply !== null && decimals !== null) {
      try {
        // totalSupply is expected to be a bigint, ensure it is one
        const supplyBigInt = typeof totalSupply === 'bigint' ? totalSupply : BigInt(0);
        const decimalNumber = typeof decimals === 'number' ? decimals : 18;
        formattedSupply = `${formatUnits(supplyBigInt, decimalNumber)} ${symbol || ''}`;
      } catch (e) {
        console.error('Error formatting AUSD supply:', e);
      }
    }

    // Use type guards to ensure proper formatting
    const formattedData = [
      { label: 'Name', value: name ? String(name) : 'Error loading' },
      { label: 'Symbol', value: symbol ? String(symbol) : 'Error loading' },
      { label: 'Decimals', value: decimals !== null ? String(decimals) : 'Error loading' },
      { label: 'Total Supply', value: formattedSupply },
      { label: 'Address', value: ausdAddress }
    ];

    formattedData.forEach(item => {
      const dataItem = document.createElement('div');
      dataItem.className = 'data-item';
      dataItem.innerHTML = `
        <div class="label">${item.label}</div>
        <div class="value">${item.value}</div>
      `;
      ausdDataElement.appendChild(dataItem);
    });
  } catch (error) {
    console.error('Error loading AUSD data:', error);
    ausdDataElement.innerHTML = `<p>Error loading data. Make sure the ${currentChainInfo?.name || 'chain'} fork is running.</p>`;
  }
}

// Load bvbEth Token data
async function loadWETHData() {
  // Check if bvbEth is available on current chain
  if (!addresses.hasContract('bvbEth')) {
    wethDataElement.innerHTML = `<p>bvbEth not available on ${currentChainInfo?.name || 'this chain'}</p>`;
    return;
  }

  // Get bvbEth address dynamically
  const wethAddress = addresses.getAddress('bvbEth');

  // Clear previous content and show loading state
  wethDataElement.innerHTML = '<div class="spinner"></div><p>Loading data...</p>';
  
  try {
    // Load data sequentially to avoid batching issues
    const name = await safeContractCall(
      () => publicClient.readContract({
        address: wethAddress,
        abi: WETH_ABI,
        functionName: 'name'
      }),
              (error) => console.error('Error reading bvbEth name:', error)
    );
    
    const symbol = await safeContractCall(
      () => publicClient.readContract({
        address: wethAddress,
        abi: WETH_ABI,
        functionName: 'symbol'
      }),
              (error) => console.error('Error reading bvbEth symbol:', error)
    );
    
    const totalSupply = await safeContractCall(
      () => publicClient.readContract({
        address: wethAddress,
        abi: WETH_ABI,
        functionName: 'totalSupply'
      }),
              (error) => console.error('Error reading bvbEth totalSupply:', error)
    );

    // If we couldn't get any data, show error
    if (!name && !symbol && !totalSupply) {
      throw new Error('Failed to load any bvbEth data');
    }

    // Format and display data
    wethDataElement.innerHTML = '';
    wethDataElement.classList.add('loaded');

    // Calculate total supply formatted string
    let formattedSupply = 'Error loading';
    if (totalSupply !== null) {
      try {
        // totalSupply is expected to be a bigint, ensure it is one
        const supplyBigInt = typeof totalSupply === 'bigint' ? totalSupply : BigInt(0);
        formattedSupply = `${formatEther(supplyBigInt)} ${symbol || ''}`;
      } catch (e) {
        console.error('Error formatting bvbEth supply:', e);
      }
    }

    // Use type guards to ensure proper formatting
    const formattedData = [
      { label: 'Name', value: name ? String(name) : 'Error loading' },
      { label: 'Symbol', value: symbol ? String(symbol) : 'Error loading' },
      { label: 'Total Supply', value: formattedSupply },
      { label: 'Address', value: wethAddress }
    ];

    formattedData.forEach(item => {
      const dataItem = document.createElement('div');
      dataItem.className = 'data-item';
      dataItem.innerHTML = `
        <div class="label">${item.label}</div>
        <div class="value">${item.value}</div>
      `;
      wethDataElement.appendChild(dataItem);
    });
  } catch (error) {
    console.error('Error loading bvbEth data:', error);
    wethDataElement.innerHTML = `<p>Error loading data. Make sure the ${currentChainInfo?.name || 'chain'} fork is running.</p>`;
  }
}

// Load MorphoBlue data
async function loadMorphoData() {
  // Check if MorphoBlue is available on current chain
  if (!addresses.hasContract('MorphoBlue')) {
    morphoDataElement.innerHTML = `<p>MorphoBlue not available on ${currentChainInfo?.name || 'this chain'}</p>`;
    return;
  }

  // Get MorphoBlue address dynamically
  const morphoAddress = addresses.getAddress('MorphoBlue');

  // Clear previous content and show loading state
  morphoDataElement.innerHTML = '<div class="spinner"></div><p>Loading data...</p>';
  
  try {
    // Load data sequentially to avoid batching issues
    const owner = await safeContractCall(
      () => publicClient.readContract({
        address: morphoAddress,
        abi: MORPHO_BLUE_ABI,
        functionName: 'owner'
      }),
      (error) => console.error('Error reading MorphoBlue owner:', error)
    );
    
    const feeRecipient = await safeContractCall(
      () => publicClient.readContract({
        address: morphoAddress,
        abi: MORPHO_BLUE_ABI,
        functionName: 'feeRecipient'
      }),
      (error) => console.error('Error reading MorphoBlue feeRecipient:', error)
    );

    // Check if 50% LLTV is enabled
    const lltv50Percent = 5000n; // 50% in basis points
    const isLltv50Enabled = await safeContractCall(
      () => publicClient.readContract({
        address: morphoAddress,
        abi: MORPHO_BLUE_ABI,
        functionName: 'isLltvEnabled',
        args: [lltv50Percent]
      }),
      (error) => console.error('Error reading MorphoBlue LLTV:', error)
    );

    // If we couldn't get any data, show error
    if (!owner && !feeRecipient && isLltv50Enabled === null) {
      throw new Error('Failed to load any MorphoBlue data');
    }

    // Format and display data
    morphoDataElement.innerHTML = '';
    morphoDataElement.classList.add('loaded');

    // Use type guards to ensure proper formatting
    const formattedData = [
      { label: 'Owner', value: owner ? shortenAddress(String(owner)) : 'Error loading' },
      { label: 'Fee Recipient', value: feeRecipient ? shortenAddress(String(feeRecipient)) : 'Error loading' },
      { label: '50% LLTV Enabled', value: isLltv50Enabled === null ? 'Error loading' : 
          isLltv50Enabled ? 'Yes' : 'No' },
      { label: 'Address', value: morphoAddress }
    ];

    formattedData.forEach(item => {
      const dataItem = document.createElement('div');
      dataItem.className = 'data-item';
      dataItem.innerHTML = `
        <div class="label">${item.label}</div>
        <div class="value">${item.value}</div>
      `;
      morphoDataElement.appendChild(dataItem);
    });
  } catch (error) {
    console.error('Error loading MorphoBlue data:', error);
    morphoDataElement.innerHTML = `<p>Error loading data. Make sure the ${currentChainInfo?.name || 'chain'} fork is running.</p>`;
  }
}

// Load origin contract data for vbUSDC
async function loadVBUSDCOriginData() {
  if (!addresses.hasOriginContract('vbUSDC')) {
    const originChain = currentChainId === CHAIN_IDS.KATANA ? 'Ethereum' : 'Sepolia';
    vbusdcOriginDataElement.innerHTML = `<p>vbUSDC not available on ${originChain} in this context</p>`;
    return;
  }

  vbusdcOriginDataElement.innerHTML = '<div class="spinner"></div><p>Loading origin data...</p>';
  
  try {
    const vbusdcOriginAddress = addresses.getOriginAddress('vbUSDC');
    const originChain = currentChainId === CHAIN_IDS.KATANA ? 'Ethereum' : 'Sepolia';
    
    // Since we're demonstrating cross-chain addresses, we can't actually read from origin contracts
    // via the local fork, but we can show the address and explain the concept
    vbusdcOriginDataElement.innerHTML = '';
    vbusdcOriginDataElement.classList.add('loaded');

    const formattedData = [
      { label: 'Origin Chain', value: originChain },
      { label: 'Contract Type', value: 'Vault Bridge USDC Token' },
      { label: 'Purpose', value: 'Cross-chain yield-bearing USDC' },
      { label: 'Origin Address', value: vbusdcOriginAddress },
      { label: 'Note', value: 'This contract exists on the origin chain and cannot be read directly from the destination chain fork.' }
    ];

    formattedData.forEach(item => {
      const dataItem = document.createElement('div');
      dataItem.className = 'data-item';
      dataItem.innerHTML = `
        <div class="label">${item.label}</div>
        <div class="value">${item.value}</div>
      `;
      vbusdcOriginDataElement.appendChild(dataItem);
    });
  } catch (error) {
    console.error('Error loading vbUSDC origin data:', error);
    vbusdcOriginDataElement.innerHTML = `<p>Error loading origin data.</p>`;
  }
}

// Load origin contract data for vbETH
async function loadVBETHOriginData() {
  if (!addresses.hasOriginContract('vbETH')) {
    const originChain = currentChainId === CHAIN_IDS.KATANA ? 'Ethereum' : 'Sepolia';
    vbethOriginDataElement.innerHTML = `<p>vbETH not available on ${originChain} in this context</p>`;
    return;
  }

  vbethOriginDataElement.innerHTML = '<div class="spinner"></div><p>Loading origin data...</p>';
  
  try {
    const vbethOriginAddress = addresses.getOriginAddress('vbETH');
    const originChain = currentChainId === CHAIN_IDS.KATANA ? 'Ethereum' : 'Sepolia';
    
    vbethOriginDataElement.innerHTML = '';
    vbethOriginDataElement.classList.add('loaded');

    const formattedData = [
      { label: 'Origin Chain', value: originChain },
      { label: 'Contract Type', value: 'Vault Bridge ETH Token' },
      { label: 'Purpose', value: 'Cross-chain yield-bearing ETH' },
      { label: 'Origin Address', value: vbethOriginAddress },
      { label: 'Note', value: 'This contract exists on the origin chain and cannot be read directly from the destination chain fork.' }
    ];

    formattedData.forEach(item => {
      const dataItem = document.createElement('div');
      dataItem.className = 'data-item';
      dataItem.innerHTML = `
        <div class="label">${item.label}</div>
        <div class="value">${item.value}</div>
      `;
      vbethOriginDataElement.appendChild(dataItem);
    });
  } catch (error) {
    console.error('Error loading vbETH origin data:', error);
    vbethOriginDataElement.innerHTML = `<p>Error loading origin data.</p>`;
  }
}

// Load all contract data
async function loadContractData() {
  // Load data sequentially to avoid overloading the server
  // Only load contracts that are available on the current chain
  try {
    console.log(`ğŸ“Š Loading contract data for ${currentChainInfo?.name}...`);
    
    if (addresses.hasContract('AUSD')) {
      await loadAUSDData();
    } else {
      ausdDataElement.innerHTML = `<p>AUSD not deployed on ${currentChainInfo?.name}</p>`;
    }
    
    if (addresses.hasContract('bvbEth')) {
      await loadWETHData();
    } else {
      wethDataElement.innerHTML = `<p>bvbEth not deployed on ${currentChainInfo?.name}</p>`;
    }
    
    if (addresses.hasContract('MorphoBlue')) {
      await loadMorphoData();
    } else {
      morphoDataElement.innerHTML = `<p>MorphoBlue not deployed on ${currentChainInfo?.name}</p>`;
    }

    // Load origin contract data
    await loadVBUSDCOriginData();
    await loadVBETHOriginData();
    
    console.log('âœ… Contract data loading complete');
  } catch (error) {
    console.error('Failed to load contract data:', error);
  }
}

// Add error styles and section styling
const style = document.createElement('style');
style.textContent = `
  .error-message {
    background-color: #fef2f2;
    border: 1px solid #fee2e2;
    border-radius: 6px;
    padding: 12px;
    margin-top: 10px;
  }
  
  .error-message h4 {
    color: #dc2626;
    margin-bottom: 8px;
  }
  
  .error-message pre {
    background-color: #f1f5f9;
    padding: 8px;
    border-radius: 4px;
    margin: 8px 0;
    overflow-x: auto;
  }
  
  .section-description {
    color: #6b7280;
    font-style: italic;
    margin-bottom: 1rem;
    line-height: 1.5;
  }
  
  #origin-contracts-section {
    margin-top: 2rem;
    padding-top: 1.5rem;
    border-top: 1px solid #e5e7eb;
  }
  
  #origin-contracts-section .card {
    border-left: 3px solid #10b981;
  }
`;
document.head.appendChild(style);

// Event listeners
connectWalletButton.addEventListener('click', connectWallet);

// Initialize the app
initialize();

// Add window.ethereum type
declare global {
  interface Window {
    ethereum: any;
  }
}



================================================
FILE: src/style.css
================================================
:root {
  --primary-color: #6366f1;
  --secondary-color: #4f46e5;
  --text-color: #1e293b;
  --light-text: #94a3b8;
  --background: #f8fafc;
  --card-bg: #ffffff;
  --border-color: #e2e8f0;
  --success-color: #10b981;
  --error-color: #ef4444;
  --warning-color: #f59e0b;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  line-height: 1.6;
  color: var(--text-color);
  background-color: var(--background);
}

.container {
  max-width: 1100px;
  margin: 0 auto;
  padding: 20px;
}

header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 30px;
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 20px;
}

header h1 {
  font-size: 2rem;
  color: var(--primary-color);
}

.network-status {
  display: flex;
  align-items: center;
  gap: 10px;
}

#network-indicator {
  display: inline-block;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background-color: var(--warning-color);
}

#network-indicator.connected {
  background-color: var(--success-color);
}

#network-indicator.error {
  background-color: var(--error-color);
}

section {
  margin-bottom: 30px;
}

h2 {
  margin-bottom: 15px;
  color: var(--text-color);
  font-weight: 600;
}

h3 {
  margin-bottom: 15px;
  color: var(--text-color);
  font-weight: 500;
}

.card {
  background-color: var(--card-bg);
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  margin-bottom: 20px;
}

.contract-address {
  margin-bottom: 15px;
  font-size: 0.9rem;
  color: var(--light-text);
}

.contract-address code {
  display: block;
  margin-top: 5px;
  padding: 5px;
  background-color: var(--background);
  border-radius: 4px;
  overflow-wrap: break-word;
}

.contract-data {
  min-height: 100px;
}

.contract-data.loaded {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 10px;
}

.data-item {
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 10px;
}

.data-item .label {
  font-size: 0.9rem;
  color: var(--light-text);
}

.data-item .value {
  font-weight: 500;
}

.spinner {
  margin: 20px auto;
  width: 30px;
  height: 30px;
  border: 3px solid var(--light-text);
  border-top: 3px solid var(--primary-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

button {
  padding: 10px 15px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 500;
  transition: all 0.2s ease;
}

.primary-button {
  background-color: var(--primary-color);
  color: white;
}

.primary-button:hover {
  background-color: var(--secondary-color);
}

/* Error message styling */
.error-message {
  background-color: #fef2f2;
  border: 1px solid #fee2e2;
  border-radius: 6px;
  padding: 12px;
  margin-top: 10px;
  color: #b91c1c;
}

.error-message h4 {
  color: #dc2626;
  margin-bottom: 8px;
  font-weight: 600;
}

.error-message pre {
  background-color: #f1f5f9;
  padding: 8px;
  border-radius: 4px;
  margin: 8px 0;
  overflow-x: auto;
  color: #334155;
  font-family: monospace;
}

footer {
  margin-top: 50px;
  padding-top: 20px;
  border-top: 1px solid var(--border-color);
  text-align: center;
  color: var(--light-text);
  font-size: 0.9rem;
}



================================================
FILE: utils/address-example.js
================================================
// Example of how to use the generated address mapping

import getContractAddress, { CHAIN_IDS, CONTRACT_ADDRESSES } from './addresses.js';

// Option 1: Get address by contract name and chain ID
const bokutoWETH = getContractAddress('WETH', CHAIN_IDS.BOKUTO);
console.log('WETH address on Bokuto:', bokutoWETH);

// Option 2: Get address from the mapping directly
const morphoAddress = CONTRACT_ADDRESSES.MorphoBlue.bokuto;
console.log('Morpho Blue address on Bokuto:', morphoAddress);

// Option 3: Checking if an address exists before using it
const chainId = CHAIN_IDS.BOKUTO; // Could come from a wallet connection
const contractName = 'Seaport';

const seaportAddress = getContractAddress(contractName, chainId);
if (seaportAddress) {
  console.log(`Using ${contractName} at ${seaportAddress}`);
} else {
  console.log(`${contractName} not available on chain ID ${chainId}`);
}

// Option 4: Getting all available contracts on a specific chain
function getContractsForChain(chainId) {
  const network = chainId === CHAIN_IDS.BOKUTO ? 'bokuto' : 'katana';
  return Object.entries(CONTRACT_ADDRESSES)
    .filter(([_, addresses]) => addresses[network] !== null)
    .map(([name, addresses]) => ({
      name,
      address: addresses[network]
    }));
}

const bokutoContracts = getContractsForChain(CHAIN_IDS.BOKUTO);
console.log('Available contracts on Bokuto:', bokutoContracts.length);


================================================
FILE: utils/phonehome.ts
================================================
import { existsSync, mkdirSync, readFileSync, writeFileSync, readSync as fsReadSync } from "fs";
import { readdir, writeFile } from "fs/promises";
import { join, dirname } from "path";
import { homedir } from "os";
import { randomUUID } from "crypto";
import { spawn } from "child_process";

type Consent = "yes" | "no" | "unset";

interface PhonehomeConfig {
  consent: Consent;
  repoId: string;
  deviceId: string;
}

const repoRoot = process.cwd();
const phonehomeDir = join(repoRoot, ".phonehome");
const queueDir = join(phonehomeDir, "queue");
const configFile = join(phonehomeDir, "config.json");
const deviceDir = join(homedir(), ".katana-phonehome");
const deviceFile = join(deviceDir, "device-id");

const envForceOn = process.env.KATANA_PHONEHOME === "1";
const envForceOff = process.env.KATANA_PHONEHOME === "0" || process.env.CI === "true" || process.env.GITHUB_ACTIONS === "true" || process.env.DO_NOT_TRACK === "1";

function ensureDir(path: string) {
  try { mkdirSync(path, { recursive: true }); } catch {}
}

function readJson<T>(path: string): T | null {
  try { return JSON.parse(readFileSync(path, "utf8")) as T; } catch { return null; }
}

function writeJson(path: string, data: unknown) {
  try {
    ensureDir(dirname(path));
    writeFileSync(path, JSON.stringify(data, null, 2) + "\n", "utf8");
  } catch {}
}

function loadOrCreateDeviceId(): string {
  try {
    if (existsSync(deviceFile)) return readFileSync(deviceFile, "utf8").trim();
  } catch {}
  const id = randomUUID();
  try {
    ensureDir(deviceDir);
    writeFileSync(deviceFile, id + "\n", "utf8");
  } catch {}
  return id;
}

function loadOrCreateConfig(): PhonehomeConfig {
  const existing = readJson<PhonehomeConfig>(configFile);
  if (existing && existing.repoId && existing.deviceId && existing.consent) return existing;
  const cfg: PhonehomeConfig = {
    consent: existing?.consent ?? "unset",
    repoId: existing?.repoId ?? randomUUID(),
    deviceId: existing?.deviceId ?? loadOrCreateDeviceId(),
  };
  writeJson(configFile, cfg);
  return cfg;
}

function promptForConsent(): Consent {
  if (!process.stdin.isTTY) return "no";
  const msg = "Help improve Katana Starter Kit by sending anonymous usage (event name, version, OS). [y/N]: ";
  process.stdout.write(msg);
  try {
    const buf = Buffer.alloc(1);
    const n = fsReadSync(0, buf, 0, 1, null);
    const ch = String.fromCharCode(buf[0] ?? 110).toLowerCase();
    return ch === "y" ? "yes" : "no";
  } catch {
    return "no";
  }
}

function getPkgVersion(): string {
  try { return JSON.parse(readFileSync(join(repoRoot, "package.json"), "utf8")).version ?? "0.0.0"; } catch { return "0.0.0"; }
}

function tryParseJson<T = any>(txt: string): T | null {
  try { return JSON.parse(txt) as T; } catch { return null; }
}

function parseKeyValueList(txt: string): Record<string, string> {
  const out: Record<string, string> = {};
  for (const part of txt.split(/[;,]/)) {
    const p = part.trim();
    if (!p) continue;
    const eq = p.indexOf("=");
    if (eq === -1) continue;
    const k = p.slice(0, eq).trim();
    const v = p.slice(eq + 1).trim();
    if (k) out[k] = v;
  }
  return out;
}

function parseMetaFromArgs(argv: string[]): Record<string, string> {
  const meta: Record<string, string> = {};
  for (let i = 0; i < argv.length; i++) {
    if (argv[i] === "--meta") {
      const val = argv[i + 1] || "";
      const eq = val.indexOf("=");
      if (eq !== -1) {
        const k = val.slice(0, eq).trim();
        const v = val.slice(eq + 1).trim();
        if (k) meta[k] = v;
      }
      i++;
    }
  }
  return meta;
}

function parseMetaFromEnv(): Record<string, string> {
  const env = process.env.PHONEHOME_META;
  if (!env) return {};
  const asJson = tryParseJson<Record<string, string>>(env);
  if (asJson && typeof asJson === "object") return asJson;
  return parseKeyValueList(env);
}

async function maybeSpawnFlusher() {
  try {
    const files = await readdir(queueDir);
    const shouldFlush = files.length >= 20 || Math.random() < 0.05;
    if (!shouldFlush) return;
    const child = spawn("bun", ["utils/phonehome_flush.ts"], { stdio: "ignore", cwd: repoRoot, detached: true });
    child.unref();
  } catch {}
}

function shouldTrack(consent: Consent): boolean {
  if (envForceOff) return false;
  if (envForceOn) return true;
  return consent === "yes";
}

async function main() {
  // parse --event <name>
  const idx = process.argv.indexOf("--event");
  const eventName = idx >= 0 ? (process.argv[idx + 1] || "") : "";
  if (!eventName) return; // nothing to do

  ensureDir(phonehomeDir);
  ensureDir(queueDir);

  const cfg = loadOrCreateConfig();

  // Resolve consent if unset
  if (cfg.consent === "unset" && !envForceOff && !envForceOn) {
    const answer = promptForConsent();
    cfg.consent = answer;
    writeJson(configFile, cfg);
  }

  if (!shouldTrack(cfg.consent)) return;

  // Build metadata (centralized; pre-scripts can enrich via env or argv)
  const meta: Record<string, any> = {
    ...parseMetaFromEnv(),
    ...parseMetaFromArgs(process.argv.slice(2)),
  };

  const payload = {
    event: eventName,
    repoId: cfg.repoId,
    deviceId: cfg.deviceId,
    version: getPkgVersion(),
    env: {
      os: process.platform,
      arch: process.arch,
      bunVersion: (process as any).versions?.bun || null,
      ci: Boolean(process.env.CI || process.env.GITHUB_ACTIONS)
    },
    ts: new Date().toISOString(),
    meta,
  };

  // Write event to queue; do not await network
  const fname = `${Date.now()}-${Math.random().toString(36).slice(2)}.json`;
  try {
    await writeFile(join(queueDir, fname), JSON.stringify(payload) + "\n", "utf8");
  } catch {}

  // Fire-and-forget flusher
  maybeSpawnFlusher();
}

main().catch(() => {});





================================================
FILE: utils/phonehome_flush.ts
================================================
import { readdir, readFile, rm } from "fs/promises";
import { existsSync } from "fs";
import { join } from "path";

const repoRoot = process.cwd();
const queueDir = join(repoRoot, ".phonehome", "queue");
const endpoint = process.env.PHONEHOME_ENDPOINT || "https://n8n.srv1000968.hstgr.cloud/webhook/3c90ca24-04d9-48bf-b8a3-de0157f61c27";
const debug = process.env.PHONEHOME_DEBUG === "1" || process.argv.includes("--debug");

function log(...args: any[]) {
  if (debug) console.log("[phonehome:flush]", ...args);
}

async function flushOnce() {
  log("cwd=", repoRoot);
  log("queueDir=", queueDir);
  if (!existsSync(queueDir)) {
    log("queueDir does not exist, nothing to flush");
    return;
  }
  let files: string[] = [];
  try {
    files = (await readdir(queueDir)).filter(f => f.endsWith(".json"));
  } catch (e) {
    log("failed to read queueDir:", (e as Error).message);
    return;
  }
  log("found", files.length, "queued files");
  if (!files.length) return;

  const batch = [] as any[];
  const used: string[] = [];
  for (const f of files.slice(0, 500)) {
    try {
      const txt = await readFile(join(queueDir, f), "utf8");
      batch.push(JSON.parse(txt));
      used.push(f);
    } catch (e) {
      log("failed to read/parse", f, ":", (e as Error).message);
    }
  }
  log("prepared batch size=", batch.length);
  if (!batch.length) {
    log("no valid events to send");
    return;
  }

  const controller = new AbortController();
  const to = setTimeout(() => controller.abort(), 800);
  try {
    log("posting to", endpoint);
    const res = await fetch(endpoint, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({ events: batch }),
      keepalive: true,
      signal: controller.signal,
    });
    clearTimeout(to);
    log("response status=", res.status);
    if (res.ok) {
      log("deleting", used.length, "flushed files");
      await Promise.all(used.map(f => rm(join(queueDir, f), { force: true })));
      log("flush complete");
    } else {
      const text = await res.text().catch(() => "");
      log("server error:", res.status, text.slice(0, 200));
    }
  } catch (e) {
    log("fetch failed:", (e as Error).name, (e as Error).message);
    // Leave files for next attempt
  }
}

flushOnce().catch((e) => {
  if (debug) console.log("[phonehome:flush] unhandled error:", (e as Error).message);
});





================================================
FILE: utils/addresses/index.ts
================================================
// Address management wrapper with improved API
// This file is manually maintained - do not auto-generate

import { CONTRACT_ADDRESSES, ORIGIN_CONTRACT_ADDRESSES, CHAIN_IDS } from './mapping';

/**
 * Chain IDs for all supported networks
 */
export interface ChainIds {
  KATANA: number;
  BOKUTO: number;
}

/**
 * Contract addresses for each network
 */
export interface ContractAddresses {
  [contractName: string]: {
    katana: `0x${string}` | null;
    bokuto: `0x${string}` | null;
  };
}

// Export the chain IDs from mapping
export { CHAIN_IDS };

/**
 * Supported chain names
 */
export type ChainName = 'katana' | 'bokuto';

/**
 * Map chain names to their IDs
 */
export const CHAINS = {
  katana: CHAIN_IDS.KATANA,
  bokuto: CHAIN_IDS.BOKUTO,
} as const;

/**
 * Get a contract address based on the contract name and chain ID
 * @param contractName - The name of the contract
 * @param chainId - The chain ID
 * @returns The contract address or null if not found
 */
function getContractAddress(contractName: string, chainId: number): `0x${string}` | null {
  if (!contractName || !CONTRACT_ADDRESSES[contractName]) {
    return null;
  }
  
  switch (chainId) {
    case CHAIN_IDS.KATANA:
      return CONTRACT_ADDRESSES[contractName].katana as `0x${string}` | null;
    case CHAIN_IDS.BOKUTO:
      return CONTRACT_ADDRESSES[contractName].bokuto as `0x${string}` | null;
    default:
      return null;
  }
}

/**
 * Get an origin contract address based on the contract name and chain ID
 * @param contractName - The name of the contract
 * @param chainId - The chain ID (representing the context, not the origin chain)
 * @returns The origin contract address or null if not found
 */
function getOriginContractAddress(contractName: string, chainId: number): `0x${string}` | null {
  if (!contractName || !ORIGIN_CONTRACT_ADDRESSES[contractName]) {
    return null;
  }
  
  switch (chainId) {
    case CHAIN_IDS.KATANA:
      return ORIGIN_CONTRACT_ADDRESSES[contractName].katana as `0x${string}` | null;
    case CHAIN_IDS.BOKUTO:
      return ORIGIN_CONTRACT_ADDRESSES[contractName].bokuto as `0x${string}` | null;
    default:
      return null;
  }
}

/**
 * Address management class with chain context
 */
class AddressManager {
  private currentChainId: number | null = null;

  /**
   * Set the current chain context
   * @param chainIdOrName - Chain ID or name to set as context
   * @example
   * addresses.setChain(CHAINS.bokuto);
   * addresses.setChain('bokuto');
   * addresses.setChain(129399);
   */
  setChain(chainIdOrName: number | ChainName): void {
    if (typeof chainIdOrName === 'string') {
      const chainId = CHAINS[chainIdOrName];
      if (!chainId) {
        throw new Error(`Unknown chain name: ${chainIdOrName}. Valid names are: ${Object.keys(CHAINS).join(', ')}`);
      }
      this.currentChainId = chainId;
    } else {
      // Validate that it's a known chain ID
      const validChainIds = Object.values(CHAIN_IDS);
      if (!validChainIds.includes(chainIdOrName)) {
        throw new Error(`Unknown chain ID: ${chainIdOrName}. Valid IDs are: ${validChainIds.join(', ')}`);
      }
      this.currentChainId = chainIdOrName;
    }
  }

  /**
   * Get the current chain ID
   * @returns The current chain ID or null if not set
   */
  getChain(): number | null {
    return this.currentChainId;
  }

  /**
   * Get the current chain name
   * @returns The current chain name or null if not set
   */
  getChainName(): ChainName | null {
    if (!this.currentChainId) return null;
    
    for (const [name, id] of Object.entries(CHAINS)) {
      if (id === this.currentChainId) {
        return name as ChainName;
      }
    }
    return null;
  }

  /**
   * Get a contract address for the current chain
   * @param contractName - Name of the contract (with or without 'I' prefix)
   * @returns The contract address
   * @throws Error if chain not set or contract not found
   * @example
   * addresses.setChain('bokuto');
   * const wethAddress = addresses.getAddress('WETH'); // Automatically tries 'IWETH' if 'WETH' not found
   */
  getAddress(contractName: string): `0x${string}` {
    if (!this.currentChainId) {
      throw new Error('Chain not set. Call setChain() first.');
    }

    // Try exact name first
    let address = getContractAddress(contractName, this.currentChainId);
    
    // If not found and doesn't start with 'I', try with 'I' prefix
    if (!address && !contractName.startsWith('I')) {
      address = getContractAddress('I' + contractName, this.currentChainId);
    }
    
    // If not found and starts with 'I', try without 'I' prefix
    if (!address && contractName.startsWith('I')) {
      address = getContractAddress(contractName.substring(1), this.currentChainId);
    }

    if (!address) {
      const chainName = this.getChainName();
      const availableContracts = Object.keys(CONTRACT_ADDRESSES)
        .filter(name => CONTRACT_ADDRESSES[name][chainName as ChainName])
        .sort();
      
      throw new Error(
        `Contract "${contractName}" not found on ${chainName} (chain ID: ${this.currentChainId}). ` +
        `Available contracts: ${availableContracts.join(', ')}`
      );
    }

    return address;
  }

  /**
   * Get a contract address for a specific chain (without setting context)
   * @param contractName - Name of the contract (with or without 'I' prefix)
   * @param chainIdOrName - Chain ID or name
   * @returns The contract address or null if not found
   */
  getAddressForChain(contractName: string, chainIdOrName: number | ChainName): `0x${string}` | null {
    const chainId = typeof chainIdOrName === 'string' ? CHAINS[chainIdOrName] : chainIdOrName;
    
    if (!chainId) {
      return null;
    }

    // Try exact name first
    let address = getContractAddress(contractName, chainId);
    
    // If not found and doesn't start with 'I', try with 'I' prefix
    if (!address && !contractName.startsWith('I')) {
      address = getContractAddress('I' + contractName, chainId);
    }
    
    // If not found and starts with 'I', try without 'I' prefix
    if (!address && contractName.startsWith('I')) {
      address = getContractAddress(contractName.substring(1), chainId);
    }

    return address;
  }

  /**
   * Check if a contract exists on the current chain
   * @param contractName - Name of the contract (with or without 'I' prefix)
   * @returns True if the contract exists on the current chain
   */
  hasContract(contractName: string): boolean {
    if (!this.currentChainId) {
      return false;
    }

    const address = this.getAddressForChain(contractName, this.currentChainId);
    return address !== null;
  }

  /**
   * Get all contract names available on the current chain
   * @returns Array of contract names
   */
  getAllContracts(): string[] {
    if (!this.currentChainId) {
      throw new Error('Chain not set. Call setChain() first.');
    }

    const chainName = this.getChainName();
    return Object.keys(CONTRACT_ADDRESSES)
      .filter(name => CONTRACT_ADDRESSES[name][chainName as ChainName])
      .sort();
  }

  /**
   * Get an origin contract address for the current chain context
   * Origin contracts are deployed on origin chains (Ethereum/Sepolia) but accessed
   * from the current chain context (e.g., for Vault Bridge operations)
   * @param contractName - Name of the contract (with or without 'I' prefix)
   * @returns The origin contract address
   * @throws Error if chain not set or contract not found
   * @example
   * addresses.setChain('katana');
   * const vbUSDCAddress = addresses.getOriginAddress('vbUSDC'); // Gets the Ethereum address
   */
  getOriginAddress(contractName: string): `0x${string}` {
    if (!this.currentChainId) {
      throw new Error('Chain not set. Call setChain() first.');
    }

    // Try exact name first
    let address = getOriginContractAddress(contractName, this.currentChainId);
    
    // If not found and doesn't start with 'I', try with 'I' prefix
    if (!address && !contractName.startsWith('I')) {
      address = getOriginContractAddress('I' + contractName, this.currentChainId);
    }
    
    // If not found and starts with 'I', try without 'I' prefix
    if (!address && contractName.startsWith('I')) {
      address = getOriginContractAddress(contractName.substring(1), this.currentChainId);
    }

    if (!address) {
      const chainName = this.getChainName();
      const availableOriginContracts = Object.keys(ORIGIN_CONTRACT_ADDRESSES)
        .filter(name => ORIGIN_CONTRACT_ADDRESSES[name][chainName as ChainName])
        .sort();
      
      throw new Error(
        `Origin contract "${contractName}" not found for chain ${chainName}. ` +
        `Available origin contracts: ${availableOriginContracts.join(', ')}`
      );
    }

    return address;
  }

  /**
   * Get an origin contract address for a specific chain without changing context
   * @param contractName - Name of the contract
   * @param chainIdOrName - Chain ID or name
   * @returns The origin contract address or null if not found
   */
  getOriginAddressForChain(contractName: string, chainIdOrName: number | ChainName): `0x${string}` | null {
    const chainId = typeof chainIdOrName === 'string' ? CHAINS[chainIdOrName] : chainIdOrName;
    
    // Try exact name first
    let address = getOriginContractAddress(contractName, chainId);
    
    // If not found and doesn't start with 'I', try with 'I' prefix
    if (!address && !contractName.startsWith('I')) {
      address = getOriginContractAddress('I' + contractName, chainId);
    }
    
    // If not found and starts with 'I', try without 'I' prefix
    if (!address && contractName.startsWith('I')) {
      address = getOriginContractAddress(contractName.substring(1), chainId);
    }

    return address;
  }

  /**
   * Check if an origin contract exists on the current chain
   * @param contractName - Name of the contract
   * @returns True if the origin contract exists
   */
  hasOriginContract(contractName: string): boolean {
    if (!this.currentChainId) {
      return false;
    }

    const address = this.getOriginAddressForChain(contractName, this.currentChainId);
    return address !== null;
  }

  /**
   * Get all origin contract names available on the current chain
   * @returns Array of origin contract names
   */
  getAllOriginContracts(): string[] {
    if (!this.currentChainId) {
      throw new Error('Chain not set. Call setChain() first.');
    }

    const chainName = this.getChainName();
    return Object.keys(ORIGIN_CONTRACT_ADDRESSES)
      .filter(name => ORIGIN_CONTRACT_ADDRESSES[name][chainName as ChainName])
      .sort();
  }
}

// Export a singleton instance
export const addresses = new AddressManager();

// Also export the class for advanced usage
export { AddressManager };

// Export the contract addresses for advanced usage
export { CONTRACT_ADDRESSES, ORIGIN_CONTRACT_ADDRESSES };


================================================
FILE: .github/actions/install/action.yml
================================================
name: Setup and Install

inputs:
  bun-version:
    required: false
    default: 'latest'
  working-directory:
    required: false
    default: '.'

runs:
  using: 'composite'
  steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Setup Bun
      uses: oven-sh/setup-bun@v2
      with:
        bun-version: ${{ inputs.bun-version }}
        
    - name: Install dependencies
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: bun install


================================================
FILE: .github/workflows/build.yml
================================================
name: Build project

on:
  workflow_call:
    inputs:
      runner:
        type: string
        default: 'ubuntu-latest'

jobs:
  build:
    runs-on: ${{ inputs.runner }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup and Install
        uses: ./.github/actions/install

      - name: Build
        run: bun run build:all

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-files
          path: dist/


================================================
FILE: .github/workflows/deploy-arns.yml
================================================
name: Arweave Deploy

on:
  push:
    branches:
      - main
jobs:
  Arweave-build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Run deployment script
        env:
          DEPLOY_KEY: ${{ secrets.DEPLOY_KEY }}
        run: |
          bun install
          bun run deploy:arns



================================================
FILE: .github/workflows/deploy.yml
================================================
name: Deploy to GitHub Pages

on:
  push:
    branches: ["**"]
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment
concurrency:
  group: "pages"
  cancel-in-progress: true

jobs:
  install:
    uses: ./.github/workflows/install.yml

  build:
    uses: ./.github/workflows/build.yml
    needs: install

  deploy:
    if: ${{ github.ref == 'refs/heads/main' }}
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: build-files
          path: dist/

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: 'dist'

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4 


================================================
FILE: .github/workflows/install.yml
================================================
name: Install Dependencies 

on:
  workflow_call:
    inputs:
      runner:
        type: string
        default: 'ubuntu-latest'

jobs:
  install:
    runs-on: ${{ inputs.runner }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup and Install
        uses: ./.github/actions/install

